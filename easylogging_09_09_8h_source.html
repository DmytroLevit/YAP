<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAP: include/easylogging++.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>include/easylogging++.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  Easylogging++ v9.80</span>
<a name="l00003"></a>00003 <span class="comment">//  Single-header only, cross-platform logging library for C++ applications</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//  Copyright (c) 2015 muflihun.com</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//  This library is released under the MIT Licence.</span>
<a name="l00008"></a>00008 <span class="comment">//  http://easylogging.muflihun.com/licence.php</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">//  easylogging@muflihun.com</span>
<a name="l00011"></a>00011 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment">//  https://github.com/easylogging/easyloggingpp</span>
<a name="l00013"></a>00013 <span class="comment">//  http://easylogging.muflihun.com</span>
<a name="l00014"></a>00014 <span class="comment">//  http://muflihun.com</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="preprocessor">#ifndef EASYLOGGINGPP_H</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#define EASYLOGGINGPP_H</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="comment">// Compilers and C++0x/C++11 Evaluation</span>
<a name="l00019"></a>00019 <span class="preprocessor">#if defined(__GNUC__)</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_COMPILER_GCC 1</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_GCC_VERSION (__GNUC__ * 10000 \</span>
<a name="l00022"></a>00022 <span class="preprocessor">                               + __GNUC_MINOR__ * 100 \</span>
<a name="l00023"></a>00023 <span class="preprocessor">                               + __GNUC_PATCHLEVEL__)</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#   if defined(__GXX_EXPERIMENTAL_CXX0X__)</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_CXX0X 1</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#   elif(ELPP_GCC_VERSION &gt;= 40801)</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_CXX11 1</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#   endif  // defined(__GXX_EXPERIMENTAL_CXX0X__)</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(__GNUC__)</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="comment">// Visual C++</span>
<a name="l00031"></a>00031 <span class="preprocessor">#if defined(_MSC_VER)</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_COMPILER_MSVC 1</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CRT_DBG_WARNINGS 1</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#   if (_MSC_VER == 1600)</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_CXX0X 1</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#   elif(_MSC_VER &gt;= 1700)</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_CXX11 1</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#   endif  // (_MSC_VER == 1600)</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(_MSC_VER)</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="comment">// Clang++</span>
<a name="l00041"></a>00041 <span class="preprocessor">#if defined(__clang__) &amp;&amp; (__clang__ == 1)</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_COMPILER_CLANG 1</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CLANG_VERSION (__clang_major__ * 10000 \</span>
<a name="l00044"></a>00044 <span class="preprocessor">                                + __clang_minor__ * 100 \</span>
<a name="l00045"></a>00045 <span class="preprocessor">                                + __clang_patchlevel__)</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#   if (ELPP_CLANG_VERSION &gt;= 30300)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_CXX11 1</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#   endif  // (ELPP_CLANG_VERSION &gt;= 30300)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(__clang__) &amp;&amp; (__clang__ == 1)</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="comment">// MinGW</span>
<a name="l00051"></a>00051 <span class="preprocessor">#if defined(__MINGW32__) || defined(__MINGW64__)</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_MINGW 1</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(__MINGW32__) || defined(__MINGW64__)</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="comment">// Cygwin</span>
<a name="l00055"></a>00055 <span class="preprocessor">#if defined(__CYGWIN__) &amp;&amp; (__CYGWIN__ == 1)</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CYGWIN 1</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(__CYGWIN__) &amp;&amp; (__CYGWIN__ == 1)</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="comment">// Intel C++</span>
<a name="l00059"></a>00059 <span class="preprocessor">#if defined(__INTEL_COMPILER)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_COMPILER_INTEL 1</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="comment">// Operating System Evaluation</span>
<a name="l00063"></a>00063 <span class="comment">// Windows</span>
<a name="l00064"></a>00064 <span class="preprocessor">#if defined(_WIN32) || defined(_WIN64)</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_WINDOWS 1</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(_WIN32) || defined(_WIN64)</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="comment">// Linux</span>
<a name="l00068"></a>00068 <span class="preprocessor">#if (defined(__linux) || defined(__linux__))</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_LINUX 1</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#endif  // (defined(__linux) || defined(__linux__))</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="comment">// Mac</span>
<a name="l00072"></a>00072 <span class="preprocessor">#if defined(__APPLE__)</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_MAC 1</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(__APPLE__)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="comment">// FreeBSD</span>
<a name="l00076"></a>00076 <span class="preprocessor">#if defined(__FreeBSD__)</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_FREEBSD 1</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="comment">// Solaris</span>
<a name="l00080"></a>00080 <span class="preprocessor">#if defined(__sun)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_SOLARIS 1</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="comment">// Unix</span>
<a name="l00084"></a>00084 <span class="preprocessor">#if ((ELPP_OS_LINUX || ELPP_OS_MAC || ELPP_OS_FREEBSD || ELPP_OS_SOLARIS) &amp;&amp; (!ELPP_OS_WINDOWS))</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_UNIX 1</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#endif  // ((ELPP_OS_LINUX || ELPP_OS_MAC || ELPP_OS_FREEBSD || ELPP_OS_SOLARIS) &amp;&amp; (!ELPP_OS_WINDOWS))</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="comment">// Android</span>
<a name="l00088"></a>00088 <span class="preprocessor">#if defined(__ANDROID__)</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_ANDROID 1</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(__ANDROID__)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="comment">// Evaluating Cygwin as *nix OS</span>
<a name="l00092"></a>00092 <span class="preprocessor">#if !ELPP_OS_UNIX &amp;&amp; !ELPP_OS_WINDOWS &amp;&amp; ELPP_CYGWIN</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#   undef ELPP_OS_UNIX</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#   undef ELPP_OS_LINUX</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_UNIX 1</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_OS_LINUX 1</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#endif //  !ELPP_OS_UNIX &amp;&amp; !ELPP_OS_WINDOWS &amp;&amp; ELPP_CYGWIN</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#if !defined(ELPP_INTERNAL_DEBUGGING_OUT_INFO)</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_DEBUGGING_OUT_INFO std::cout</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#if !defined(ELPP_INTERNAL_DEBUGGING_OUT_ERROR)</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_DEBUGGING_OUT_ERROR std::cerr</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#if !defined(ELPP_INTERNAL_DEBUGGING_ENDL)</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_DEBUGGING_ENDL std::endl</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#if !defined(ELPP_INTERNAL_DEBUGGING_MSG)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_DEBUGGING_MSG(msg) msg</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="comment">// Internal Assertions and errors</span>
<a name="l00111"></a>00111 <span class="preprocessor">#if !defined(ELPP_DISABLE_ASSERT)</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#   if (defined(ELPP_DEBUG_ASSERT_FAILURE))</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_ASSERT(expr, msg) if (!(expr)) { \</span>
<a name="l00114"></a>00114 <span class="preprocessor">          std::stringstream internalInfoStream; internalInfoStream &lt;&lt; msg; \</span>
<a name="l00115"></a>00115 <span class="preprocessor">          ELPP_INTERNAL_DEBUGGING_OUT_ERROR \</span>
<a name="l00116"></a>00116 <span class="preprocessor">              &lt;&lt; &quot;EASYLOGGING++ ASSERTION FAILED (LINE: &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) [&quot; #expr &lt;&lt; &quot;] WITH MESSAGE \&quot;&quot; \</span>
<a name="l00117"></a>00117 <span class="preprocessor">              &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; base::utils::abort(1, \</span>
<a name="l00118"></a>00118 <span class="preprocessor">                  &quot;ELPP Assertion failure, please define ELPP_DEBUG_ASSERT_FAILURE&quot;); }</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_ASSERT(expr, msg) if (!(expr)) { \</span>
<a name="l00121"></a>00121 <span class="preprocessor">          std::stringstream internalInfoStream; internalInfoStream &lt;&lt; msg; \</span>
<a name="l00122"></a>00122 <span class="preprocessor">          ELPP_INTERNAL_DEBUGGING_OUT_ERROR\</span>
<a name="l00123"></a>00123 <span class="preprocessor">             &lt;&lt; &quot;ASSERTION FAILURE FROM EASYLOGGING++ (LINE: &quot; \</span>
<a name="l00124"></a>00124 <span class="preprocessor">             &lt;&lt; __LINE__ &lt;&lt; &quot;) [&quot; #expr &lt;&lt; &quot;] WITH MESSAGE \&quot;&quot; &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) &lt;&lt; &quot;\&quot;&quot; \</span>
<a name="l00125"></a>00125 <span class="preprocessor">             &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; }</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#   endif  // (defined(ELPP_DEBUG_ASSERT_FAILURE))</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_ASSERT(x, y)</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor">#endif  //(!defined(ELPP_DISABLE_ASSERT)</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_COMPILER_MSVC</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_DEBUGGING_WRITE_PERROR \</span>
<a name="l00132"></a>00132 <span class="preprocessor">       { char buff[256]; strerror_s(buff, 256, errno); \</span>
<a name="l00133"></a>00133 <span class="preprocessor">       ELPP_INTERNAL_DEBUGGING_OUT_ERROR &lt;&lt; &quot;: &quot; &lt;&lt; buff &lt;&lt; &quot; [&quot; &lt;&lt; errno &lt;&lt; &quot;]&quot;;} (void)0</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_DEBUGGING_WRITE_PERROR \</span>
<a name="l00136"></a>00136 <span class="preprocessor">        ELPP_INTERNAL_DEBUGGING_OUT_ERROR &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno) &lt;&lt; &quot; [&quot; &lt;&lt; errno &lt;&lt; &quot;]&quot;; (void)0</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_COMPILER_MSVC</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_DEBUG_ERRORS)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#   if !defined(ELPP_INTERNAL_ERROR)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_INTERNAL_ERROR(msg, pe) { \</span>
<a name="l00141"></a>00141 <span class="preprocessor">          std::stringstream internalInfoStream; internalInfoStream &lt;&lt; &quot;&lt;ERROR&gt; &quot; &lt;&lt; msg; \</span>
<a name="l00142"></a>00142 <span class="preprocessor">          ELPP_INTERNAL_DEBUGGING_OUT_ERROR \</span>
<a name="l00143"></a>00143 <span class="preprocessor">          &lt;&lt; &quot;ERROR FROM EASYLOGGING++ (LINE: &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) &quot; \</span>
<a name="l00144"></a>00144 <span class="preprocessor">          &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; \</span>
<a name="l00145"></a>00145 <span class="preprocessor">          if (pe) { ELPP_INTERNAL_DEBUGGING_OUT_ERROR &lt;&lt; &quot;    &quot;; ELPP_INTERNAL_DEBUGGING_WRITE_PERROR; }} (void)0</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="preprocessor">#   endif</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#   undef ELPP_INTERNAL_INFO</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_ERROR(msg, pe)</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_DEBUG_ERRORS)</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="preprocessor">#if (defined(ELPP_DEBUG_INFO))</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="preprocessor">#   if !(defined(ELPP_INTERNAL_INFO_LEVEL))</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_INTERNAL_INFO_LEVEL 9</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">#   endif  // !(defined(ELPP_INTERNAL_INFO_LEVEL))</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#   if !defined(ELPP_INTERNAL_INFO)</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_INTERNAL_INFO(lvl, msg) { if (lvl &lt;= ELPP_INTERNAL_INFO_LEVEL) { \</span>
<a name="l00157"></a>00157 <span class="preprocessor">          std::stringstream internalInfoStream; internalInfoStream &lt;&lt; &quot;&lt;INFO&gt; &quot; &lt;&lt; msg; \</span>
<a name="l00158"></a>00158 <span class="preprocessor">          ELPP_INTERNAL_DEBUGGING_OUT_INFO &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) \</span>
<a name="l00159"></a>00159 <span class="preprocessor">             &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; }}</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#   endif</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="preprocessor">#   undef ELPP_INTERNAL_INFO</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INTERNAL_INFO(lvl, msg)</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#endif  // (defined(ELPP_DEBUG_INFO))</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_STACKTRACE_ON_CRASH)</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">#   if (ELPP_COMPILER_GCC &amp;&amp; !ELPP_MINGW)</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_STACKTRACE 1</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="preprocessor">#      if ELPP_COMPILER_MSVC</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor">#         pragma message(&quot;Stack trace not available for this compiler&quot;)</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="preprocessor">#      else</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">#         warning &quot;Stack trace not available for this compiler&quot;;</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span><span class="preprocessor">#      endif  // ELPP_COMPILER_MSVC</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">#   endif  // ELPP_COMPILER_GCC</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#endif  // (defined(ELPP_STACKTRACE_ON_CRASH))</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="comment">// Miscellaneous macros</span>
<a name="l00177"></a>00177 <span class="preprocessor">#define ELPP_UNUSED(x) (void)x</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="comment">// Log file permissions for unix-based systems</span>
<a name="l00180"></a>00180 <span class="preprocessor">#   define ELPP_LOG_PERMS S_IRUSR | S_IWUSR | S_IXUSR | S_IWGRP | S_IRGRP | S_IXGRP | S_IWOTH | S_IXOTH</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_AS_DLL) &amp;&amp; ELPP_COMPILER_MSVC</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#   if defined(ELPP_EXPORT_SYMBOLS)</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_EXPORT __declspec(dllexport)</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_EXPORT __declspec(dllimport)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#   endif  // defined(ELPP_EXPORT_SYMBOLS)</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_EXPORT</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_AS_DLL) &amp;&amp; ELPP_COMPILER_MSVC</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span><span class="comment">// Some special functions that are VC++ specific</span>
<a name="l00192"></a>00192 <span class="preprocessor">#undef STRTOK</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#undef STRERROR</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#undef STRCAT</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span><span class="preprocessor">#undef STRCPY</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_CRT_DBG_WARNINGS</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span><span class="preprocessor">#   define STRTOK(a, b, c) strtok_s(a, b, c)</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span><span class="preprocessor">#   define STRERROR(a, b, c) strerror_s(a, b, c)</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#   define STRCAT(a, b, len) strcat_s(a, len, b)</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="preprocessor">#   define STRCPY(a, b, len) strcpy_s(a, len, b)</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="preprocessor">#   define STRTOK(a, b, c) strtok(a, b)</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span><span class="preprocessor">#   define STRERROR(a, b, c) strerror(c)</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="preprocessor">#   define STRCAT(a, b, len) strcat(a, b)</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span><span class="preprocessor">#   define STRCPY(a, b, len) strcpy(a, b)</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span><span class="comment">// Compiler specific support evaluations</span>
<a name="l00208"></a>00208 <span class="preprocessor">#if (!ELPP_MINGW &amp;&amp; !ELPP_COMPILER_CLANG) || defined(ELPP_FORCE_USE_STD_THREAD)</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_USE_STD_THREADING 1</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!ELPP_MINGW &amp;&amp; !ELPP_COMPILER_CLANG) || defined(ELPP_FORCE_USE_STD_THREAD)</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_FINAL</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_COMPILER_INTEL || (ELPP_GCC_VERSION &lt; 40702)</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FINAL</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FINAL final</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_COMPILER_INTEL || (ELPP_GCC_VERSION &lt; 40702)</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_EXPERIMENTAL_ASYNC)</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_ASYNC_LOGGING 1</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_ASYNC_LOGGING 0</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_EXPERIMENTAL_ASYNC)</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_THREAD_SAFE) || ELPP_ASYNC_LOGGING</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_THREADING_ENABLED 1</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_THREAD_SAFE) || ELPP_ASYNC_LOGGING</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span><span class="comment">// Function macro ELPP_FUNC</span>
<a name="l00226"></a>00226 <span class="preprocessor">#undef ELPP_FUNC</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_COMPILER_MSVC  // Visual C++</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FUNC __FUNCSIG__</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="preprocessor">#elif ELPP_COMPILER_GCC  // GCC</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FUNC __PRETTY_FUNCTION__</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span><span class="preprocessor">#elif ELPP_COMPILER_INTEL  // Intel C++</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FUNC __PRETTY_FUNCTION__</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span><span class="preprocessor">#elif ELPP_COMPILER_CLANG  // Clang++</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FUNC __PRETTY_FUNCTION__</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span><span class="preprocessor">#   if defined(__func__)</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_FUNC __func__</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_FUNC &quot;&quot;</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span><span class="preprocessor">#   endif  // defined(__func__)</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(_MSC_VER)</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="comment">// Keep following line commented until features are fixed</span>
<a name="l00244"></a>00244 <span class="preprocessor">#if ELPP_COMPILER_GCC || ELPP_COMPILER_CLANG || ELPP_COMPILER_INTEL || (ELPP_COMPILER_MSVC &amp;&amp; _MSC_VER &gt;= 1800)</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_VARIADIC_TEMPLATES_SUPPORTED 1</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_COMPILER_GCC || ELPP_COMPILER_CLANG || ELPP_COMPILER_INTEL || (ELPP_COMPILER_MSVC &amp;&amp; _MSC_VER &gt;= 1800)</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span><span class="comment">// Logging Enable/Disable macros</span>
<a name="l00248"></a>00248 <span class="preprocessor">#if (!defined(ELPP_DISABLE_LOGS))</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_LOGGING_ENABLED 1</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_LOGS))</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_DEBUG_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED) &amp;&amp; ((defined(_DEBUG)) || (!defined(NDEBUG))))</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_DEBUG_LOG 1</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_DEBUG_LOG 0</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_DEBUG_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED) &amp;&amp; ((defined(_DEBUG)) || (!defined(NDEBUG))))</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_INFO_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INFO_LOG 1</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_INFO_LOG 0</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_INFO_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_WARNING_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WARNING_LOG 1</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WARNING_LOG 0</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_WARNING_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_ERROR_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_ERROR_LOG 1</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_ERROR_LOG 0</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_ERROR_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_FATAL_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FATAL_LOG 1</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_FATAL_LOG 0</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_FATAL_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_TRACE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_TRACE_LOG 1</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_TRACE_LOG 0</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_TRACE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span><span class="preprocessor">#if (!defined(ELPP_DISABLE_VERBOSE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_VERBOSE_LOG 1</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_VERBOSE_LOG 0</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!defined(ELPP_DISABLE_VERBOSE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span><span class="preprocessor">#if (!(ELPP_CXX0X || ELPP_CXX11))</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#   error &quot;Easylogging++ 9.0+ is only compatible with C++0x (or higher) compliant compiler&quot;</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span><span class="preprocessor">#endif  // (!(ELPP_CXX0X || ELPP_CXX11))</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span><span class="comment">// Headers</span>
<a name="l00290"></a>00290 <span class="preprocessor">#if defined(ELPP_SYSLOG)</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;syslog.h&gt;</span>
<a name="l00292"></a>00292 <span class="preprocessor">#endif  // defined(ELPP_SYSLOG)</span>
<a name="l00293"></a>00293 <span class="preprocessor"></span><span class="preprocessor">#include &lt;ctime&gt;</span>
<a name="l00294"></a>00294 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00295"></a>00295 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<a name="l00296"></a>00296 <span class="preprocessor">#include &lt;cctype&gt;</span>
<a name="l00297"></a>00297 <span class="preprocessor">#include &lt;cwchar&gt;</span>
<a name="l00298"></a>00298 <span class="preprocessor">#include &lt;csignal&gt;</span>
<a name="l00299"></a>00299 <span class="preprocessor">#include &lt;cerrno&gt;</span>
<a name="l00300"></a>00300 <span class="preprocessor">#include &lt;cstdarg&gt;</span>
<a name="l00301"></a>00301 <span class="preprocessor">#if defined(ELPP_UNICODE)</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;locale&gt;</span>
<a name="l00303"></a>00303 <span class="preprocessor">#   if ELPP_OS_WINDOWS</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span><span class="preprocessor">#      include &lt;codecvt&gt;</span>
<a name="l00305"></a>00305 <span class="preprocessor">#   endif // ELPP_OS_WINDOWS</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_UNICODE)</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_STACKTRACE</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;cxxabi.h&gt;</span>
<a name="l00309"></a>00309 <span class="preprocessor">#   include &lt;execinfo.h&gt;</span>
<a name="l00310"></a>00310 <span class="preprocessor">#endif  // ELPP_STACKTRACE</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_OS_ANDROID</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;sys/system_properties.h&gt;</span>
<a name="l00313"></a>00313 <span class="preprocessor">#endif  // ELPP_OS_ANDROID</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;sys/stat.h&gt;</span>
<a name="l00316"></a>00316 <span class="preprocessor">#   include &lt;sys/time.h&gt;</span>
<a name="l00317"></a>00317 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;direct.h&gt;</span>
<a name="l00319"></a>00319 <span class="preprocessor">#   include &lt;windows.h&gt;</span>
<a name="l00320"></a>00320 <span class="preprocessor">#   if defined(WIN32_LEAN_AND_MEAN)</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span><span class="preprocessor">#      if defined(ELPP_WINSOCK2)</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span><span class="preprocessor">#         include &lt;winsock2.h&gt;</span>
<a name="l00323"></a>00323 <span class="preprocessor">#          else</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span><span class="preprocessor">#         include &lt;winsock.h&gt;</span>
<a name="l00325"></a>00325 <span class="preprocessor">#      endif // defined(ELPP_WINSOCK2)</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span><span class="preprocessor">#   endif // defined(WIN32_LEAN_AND_MEAN)</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00329"></a>00329 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00330"></a>00330 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00331"></a>00331 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00332"></a>00332 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00333"></a>00333 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00334"></a>00334 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00335"></a>00335 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00336"></a>00336 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00337"></a>00337 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00338"></a>00338 <span class="preprocessor">#include &lt;type_traits&gt;</span>
<a name="l00339"></a>00339 <span class="preprocessor">#if ELPP_THREADING_ENABLED</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_USE_STD_THREADING</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span><span class="preprocessor">#      include &lt;mutex&gt;</span>
<a name="l00342"></a>00342 <span class="preprocessor">#      include &lt;thread&gt;</span>
<a name="l00343"></a>00343 <span class="preprocessor">#   else</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span><span class="preprocessor">#      if ELPP_OS_UNIX</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span><span class="preprocessor">#         include &lt;pthread.h&gt;</span>
<a name="l00346"></a>00346 <span class="preprocessor">#      endif  // ELPP_OS_UNIX</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span><span class="preprocessor">#   endif  // ELPP_USE_STD_THREADING</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_THREADING_ENABLED</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;thread&gt;</span>
<a name="l00351"></a>00351 <span class="preprocessor">#   include &lt;queue&gt;</span>
<a name="l00352"></a>00352 <span class="preprocessor">#   include &lt;condition_variable&gt;</span>
<a name="l00353"></a>00353 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING </span>
<a name="l00354"></a>00354 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_STL_LOGGING)</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span><span class="comment">// For logging STL based templates</span>
<a name="l00356"></a>00356 <span class="preprocessor">#   include &lt;list&gt;</span>
<a name="l00357"></a>00357 <span class="preprocessor">#   include &lt;queue&gt;</span>
<a name="l00358"></a>00358 <span class="preprocessor">#   include &lt;deque&gt;</span>
<a name="l00359"></a>00359 <span class="preprocessor">#   include &lt;set&gt;</span>
<a name="l00360"></a>00360 <span class="preprocessor">#   include &lt;bitset&gt;</span>
<a name="l00361"></a>00361 <span class="preprocessor">#   include &lt;stack&gt;</span>
<a name="l00362"></a>00362 <span class="preprocessor">#   if defined(ELPP_LOG_STD_ARRAY)</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span><span class="preprocessor">#      include &lt;array&gt;</span>
<a name="l00364"></a>00364 <span class="preprocessor">#   endif  // defined(ELPP_LOG_STD_ARRAY)</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span><span class="preprocessor">#   if defined(ELPP_LOG_UNORDERED_MAP)</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span><span class="preprocessor">#      include &lt;unordered_map&gt;</span>
<a name="l00367"></a>00367 <span class="preprocessor">#   endif  // defined(ELPP_LOG_UNORDERED_MAP)</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span><span class="preprocessor">#   if defined(ELPP_LOG_UNORDERED_SET)</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span><span class="preprocessor">#      include &lt;unordered_set&gt;</span>
<a name="l00370"></a>00370 <span class="preprocessor">#   endif  // defined(ELPP_UNORDERED_SET)</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_STL_LOGGING)</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_QT_LOGGING)</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span><span class="comment">// For logging Qt based classes &amp; templates</span>
<a name="l00374"></a>00374 <span class="preprocessor">#   include &lt;QString&gt;</span>
<a name="l00375"></a>00375 <span class="preprocessor">#   include &lt;QByteArray&gt;</span>
<a name="l00376"></a>00376 <span class="preprocessor">#   include &lt;QVector&gt;</span>
<a name="l00377"></a>00377 <span class="preprocessor">#   include &lt;QList&gt;</span>
<a name="l00378"></a>00378 <span class="preprocessor">#   include &lt;QPair&gt;</span>
<a name="l00379"></a>00379 <span class="preprocessor">#   include &lt;QMap&gt;</span>
<a name="l00380"></a>00380 <span class="preprocessor">#   include &lt;QQueue&gt;</span>
<a name="l00381"></a>00381 <span class="preprocessor">#   include &lt;QSet&gt;</span>
<a name="l00382"></a>00382 <span class="preprocessor">#   include &lt;QLinkedList&gt;</span>
<a name="l00383"></a>00383 <span class="preprocessor">#   include &lt;QHash&gt;</span>
<a name="l00384"></a>00384 <span class="preprocessor">#   include &lt;QMultiHash&gt;</span>
<a name="l00385"></a>00385 <span class="preprocessor">#   include &lt;QStack&gt;</span>
<a name="l00386"></a>00386 <span class="preprocessor">#endif  // defined(ELPP_QT_LOGGING)</span>
<a name="l00387"></a>00387 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_BOOST_LOGGING)</span>
<a name="l00388"></a>00388 <span class="preprocessor"></span><span class="comment">// For logging boost based classes &amp; templates</span>
<a name="l00389"></a>00389 <span class="preprocessor">#   include &lt;boost/container/vector.hpp&gt;</span>
<a name="l00390"></a>00390 <span class="preprocessor">#   include &lt;boost/container/stable_vector.hpp&gt;</span>
<a name="l00391"></a>00391 <span class="preprocessor">#   include &lt;boost/container/list.hpp&gt;</span>
<a name="l00392"></a>00392 <span class="preprocessor">#   include &lt;boost/container/deque.hpp&gt;</span>
<a name="l00393"></a>00393 <span class="preprocessor">#   include &lt;boost/container/map.hpp&gt;</span>
<a name="l00394"></a>00394 <span class="preprocessor">#   include &lt;boost/container/flat_map.hpp&gt;</span>
<a name="l00395"></a>00395 <span class="preprocessor">#   include &lt;boost/container/set.hpp&gt;</span>
<a name="l00396"></a>00396 <span class="preprocessor">#   include &lt;boost/container/flat_set.hpp&gt;</span>
<a name="l00397"></a>00397 <span class="preprocessor">#endif  // defined(ELPP_BOOST_LOGGING)</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_WXWIDGETS_LOGGING)</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span><span class="comment">// For logging wxWidgets based classes &amp; templates</span>
<a name="l00400"></a>00400 <span class="preprocessor">#   include &lt;wx/vector.h&gt;</span>
<a name="l00401"></a>00401 <span class="preprocessor">#endif  // defined(ELPP_WXWIDGETS_LOGGING)</span>
<a name="l00402"></a>00402 <span class="preprocessor"></span><span class="comment">// Forward declarations</span>
<a name="l00403"></a>00403 <span class="keyword">namespace </span>el {
<a name="l00404"></a>00404 <span class="keyword">class </span>Logger;
<a name="l00405"></a>00405 <span class="keyword">class </span>LogMessage;
<a name="l00406"></a>00406 <span class="keyword">class </span>PerformanceTrackingData;
<a name="l00407"></a>00407 <span class="keyword">class </span>Loggers;
<a name="l00408"></a>00408 <span class="keyword">class </span>Helpers;
<a name="l00409"></a>00409 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>Callback;
<a name="l00410"></a>00410 <span class="keyword">class </span>LogDispatchCallback;
<a name="l00411"></a>00411 <span class="keyword">class </span>PerformanceTrackingCallback;
<a name="l00412"></a>00412 <span class="keyword">class </span>LogDispatchData;
<a name="l00413"></a>00413 <span class="keyword">namespace </span>base {
<a name="l00414"></a>00414 <span class="keyword">class </span>Storage;
<a name="l00415"></a>00415 <span class="keyword">class </span>RegisteredLoggers;
<a name="l00416"></a>00416 <span class="keyword">class </span>PerformanceTracker;
<a name="l00417"></a>00417 <span class="keyword">class </span>MessageBuilder;
<a name="l00418"></a>00418 <span class="keyword">class </span>Writer;
<a name="l00419"></a>00419 <span class="keyword">class </span>PErrorWriter;
<a name="l00420"></a>00420 <span class="keyword">class </span>LogDispatcher;
<a name="l00421"></a>00421 <span class="keyword">class </span>DefaultLogBuilder;
<a name="l00422"></a>00422 <span class="keyword">class </span>DefaultLogDispatchCallback;
<a name="l00423"></a>00423 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span><span class="keyword">class </span>AsyncLogDispatchCallback;
<a name="l00425"></a>00425 <span class="keyword">class </span>AsyncDispatchWorker;
<a name="l00426"></a>00426 <span class="preprocessor">#endif // ELPP_ASYNC_LOGGING</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span><span class="keyword">class </span>DefaultPerformanceTrackingCallback;
<a name="l00428"></a>00428 }  <span class="comment">// namespace base</span>
<a name="l00429"></a>00429 }  <span class="comment">// namespace el</span>
<a name="l00431"></a>00431 <span class="comment"></span><span class="keyword">namespace </span>el {
<a name="l00433"></a>00433 <span class="keyword">namespace </span>base {
<a name="l00435"></a>00435 <span class="keyword">namespace </span>type {
<a name="l00436"></a>00436 <span class="preprocessor">#undef ELPP_LITERAL</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_STRLEN</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_COUT</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_UNICODE)</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_LITERAL(txt) L##txt</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_STRLEN wcslen</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span><span class="preprocessor">#   if defined ELPP_CUSTOM_COUT</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_COUT ELPP_CUSTOM_COUT</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_COUT std::wcout</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span><span class="preprocessor">#   endif  // defined ELPP_CUSTOM_COUT</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">wchar_t</span> char_t;
<a name="l00448"></a>00448 <span class="keyword">typedef</span> std::wstring string_t;
<a name="l00449"></a>00449 <span class="keyword">typedef</span> std::wstringstream stringstream_t;
<a name="l00450"></a>00450 <span class="keyword">typedef</span> std::wfstream fstream_t;
<a name="l00451"></a>00451 <span class="keyword">typedef</span> std::wostream ostream_t;
<a name="l00452"></a>00452 <span class="preprocessor">#else</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_LITERAL(txt) txt</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_STRLEN strlen</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span><span class="preprocessor">#   if defined ELPP_CUSTOM_COUT</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_COUT ELPP_CUSTOM_COUT</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span><span class="preprocessor">#      define ELPP_COUT std::cout</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span><span class="preprocessor">#   endif  // defined ELPP_CUSTOM_COUT</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">char</span> char_t;
<a name="l00461"></a>00461 <span class="keyword">typedef</span> std::string string_t;
<a name="l00462"></a>00462 <span class="keyword">typedef</span> std::stringstream stringstream_t;
<a name="l00463"></a>00463 <span class="keyword">typedef</span> std::fstream fstream_t;
<a name="l00464"></a>00464 <span class="keyword">typedef</span> std::ostream ostream_t;
<a name="l00465"></a>00465 <span class="preprocessor">#endif  // defined(ELPP_UNICODE)</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_CUSTOM_COUT_LINE)</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_COUT_LINE(logLine) ELPP_CUSTOM_COUT_LINE(logLine)</span>
<a name="l00468"></a>00468 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_COUT_LINE(logLine) logLine &lt;&lt; std::flush</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span><span class="preprocessor">#endif // defined(ELPP_CUSTOM_COUT_LINE)</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> EnumType;
<a name="l00472"></a>00472 <span class="keyword">typedef</span> std::shared_ptr&lt;base::Storage&gt; StoragePointer;
<a name="l00473"></a>00473 <span class="keyword">typedef</span> <span class="keywordtype">int</span> VerboseLevel;
<a name="l00474"></a>00474 <span class="keyword">typedef</span> std::shared_ptr&lt;LogDispatchCallback&gt; LogDispatchCallbackPtr;
<a name="l00475"></a>00475 <span class="keyword">typedef</span> std::shared_ptr&lt;PerformanceTrackingCallback&gt; PerformanceTrackingCallbackPtr;
<a name="l00476"></a>00476 }  <span class="comment">// namespace type</span>
<a name="l00480"></a>00480 <span class="comment"></span><span class="keyword">class </span>NoCopy
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482 <span class="keyword">protected</span>:
<a name="l00483"></a>00483     NoCopy(<span class="keywordtype">void</span>) {}
<a name="l00484"></a>00484 <span class="keyword">private</span>:
<a name="l00485"></a>00485     NoCopy(<span class="keyword">const</span> NoCopy&amp;);
<a name="l00486"></a>00486     NoCopy&amp; operator=(<span class="keyword">const</span> NoCopy&amp;);
<a name="l00487"></a>00487 };
<a name="l00492"></a>00492 <span class="keyword">class </span>StaticClass
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494 <span class="keyword">private</span>:
<a name="l00495"></a>00495     StaticClass(<span class="keywordtype">void</span>);
<a name="l00496"></a>00496     StaticClass(<span class="keyword">const</span> StaticClass&amp;);
<a name="l00497"></a>00497     StaticClass&amp; operator=(<span class="keyword">const</span> StaticClass&amp;);
<a name="l00498"></a>00498 };
<a name="l00499"></a>00499 }  <span class="comment">// namespace base</span>
<a name="l00504"></a>00504 <span class="comment"></span><span class="keyword">enum class</span> Level : base::type::EnumType {
<a name="l00506"></a>00506     Global = 1,
<a name="l00508"></a>00508     Trace = 2,
<a name="l00510"></a>00510     Debug = 4,
<a name="l00512"></a>00512     Fatal = 8,
<a name="l00514"></a>00514     Error = 16,
<a name="l00516"></a>00516     Warning = 32,
<a name="l00518"></a>00518     Verbose = 64,
<a name="l00520"></a>00520     Info = 128,
<a name="l00522"></a>00522     Unknown = 1010
<a name="l00523"></a>00523 };
<a name="l00525"></a>00525 <span class="keyword">class </span>LevelHelper : base::StaticClass
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527 <span class="keyword">public</span>:
<a name="l00529"></a>00529     <span class="keyword">static</span> <span class="keyword">const</span> base::type::EnumType kMinValid = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(Level::Trace);
<a name="l00531"></a>00531     <span class="keyword">static</span> <span class="keyword">const</span> base::type::EnumType kMaxValid = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(Level::Info);
<a name="l00533"></a>00533     <span class="keyword">static</span> base::type::EnumType castToInt(Level level)
<a name="l00534"></a>00534     {
<a name="l00535"></a>00535         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(level);
<a name="l00536"></a>00536     }
<a name="l00538"></a>00538     <span class="keyword">static</span> Level castFromInt(base::type::EnumType l)
<a name="l00539"></a>00539     {
<a name="l00540"></a>00540         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Level<span class="keyword">&gt;</span>(l);
<a name="l00541"></a>00541     }
<a name="l00544"></a>00544     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* convertToString(Level level)
<a name="l00545"></a>00545     {
<a name="l00546"></a>00546         <span class="comment">// Do not use switch over strongly typed enums because Intel C++ compilers dont support them yet.</span>
<a name="l00547"></a>00547         <span class="keywordflow">if</span> (level == Level::Global) <span class="keywordflow">return</span> <span class="stringliteral">&quot;GLOBAL&quot;</span>;
<a name="l00548"></a>00548         <span class="keywordflow">if</span> (level == Level::Debug) <span class="keywordflow">return</span> <span class="stringliteral">&quot;DEBUG&quot;</span>;
<a name="l00549"></a>00549         <span class="keywordflow">if</span> (level == Level::Info) <span class="keywordflow">return</span> <span class="stringliteral">&quot;INFO&quot;</span>;
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (level == Level::Warning) <span class="keywordflow">return</span> <span class="stringliteral">&quot;WARNING&quot;</span>;
<a name="l00551"></a>00551         <span class="keywordflow">if</span> (level == Level::Error) <span class="keywordflow">return</span> <span class="stringliteral">&quot;ERROR&quot;</span>;
<a name="l00552"></a>00552         <span class="keywordflow">if</span> (level == Level::Fatal) <span class="keywordflow">return</span> <span class="stringliteral">&quot;FATAL&quot;</span>;
<a name="l00553"></a>00553         <span class="keywordflow">if</span> (level == Level::Verbose) <span class="keywordflow">return</span> <span class="stringliteral">&quot;VERBOSE&quot;</span>;
<a name="l00554"></a>00554         <span class="keywordflow">if</span> (level == Level::Trace) <span class="keywordflow">return</span> <span class="stringliteral">&quot;TRACE&quot;</span>;
<a name="l00555"></a>00555         <span class="keywordflow">return</span> <span class="stringliteral">&quot;UNKNOWN&quot;</span>;
<a name="l00556"></a>00556     }
<a name="l00560"></a>00560     <span class="keyword">static</span> Level convertFromString(<span class="keyword">const</span> <span class="keywordtype">char</span>* levelStr)
<a name="l00561"></a>00561     {
<a name="l00562"></a>00562         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;GLOBAL&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;global&quot;</span>) == 0))
<a name="l00563"></a>00563             <span class="keywordflow">return</span> Level::Global;
<a name="l00564"></a>00564         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;DEBUG&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;debug&quot;</span>) == 0))
<a name="l00565"></a>00565             <span class="keywordflow">return</span> Level::Debug;
<a name="l00566"></a>00566         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;INFO&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;info&quot;</span>) == 0))
<a name="l00567"></a>00567             <span class="keywordflow">return</span> Level::Info;
<a name="l00568"></a>00568         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;WARNING&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;warning&quot;</span>) == 0))
<a name="l00569"></a>00569             <span class="keywordflow">return</span> Level::Warning;
<a name="l00570"></a>00570         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;ERROR&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;error&quot;</span>) == 0))
<a name="l00571"></a>00571             <span class="keywordflow">return</span> Level::Error;
<a name="l00572"></a>00572         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;FATAL&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;fatal&quot;</span>) == 0))
<a name="l00573"></a>00573             <span class="keywordflow">return</span> Level::Fatal;
<a name="l00574"></a>00574         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;VERBOSE&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;verbose&quot;</span>) == 0))
<a name="l00575"></a>00575             <span class="keywordflow">return</span> Level::Verbose;
<a name="l00576"></a>00576         <span class="keywordflow">if</span> ((strcmp(levelStr, <span class="stringliteral">&quot;TRACE&quot;</span>) == 0) || (strcmp(levelStr, <span class="stringliteral">&quot;trace&quot;</span>) == 0))
<a name="l00577"></a>00577             <span class="keywordflow">return</span> Level::Trace;
<a name="l00578"></a>00578         <span class="keywordflow">return</span> Level::Unknown;
<a name="l00579"></a>00579     }
<a name="l00584"></a>00584     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> forEachLevel(base::type::EnumType* startIndex, <span class="keyword">const</span> std::function&lt;<span class="keywordtype">bool</span>(<span class="keywordtype">void</span>)&gt;&amp; fn)
<a name="l00585"></a>00585     {
<a name="l00586"></a>00586         base::type::EnumType lIndexMax = LevelHelper::kMaxValid;
<a name="l00587"></a>00587         <span class="keywordflow">do</span> {
<a name="l00588"></a>00588             <span class="keywordflow">if</span> (fn()) {
<a name="l00589"></a>00589                 <span class="keywordflow">break</span>;
<a name="l00590"></a>00590             }
<a name="l00591"></a>00591             *startIndex = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(*startIndex &lt;&lt; 1);
<a name="l00592"></a>00592         } <span class="keywordflow">while</span> (*startIndex &lt;= lIndexMax);
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594 };
<a name="l00597"></a>00597 <span class="keyword">enum class</span> ConfigurationType : base::type::EnumType {
<a name="l00600"></a>00600     Enabled = 1,
<a name="l00602"></a>00602     ToFile = 2,
<a name="l00605"></a>00605     ToStandardOutput = 4,
<a name="l00607"></a>00607     Format = 8,
<a name="l00609"></a>00609     Filename = 16,
<a name="l00611"></a>00611     MillisecondsWidth = 32,
<a name="l00615"></a>00615     PerformanceTracking = 64,
<a name="l00620"></a>00620     MaxLogFileSize = 128,
<a name="l00622"></a>00622     LogFlushThreshold = 256,
<a name="l00624"></a>00624     Unknown = 1010
<a name="l00625"></a>00625 };
<a name="l00627"></a>00627 <span class="keyword">class </span>ConfigurationTypeHelper : base::StaticClass
<a name="l00628"></a>00628 {
<a name="l00629"></a>00629 <span class="keyword">public</span>:
<a name="l00631"></a>00631     <span class="keyword">static</span> <span class="keyword">const</span> base::type::EnumType kMinValid = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(ConfigurationType::Enabled);
<a name="l00633"></a>00633     <span class="keyword">static</span> <span class="keyword">const</span> base::type::EnumType kMaxValid = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(ConfigurationType::MaxLogFileSize);
<a name="l00635"></a>00635     <span class="keyword">static</span> base::type::EnumType castToInt(ConfigurationType configurationType)
<a name="l00636"></a>00636     {
<a name="l00637"></a>00637         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(configurationType);
<a name="l00638"></a>00638     }
<a name="l00640"></a>00640     <span class="keyword">static</span> ConfigurationType castFromInt(base::type::EnumType c)
<a name="l00641"></a>00641     {
<a name="l00642"></a>00642         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ConfigurationType<span class="keyword">&gt;</span>(c);
<a name="l00643"></a>00643     }
<a name="l00646"></a>00646     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* convertToString(ConfigurationType configurationType)
<a name="l00647"></a>00647     {
<a name="l00648"></a>00648         <span class="comment">// Do not use switch over strongly typed enums because Intel C++ compilers dont support them yet.</span>
<a name="l00649"></a>00649         <span class="keywordflow">if</span> (configurationType == ConfigurationType::Enabled) <span class="keywordflow">return</span> <span class="stringliteral">&quot;ENABLED&quot;</span>;
<a name="l00650"></a>00650         <span class="keywordflow">if</span> (configurationType == ConfigurationType::Filename) <span class="keywordflow">return</span> <span class="stringliteral">&quot;FILENAME&quot;</span>;
<a name="l00651"></a>00651         <span class="keywordflow">if</span> (configurationType == ConfigurationType::Format) <span class="keywordflow">return</span> <span class="stringliteral">&quot;FORMAT&quot;</span>;
<a name="l00652"></a>00652         <span class="keywordflow">if</span> (configurationType == ConfigurationType::ToFile) <span class="keywordflow">return</span> <span class="stringliteral">&quot;TO_FILE&quot;</span>;
<a name="l00653"></a>00653         <span class="keywordflow">if</span> (configurationType == ConfigurationType::ToStandardOutput) <span class="keywordflow">return</span> <span class="stringliteral">&quot;TO_STANDARD_OUTPUT&quot;</span>;
<a name="l00654"></a>00654         <span class="keywordflow">if</span> (configurationType == ConfigurationType::MillisecondsWidth) <span class="keywordflow">return</span> <span class="stringliteral">&quot;MILLISECONDS_WIDTH&quot;</span>;
<a name="l00655"></a>00655         <span class="keywordflow">if</span> (configurationType == ConfigurationType::PerformanceTracking) <span class="keywordflow">return</span> <span class="stringliteral">&quot;PERFORMANCE_TRACKING&quot;</span>;
<a name="l00656"></a>00656         <span class="keywordflow">if</span> (configurationType == ConfigurationType::MaxLogFileSize) <span class="keywordflow">return</span> <span class="stringliteral">&quot;MAX_LOG_FILE_SIZE&quot;</span>;
<a name="l00657"></a>00657         <span class="keywordflow">if</span> (configurationType == ConfigurationType::LogFlushThreshold) <span class="keywordflow">return</span> <span class="stringliteral">&quot;LOG_FLUSH_THRESHOLD&quot;</span>;
<a name="l00658"></a>00658         <span class="keywordflow">return</span> <span class="stringliteral">&quot;UNKNOWN&quot;</span>;
<a name="l00659"></a>00659     }
<a name="l00663"></a>00663     <span class="keyword">static</span> ConfigurationType convertFromString(<span class="keyword">const</span> <span class="keywordtype">char</span>* configStr)
<a name="l00664"></a>00664     {
<a name="l00665"></a>00665         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;ENABLED&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;enabled&quot;</span>) == 0))
<a name="l00666"></a>00666             <span class="keywordflow">return</span> ConfigurationType::Enabled;
<a name="l00667"></a>00667         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;TO_FILE&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;to_file&quot;</span>) == 0))
<a name="l00668"></a>00668             <span class="keywordflow">return</span> ConfigurationType::ToFile;
<a name="l00669"></a>00669         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;TO_STANDARD_OUTPUT&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;to_standard_output&quot;</span>) == 0))
<a name="l00670"></a>00670             <span class="keywordflow">return</span> ConfigurationType::ToStandardOutput;
<a name="l00671"></a>00671         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;FORMAT&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;format&quot;</span>) == 0))
<a name="l00672"></a>00672             <span class="keywordflow">return</span> ConfigurationType::Format;
<a name="l00673"></a>00673         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;FILENAME&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;filename&quot;</span>) == 0))
<a name="l00674"></a>00674             <span class="keywordflow">return</span> ConfigurationType::Filename;
<a name="l00675"></a>00675         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;MILLISECONDS_WIDTH&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;milliseconds_width&quot;</span>) == 0))
<a name="l00676"></a>00676             <span class="keywordflow">return</span> ConfigurationType::MillisecondsWidth;
<a name="l00677"></a>00677         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;PERFORMANCE_TRACKING&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;performance_tracking&quot;</span>) == 0))
<a name="l00678"></a>00678             <span class="keywordflow">return</span> ConfigurationType::PerformanceTracking;
<a name="l00679"></a>00679         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;MAX_LOG_FILE_SIZE&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;max_log_file_size&quot;</span>) == 0))
<a name="l00680"></a>00680             <span class="keywordflow">return</span> ConfigurationType::MaxLogFileSize;
<a name="l00681"></a>00681         <span class="keywordflow">if</span> ((strcmp(configStr, <span class="stringliteral">&quot;LOG_FLUSH_THRESHOLD&quot;</span>) == 0) || (strcmp(configStr, <span class="stringliteral">&quot;log_flush_threshold&quot;</span>) == 0))
<a name="l00682"></a>00682             <span class="keywordflow">return</span> ConfigurationType::LogFlushThreshold;
<a name="l00683"></a>00683         <span class="keywordflow">return</span> ConfigurationType::Unknown;
<a name="l00684"></a>00684     }
<a name="l00690"></a>00690     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> forEachConfigType(base::type::EnumType* startIndex, <span class="keyword">const</span> std::function&lt;<span class="keywordtype">bool</span>(<span class="keywordtype">void</span>)&gt;&amp; fn)
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692         base::type::EnumType cIndexMax = ConfigurationTypeHelper::kMaxValid;
<a name="l00693"></a>00693         <span class="keywordflow">do</span> {
<a name="l00694"></a>00694             <span class="keywordflow">if</span> (fn()) {
<a name="l00695"></a>00695                 <span class="keywordflow">break</span>;
<a name="l00696"></a>00696             }
<a name="l00697"></a>00697             *startIndex = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(*startIndex &lt;&lt; 1);
<a name="l00698"></a>00698         } <span class="keywordflow">while</span> (*startIndex &lt;= cIndexMax);
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 };
<a name="l00702"></a>00702 <span class="keyword">enum class</span> LoggingFlag : base::type::EnumType {
<a name="l00704"></a>00704     NewLineForContainer = 1,
<a name="l00707"></a>00707     AllowVerboseIfModuleNotSpecified = 2,
<a name="l00709"></a>00709     LogDetailedCrashReason = 4,
<a name="l00711"></a>00711     DisableApplicationAbortOnFatalLog = 8,
<a name="l00713"></a>00713     ImmediateFlush = 16,
<a name="l00715"></a>00715     StrictLogFileSizeCheck = 32,
<a name="l00717"></a>00717     ColoredTerminalOutput = 64,
<a name="l00719"></a>00719     MultiLoggerSupport = 128,
<a name="l00721"></a>00721     DisablePerformanceTrackingCheckpointComparison = 256,
<a name="l00723"></a>00723     DisableVModules = 512,
<a name="l00725"></a>00725     DisableVModulesExtensions = 1024,
<a name="l00727"></a>00727     HierarchicalLogging = 2048,
<a name="l00729"></a>00729     CreateLoggerAutomatically = 4096,
<a name="l00731"></a>00731     AutoSpacing = 8192,
<a name="l00733"></a>00733     FixedTimeFormat = 16384
<a name="l00734"></a>00734 };
<a name="l00735"></a>00735 <span class="keyword">namespace </span>base {
<a name="l00737"></a>00737 <span class="keyword">namespace </span>consts {
<a name="l00738"></a>00738 <span class="comment">// Level log values - These are values that are replaced in place of %level format specifier</span>
<a name="l00739"></a>00739 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kInfoLevelLogValue     =   ELPP_LITERAL(<span class="stringliteral">&quot;INFO &quot;</span>);
<a name="l00740"></a>00740 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kDebugLevelLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;DEBUG&quot;</span>);
<a name="l00741"></a>00741 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kWarningLevelLogValue  =   ELPP_LITERAL(<span class="stringliteral">&quot;WARN &quot;</span>);
<a name="l00742"></a>00742 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kErrorLevelLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;ERROR&quot;</span>);
<a name="l00743"></a>00743 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kFatalLevelLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;FATAL&quot;</span>);
<a name="l00744"></a>00744 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kVerboseLevelLogValue  =   ELPP_LITERAL(<span class="stringliteral">&quot;VER&quot;</span>);
<a name="l00745"></a>00745 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kTraceLevelLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;TRACE&quot;</span>);
<a name="l00746"></a>00746 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kInfoLevelShortLogValue     =   ELPP_LITERAL(<span class="stringliteral">&quot;I&quot;</span>);
<a name="l00747"></a>00747 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kDebugLevelShortLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;D&quot;</span>);
<a name="l00748"></a>00748 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kWarningLevelShortLogValue  =   ELPP_LITERAL(<span class="stringliteral">&quot;W&quot;</span>);
<a name="l00749"></a>00749 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kErrorLevelShortLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;E&quot;</span>);
<a name="l00750"></a>00750 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kFatalLevelShortLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;F&quot;</span>);
<a name="l00751"></a>00751 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kVerboseLevelShortLogValue  =   ELPP_LITERAL(<span class="stringliteral">&quot;V&quot;</span>);
<a name="l00752"></a>00752 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kTraceLevelShortLogValue    =   ELPP_LITERAL(<span class="stringliteral">&quot;T&quot;</span>);
<a name="l00753"></a>00753 <span class="comment">// Format specifiers - These are used to define log format</span>
<a name="l00754"></a>00754 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kAppNameFormatSpecifier          =      ELPP_LITERAL(<span class="stringliteral">&quot;%app&quot;</span>);
<a name="l00755"></a>00755 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kLoggerIdFormatSpecifier         =      ELPP_LITERAL(<span class="stringliteral">&quot;%logger&quot;</span>);
<a name="l00756"></a>00756 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kThreadIdFormatSpecifier         =      ELPP_LITERAL(<span class="stringliteral">&quot;%thread&quot;</span>);
<a name="l00757"></a>00757 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kSeverityLevelFormatSpecifier    =      ELPP_LITERAL(<span class="stringliteral">&quot;%level&quot;</span>);
<a name="l00758"></a>00758 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kSeverityLevelShortFormatSpecifier    =      ELPP_LITERAL(<span class="stringliteral">&quot;%levshort&quot;</span>);
<a name="l00759"></a>00759 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kDateTimeFormatSpecifier         =      ELPP_LITERAL(<span class="stringliteral">&quot;%datetime&quot;</span>);
<a name="l00760"></a>00760 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kLogFileFormatSpecifier          =      ELPP_LITERAL(<span class="stringliteral">&quot;%file&quot;</span>);
<a name="l00761"></a>00761 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kLogFileBaseFormatSpecifier      =      ELPP_LITERAL(<span class="stringliteral">&quot;%fbase&quot;</span>);
<a name="l00762"></a>00762 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kLogLineFormatSpecifier          =      ELPP_LITERAL(<span class="stringliteral">&quot;%line&quot;</span>);
<a name="l00763"></a>00763 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kLogLocationFormatSpecifier      =      ELPP_LITERAL(<span class="stringliteral">&quot;%loc&quot;</span>);
<a name="l00764"></a>00764 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kLogFunctionFormatSpecifier      =      ELPP_LITERAL(<span class="stringliteral">&quot;%func&quot;</span>);
<a name="l00765"></a>00765 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kCurrentUserFormatSpecifier      =      ELPP_LITERAL(<span class="stringliteral">&quot;%user&quot;</span>);
<a name="l00766"></a>00766 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kCurrentHostFormatSpecifier      =      ELPP_LITERAL(<span class="stringliteral">&quot;%host&quot;</span>);
<a name="l00767"></a>00767 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kMessageFormatSpecifier          =      ELPP_LITERAL(<span class="stringliteral">&quot;%msg&quot;</span>);
<a name="l00768"></a>00768 <span class="keyword">static</span> <span class="keyword">const</span> base::type::char_t* kVerboseLevelFormatSpecifier     =      ELPP_LITERAL(<span class="stringliteral">&quot;%vlevel&quot;</span>);
<a name="l00769"></a>00769 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDateTimeFormatSpecifierForFilename            =      <span class="stringliteral">&quot;%datetime&quot;</span>;
<a name="l00770"></a>00770 <span class="comment">// Date/time</span>
<a name="l00771"></a>00771 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDays[7]                         =      { <span class="stringliteral">&quot;Sunday&quot;</span>, <span class="stringliteral">&quot;Monday&quot;</span>, <span class="stringliteral">&quot;Tuesday&quot;</span>, <span class="stringliteral">&quot;Wednesday&quot;</span>, <span class="stringliteral">&quot;Thursday&quot;</span>, <span class="stringliteral">&quot;Friday&quot;</span>, <span class="stringliteral">&quot;Saturday&quot;</span> };
<a name="l00772"></a>00772 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDaysAbbrev[7]                   =      { <span class="stringliteral">&quot;Sun&quot;</span>, <span class="stringliteral">&quot;Mon&quot;</span>, <span class="stringliteral">&quot;Tue&quot;</span>, <span class="stringliteral">&quot;Wed&quot;</span>, <span class="stringliteral">&quot;Thu&quot;</span>, <span class="stringliteral">&quot;Fri&quot;</span>, <span class="stringliteral">&quot;Sat&quot;</span> };
<a name="l00773"></a>00773 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kMonths[12]                      =      { <span class="stringliteral">&quot;January&quot;</span>, <span class="stringliteral">&quot;February&quot;</span>, <span class="stringliteral">&quot;March&quot;</span>, <span class="stringliteral">&quot;Apri&quot;</span>, <span class="stringliteral">&quot;May&quot;</span>, <span class="stringliteral">&quot;June&quot;</span>, <span class="stringliteral">&quot;July&quot;</span>, <span class="stringliteral">&quot;August&quot;</span>,
<a name="l00774"></a>00774                                                              <span class="stringliteral">&quot;September&quot;</span>, <span class="stringliteral">&quot;October&quot;</span>, <span class="stringliteral">&quot;November&quot;</span>, <span class="stringliteral">&quot;December&quot;</span>
<a name="l00775"></a>00775                                                            };
<a name="l00776"></a>00776 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kMonthsAbbrev[12]                =      { <span class="stringliteral">&quot;Jan&quot;</span>, <span class="stringliteral">&quot;Feb&quot;</span>, <span class="stringliteral">&quot;Mar&quot;</span>, <span class="stringliteral">&quot;Apr&quot;</span>, <span class="stringliteral">&quot;May&quot;</span>, <span class="stringliteral">&quot;Jun&quot;</span>, <span class="stringliteral">&quot;Jul&quot;</span>, <span class="stringliteral">&quot;Aug&quot;</span>, <span class="stringliteral">&quot;Sep&quot;</span>, <span class="stringliteral">&quot;Oct&quot;</span>, <span class="stringliteral">&quot;Nov&quot;</span>, <span class="stringliteral">&quot;Dec&quot;</span> };
<a name="l00777"></a>00777 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultDateTimeFormat           =      <span class="stringliteral">&quot;%Y-%M-%d %H:%m:%s,%g&quot;</span>;
<a name="l00778"></a>00778 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultDateTimeFormatInFilename =      <span class="stringliteral">&quot;%Y-%M-%d_%H-%m&quot;</span>;
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kYearBase                          =      1900;
<a name="l00780"></a>00780 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kAm                              =      <span class="stringliteral">&quot;AM&quot;</span>;
<a name="l00781"></a>00781 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kPm                              =      <span class="stringliteral">&quot;PM&quot;</span>;
<a name="l00782"></a>00782 <span class="comment">// Miscellaneous constants</span>
<a name="l00783"></a>00783 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultLoggerId                        =      <span class="stringliteral">&quot;default&quot;</span>;
<a name="l00784"></a>00784 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kPerformanceLoggerId                    =      <span class="stringliteral">&quot;performance&quot;</span>;
<a name="l00785"></a>00785 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kSysLogLoggerId                         =      <span class="stringliteral">&quot;syslog&quot;</span>;
<a name="l00786"></a>00786 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kNullPointer                            =      <span class="stringliteral">&quot;nullptr&quot;</span>;
<a name="l00787"></a>00787 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>  kFormatSpecifierChar                    =      <span class="charliteral">&apos;%&apos;</span>;
<a name="l00788"></a>00788 <span class="preprocessor">#if ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l00789"></a>00789 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>  kFormatSpecifierCharValue               =      <span class="charliteral">&apos;v&apos;</span>;
<a name="l00790"></a>00790 <span class="preprocessor">#endif  // ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kMaxLogPerContainer              =      100;
<a name="l00792"></a>00792 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kMaxLogPerCounter                =      100000;
<a name="l00793"></a>00793 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  kDefaultMillisecondsWidth       =      3;
<a name="l00794"></a>00794 <span class="keyword">static</span> <span class="keyword">const</span> base::type::VerboseLevel kMaxVerboseLevel     =      9;
<a name="l00795"></a>00795 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kUnknownUser                            =      <span class="stringliteral">&quot;user&quot;</span>;
<a name="l00796"></a>00796 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kUnknownHost                            =      <span class="stringliteral">&quot;unknown-host&quot;</span>;
<a name="l00797"></a>00797 <span class="preprocessor">#if defined(ELPP_DEFAULT_LOG_FILE)</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultLogFile                         =      ELPP_DEFAULT_LOG_FILE;
<a name="l00799"></a>00799 <span class="preprocessor">#else</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l00801"></a>00801 <span class="preprocessor"></span><span class="preprocessor">#      if ELPP_OS_ANDROID</span>
<a name="l00802"></a>00802 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultLogFile                         =      <span class="stringliteral">&quot;logs/myeasylog.log&quot;</span>;
<a name="l00803"></a>00803 <span class="preprocessor">#      else</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultLogFile                         =      <span class="stringliteral">&quot;logs/myeasylog.log&quot;</span>;
<a name="l00805"></a>00805 <span class="preprocessor">#      endif  // ELPP_OS_ANDROID</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span><span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l00807"></a>00807 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultLogFile                         =      <span class="stringliteral">&quot;logs\\myeasylog.log&quot;</span>;
<a name="l00808"></a>00808 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l00809"></a>00809 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_DEFAULT_LOG_FILE)</span>
<a name="l00810"></a>00810 <span class="preprocessor"></span><span class="preprocessor">#if !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kDefaultLogFileParam                    =      <span class="stringliteral">&quot;--default-log-file&quot;</span>;
<a name="l00812"></a>00812 <span class="preprocessor">#endif  // !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_LOGGING_FLAGS_FROM_ARG)</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kLoggingFlagsParam                      =      <span class="stringliteral">&quot;--logging-flags&quot;</span>;
<a name="l00815"></a>00815 <span class="preprocessor">#endif  // defined(ELPP_LOGGING_FLAGS_FROM_ARG)</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_OS_WINDOWS</span>
<a name="l00817"></a>00817 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kFilePathSeperator                      =      <span class="stringliteral">&quot;\\&quot;</span>;
<a name="l00818"></a>00818 <span class="preprocessor">#else</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kFilePathSeperator                      =      <span class="stringliteral">&quot;/&quot;</span>;
<a name="l00820"></a>00820 <span class="preprocessor">#endif  // ELPP_OS_WINDOWS</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kValidLoggerIdSymbols                   =      <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._&quot;</span>;
<a name="l00822"></a>00822 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kConfigurationComment                   =      <span class="stringliteral">&quot;##&quot;</span>;
<a name="l00823"></a>00823 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kConfigurationLevel                     =      <span class="stringliteral">&quot;*&quot;</span>;
<a name="l00824"></a>00824 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kConfigurationLoggerId                  =      <span class="stringliteral">&quot;--&quot;</span>;
<a name="l00825"></a>00825 <span class="keyword">static</span> <span class="keyword">const</span> std::size_t kSourceFilenameMaxLength          =      100;
<a name="l00826"></a>00826 <span class="keyword">static</span> <span class="keyword">const</span> std::size_t kSourceLineMaxLength              =      10;
<a name="l00827"></a>00827 <span class="keyword">static</span> <span class="keyword">const</span> Level kPerformanceTrackerDefaultLevel         =      Level::Info;
<a name="l00828"></a>00828 <span class="keyword">const</span> <span class="keyword">struct </span>{
<a name="l00829"></a>00829     <span class="keywordtype">double</span> value;
<a name="l00830"></a>00830     <span class="keyword">const</span> base::type::char_t* unit;
<a name="l00831"></a>00831 } kTimeFormats[] = {
<a name="l00832"></a>00832     { 1000.0f, ELPP_LITERAL(<span class="stringliteral">&quot;mis&quot;</span>) },
<a name="l00833"></a>00833     { 1000.0f, ELPP_LITERAL(<span class="stringliteral">&quot;ms&quot;</span>) },
<a name="l00834"></a>00834     { 60.0f, ELPP_LITERAL(<span class="stringliteral">&quot;seconds&quot;</span>) },
<a name="l00835"></a>00835     { 60.0f, ELPP_LITERAL(<span class="stringliteral">&quot;minutes&quot;</span>) },
<a name="l00836"></a>00836     { 24.0f, ELPP_LITERAL(<span class="stringliteral">&quot;hours&quot;</span>) },
<a name="l00837"></a>00837     { 7.0f, ELPP_LITERAL(<span class="stringliteral">&quot;days&quot;</span>) }
<a name="l00838"></a>00838 };
<a name="l00839"></a>00839 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kTimeFormatsCount                           =      <span class="keyword">sizeof</span>(kTimeFormats) / <span class="keyword">sizeof</span>(kTimeFormats[0]);
<a name="l00840"></a>00840 <span class="keyword">const</span> <span class="keyword">struct </span>{
<a name="l00841"></a>00841     <span class="keywordtype">int</span> numb;
<a name="l00842"></a>00842     <span class="keyword">const</span> <span class="keywordtype">char</span>* name;
<a name="l00843"></a>00843     <span class="keyword">const</span> <span class="keywordtype">char</span>* brief;
<a name="l00844"></a>00844     <span class="keyword">const</span> <span class="keywordtype">char</span>* detail;
<a name="l00845"></a>00845 } kCrashSignals[] = {
<a name="l00846"></a>00846     <span class="comment">// NOTE: Do not re-order, if you do please check CrashHandler(bool) constructor and CrashHandler::setHandler(..)</span>
<a name="l00847"></a>00847     {
<a name="l00848"></a>00848         SIGABRT, <span class="stringliteral">&quot;SIGABRT&quot;</span>, <span class="stringliteral">&quot;Abnormal termination&quot;</span>,
<a name="l00849"></a>00849         <span class="stringliteral">&quot;Program was abnormally terminated.&quot;</span>
<a name="l00850"></a>00850     },
<a name="l00851"></a>00851     {
<a name="l00852"></a>00852         SIGFPE, <span class="stringliteral">&quot;SIGFPE&quot;</span>, <span class="stringliteral">&quot;Erroneous arithmetic operation&quot;</span>,
<a name="l00853"></a>00853         <span class="stringliteral">&quot;Arithemetic operation issue such as division by zero or operation resulting in overflow.&quot;</span>
<a name="l00854"></a>00854     },
<a name="l00855"></a>00855     {
<a name="l00856"></a>00856         SIGILL, <span class="stringliteral">&quot;SIGILL&quot;</span>, <span class="stringliteral">&quot;Illegal instruction&quot;</span>,
<a name="l00857"></a>00857         <span class="stringliteral">&quot;Generally due to a corruption in the code or to an attempt to execute data.&quot;</span>
<a name="l00858"></a>00858     },
<a name="l00859"></a>00859     {
<a name="l00860"></a>00860         SIGSEGV, <span class="stringliteral">&quot;SIGSEGV&quot;</span>, <span class="stringliteral">&quot;Invalid access to memory&quot;</span>,
<a name="l00861"></a>00861         <span class="stringliteral">&quot;Program is trying to read an invalid (unallocated, deleted or corrupted) or inaccessible memory.&quot;</span>
<a name="l00862"></a>00862     },
<a name="l00863"></a>00863     {
<a name="l00864"></a>00864         SIGINT, <span class="stringliteral">&quot;SIGINT&quot;</span>, <span class="stringliteral">&quot;Interactive attention signal&quot;</span>,
<a name="l00865"></a>00865         <span class="stringliteral">&quot;Interruption generated (generally) by user or operating system.&quot;</span>
<a name="l00866"></a>00866     },
<a name="l00867"></a>00867 };
<a name="l00868"></a>00868 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kCrashSignalsCount                          =      <span class="keyword">sizeof</span>(kCrashSignals) / <span class="keyword">sizeof</span>(kCrashSignals[0]);
<a name="l00869"></a>00869 }  <span class="comment">// namespace consts</span>
<a name="l00870"></a>00870 }  <span class="comment">// namespace base</span>
<a name="l00871"></a>00871 <span class="keyword">typedef</span> std::function&lt;void(const char*, std::size_t)&gt; PreRollOutCallback;
<a name="l00872"></a>00872 <span class="keyword">namespace </span>base {
<a name="l00873"></a>00873 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> defaultPreRollOutCallback(<span class="keyword">const</span> <span class="keywordtype">char</span>*, std::size_t) {}
<a name="l00875"></a>00875 <span class="keyword">enum class</span> TimestampUnit : base::type::EnumType {
<a name="l00876"></a>00876     Microsecond = 0, Millisecond = 1, Second = 2, Minute = 3, Hour = 4, Day = 5
<a name="l00877"></a>00877 };
<a name="l00879"></a>00879 <span class="keyword">enum class</span> FormatFlags : base::type::EnumType {
<a name="l00880"></a>00880     DateTime = 1 &lt;&lt; 1, LoggerId = 1 &lt;&lt; 2, File = 1 &lt;&lt; 3, Line = 1 &lt;&lt; 4, Location = 1 &lt;&lt; 5, Function = 1 &lt;&lt; 6,
<a name="l00881"></a>00881     User = 1 &lt;&lt; 7, Host = 1 &lt;&lt; 8, LogMessage = 1 &lt;&lt; 9, VerboseLevel = 1 &lt;&lt; 10, AppName = 1 &lt;&lt; 11, ThreadId = 1 &lt;&lt; 12,
<a name="l00882"></a>00882     Level = 1 &lt;&lt; 13, FileBase = 1 &lt;&lt; 14, LevelShort = 1 &lt;&lt; 15
<a name="l00883"></a>00883 };
<a name="l00885"></a>00885 <span class="keyword">class </span>MillisecondsWidth
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887 <span class="keyword">public</span>:
<a name="l00888"></a>00888     MillisecondsWidth(<span class="keywordtype">void</span>) { init(base::consts::kDefaultMillisecondsWidth); }
<a name="l00889"></a>00889     <span class="keyword">explicit</span> MillisecondsWidth(<span class="keywordtype">int</span> width) { init(width); }
<a name="l00890"></a>00890     <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MillisecondsWidth&amp; msWidth) { <span class="keywordflow">return</span> m_width == msWidth.m_width &amp;&amp; m_offset == msWidth.m_offset; }
<a name="l00891"></a>00891     <span class="keywordtype">int</span> m_width;
<a name="l00892"></a>00892     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_offset;
<a name="l00893"></a>00893 <span class="keyword">private</span>:
<a name="l00894"></a>00894     <span class="keywordtype">void</span> init(<span class="keywordtype">int</span> width)
<a name="l00895"></a>00895     {
<a name="l00896"></a>00896         <span class="keywordflow">if</span> (width &lt; 1 || width &gt; 6) {
<a name="l00897"></a>00897             width = base::consts::kDefaultMillisecondsWidth;
<a name="l00898"></a>00898         }
<a name="l00899"></a>00899         m_width = width;
<a name="l00900"></a>00900         <span class="keywordflow">switch</span> (m_width) {
<a name="l00901"></a>00901             <span class="keywordflow">case</span> 3:
<a name="l00902"></a>00902                 m_offset = 1000;
<a name="l00903"></a>00903                 <span class="keywordflow">break</span>;
<a name="l00904"></a>00904             <span class="keywordflow">case</span> 4:
<a name="l00905"></a>00905                 m_offset = 100;
<a name="l00906"></a>00906                 <span class="keywordflow">break</span>;
<a name="l00907"></a>00907             <span class="keywordflow">case</span> 5:
<a name="l00908"></a>00908                 m_offset = 10;
<a name="l00909"></a>00909                 <span class="keywordflow">break</span>;
<a name="l00910"></a>00910             <span class="keywordflow">case</span> 6:
<a name="l00911"></a>00911                 m_offset = 1;
<a name="l00912"></a>00912                 <span class="keywordflow">break</span>;
<a name="l00913"></a>00913             <span class="keywordflow">default</span>:
<a name="l00914"></a>00914                 m_offset = 1000;
<a name="l00915"></a>00915                 <span class="keywordflow">break</span>;
<a name="l00916"></a>00916         }
<a name="l00917"></a>00917     }
<a name="l00918"></a>00918 };
<a name="l00920"></a>00920 <span class="keyword">namespace </span>utils {
<a name="l00922"></a>00922 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00923"></a>00923 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00924"></a>00924 <span class="keyword">typename</span> std::enable_if&lt;std::is_pointer&lt;T*&gt;::value, <span class="keywordtype">void</span>&gt;::type
<a name="l00925"></a>00925 safeDelete(T*&amp; pointer)
<a name="l00926"></a>00926 {
<a name="l00927"></a>00927     <span class="keywordflow">if</span> (pointer == <span class="keyword">nullptr</span>)
<a name="l00928"></a>00928         <span class="keywordflow">return</span>;
<a name="l00929"></a>00929     <span class="keyword">delete</span> pointer;
<a name="l00930"></a>00930     pointer = <span class="keyword">nullptr</span>;
<a name="l00931"></a>00931 }
<a name="l00933"></a>00933 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* charPtrVal(<span class="keyword">const</span> <span class="keywordtype">char</span>* pointer)
<a name="l00934"></a>00934 {
<a name="l00935"></a>00935     <span class="keywordflow">return</span> pointer == <span class="keyword">nullptr</span> ? base::consts::kNullPointer : pointer;
<a name="l00936"></a>00936 }
<a name="l00938"></a>00938 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> abort(<span class="keywordtype">int</span> status, <span class="keyword">const</span> std::string&amp; reason = std::string())
<a name="l00939"></a>00939 {
<a name="l00940"></a>00940     <span class="comment">// Both status and reason params are there for debugging with tools like gdb etc</span>
<a name="l00941"></a>00941     ELPP_UNUSED(status);
<a name="l00942"></a>00942     ELPP_UNUSED(reason);
<a name="l00943"></a>00943 <span class="preprocessor">#if defined(ELPP_COMPILER_MSVC) &amp;&amp; defined(_M_IX86) &amp;&amp; defined(_DEBUG)</span>
<a name="l00944"></a>00944 <span class="preprocessor"></span>    <span class="comment">// Ignore msvc critical error dialog - break instead (on debug mode)</span>
<a name="l00945"></a>00945     _asm <span class="keywordtype">int</span> 3
<a name="l00946"></a>00946 <span class="preprocessor">#else</span>
<a name="l00947"></a>00947 <span class="preprocessor"></span>    ::abort();
<a name="l00948"></a>00948 <span class="preprocessor">#endif  // defined(ELPP_COMPILER_MSVC) &amp;&amp; defined(_M_IX86) &amp;&amp; defined(_DEBUG)</span>
<a name="l00949"></a>00949 <span class="preprocessor"></span>}
<a name="l00952"></a>00952 <span class="keyword">namespace </span>bitwise {
<a name="l00953"></a>00953 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Enum&gt;
<a name="l00954"></a>00954 <span class="keyword">static</span> <span class="keyword">inline</span> base::type::EnumType And(Enum e, base::type::EnumType flag)
<a name="l00955"></a>00955 {
<a name="l00956"></a>00956     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(flag) &amp; static_cast&lt;base::type::EnumType&gt;(e);
<a name="l00957"></a>00957 }
<a name="l00958"></a>00958 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Enum&gt;
<a name="l00959"></a>00959 <span class="keyword">static</span> <span class="keyword">inline</span> base::type::EnumType Not(Enum e, base::type::EnumType flag)
<a name="l00960"></a>00960 {
<a name="l00961"></a>00961     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(flag) &amp; ~(static_cast&lt;base::type::EnumType&gt;(e));
<a name="l00962"></a>00962 }
<a name="l00963"></a>00963 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Enum&gt;
<a name="l00964"></a>00964 <span class="keyword">static</span> <span class="keyword">inline</span> base::type::EnumType Or(Enum e, base::type::EnumType flag)
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(flag) | static_cast&lt;base::type::EnumType&gt;(e);
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 }  <span class="comment">// namespace bitwise</span>
<a name="l00969"></a>00969 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Enum&gt;
<a name="l00970"></a>00970 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> addFlag(Enum e, base::type::EnumType* flag)
<a name="l00971"></a>00971 {
<a name="l00972"></a>00972     *flag = base::utils::bitwise::Or&lt;Enum&gt;(e, *flag);
<a name="l00973"></a>00973 }
<a name="l00974"></a>00974 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Enum&gt;
<a name="l00975"></a>00975 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> removeFlag(Enum e, base::type::EnumType* flag)
<a name="l00976"></a>00976 {
<a name="l00977"></a>00977     *flag = base::utils::bitwise::Not&lt;Enum&gt;(e, *flag);
<a name="l00978"></a>00978 }
<a name="l00979"></a>00979 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Enum&gt;
<a name="l00980"></a>00980 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasFlag(Enum e, base::type::EnumType flag)
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982     <span class="keywordflow">return</span> base::utils::bitwise::And&lt;Enum&gt;(e, flag) &gt; 0x0;
<a name="l00983"></a>00983 }
<a name="l00984"></a>00984 }  <span class="comment">// namespace utils</span>
<a name="l00985"></a>00985 <span class="keyword">namespace </span>threading {
<a name="l00986"></a>00986 <span class="preprocessor">#if ELPP_THREADING_ENABLED</span>
<a name="l00987"></a>00987 <span class="preprocessor"></span><span class="preprocessor">#   if !ELPP_USE_STD_THREADING</span>
<a name="l00988"></a>00988 <span class="preprocessor"></span><span class="keyword">namespace </span>internal {
<a name="l00990"></a>00990 <span class="keyword">class </span>Mutex : base::NoCopy
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992 <span class="keyword">public</span>:
<a name="l00993"></a>00993     Mutex(<span class="keywordtype">void</span>)
<a name="l00994"></a>00994     {
<a name="l00995"></a>00995 <span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span>        pthread_mutex_init(&amp;m_underlyingMutex, <span class="keyword">nullptr</span>);
<a name="l00997"></a>00997 <span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span>        InitializeCriticalSection(&amp;m_underlyingMutex);
<a name="l00999"></a>00999 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span>    }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="keyword">virtual</span> ~Mutex(<span class="keywordtype">void</span>)
<a name="l01003"></a>01003     {
<a name="l01004"></a>01004 <span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>        pthread_mutex_destroy(&amp;m_underlyingMutex);
<a name="l01006"></a>01006 <span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l01007"></a>01007 <span class="preprocessor"></span>        DeleteCriticalSection(&amp;m_underlyingMutex);
<a name="l01008"></a>01008 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span>    }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011     <span class="keyword">inline</span> <span class="keywordtype">void</span> lock(<span class="keywordtype">void</span>)
<a name="l01012"></a>01012     {
<a name="l01013"></a>01013 <span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span>        pthread_mutex_lock(&amp;m_underlyingMutex);
<a name="l01015"></a>01015 <span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>        EnterCriticalSection(&amp;m_underlyingMutex);
<a name="l01017"></a>01017 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l01018"></a>01018 <span class="preprocessor"></span>    }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020     <span class="keyword">inline</span> <span class="keywordtype">bool</span> try_lock(<span class="keywordtype">void</span>)
<a name="l01021"></a>01021     {
<a name="l01022"></a>01022 <span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l01023"></a>01023 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (pthread_mutex_trylock(&amp;m_underlyingMutex) == 0);
<a name="l01024"></a>01024 <span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span>        <span class="keywordflow">return</span> TryEnterCriticalSection(&amp;m_underlyingMutex);
<a name="l01026"></a>01026 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l01027"></a>01027 <span class="preprocessor"></span>    }
<a name="l01028"></a>01028 
<a name="l01029"></a>01029     <span class="keyword">inline</span> <span class="keywordtype">void</span> unlock(<span class="keywordtype">void</span>)
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031 <span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l01032"></a>01032 <span class="preprocessor"></span>        pthread_mutex_unlock(&amp;m_underlyingMutex);
<a name="l01033"></a>01033 <span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>        LeaveCriticalSection(&amp;m_underlyingMutex);
<a name="l01035"></a>01035 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l01036"></a>01036 <span class="preprocessor"></span>    }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 <span class="keyword">private</span>:
<a name="l01039"></a>01039 <span class="preprocessor">#   if ELPP_OS_UNIX</span>
<a name="l01040"></a>01040 <span class="preprocessor"></span>    pthread_mutex_t m_underlyingMutex;
<a name="l01041"></a>01041 <span class="preprocessor">#   elif ELPP_OS_WINDOWS</span>
<a name="l01042"></a>01042 <span class="preprocessor"></span>    CRITICAL_SECTION m_underlyingMutex;
<a name="l01043"></a>01043 <span class="preprocessor">#   endif  // ELPP_OS_UNIX</span>
<a name="l01044"></a>01044 <span class="preprocessor"></span>};
<a name="l01046"></a>01046 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt;
<a name="l01047"></a>01047 <span class="keyword">class </span>ScopedLock : base::NoCopy
<a name="l01048"></a>01048 {
<a name="l01049"></a>01049 <span class="keyword">public</span>:
<a name="l01050"></a>01050     <span class="keyword">explicit</span> ScopedLock(M&amp; mutex)
<a name="l01051"></a>01051     {
<a name="l01052"></a>01052         m_mutex = &amp;mutex;
<a name="l01053"></a>01053         m_mutex-&gt;lock();
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056     <span class="keyword">virtual</span> ~ScopedLock(<span class="keywordtype">void</span>)
<a name="l01057"></a>01057     {
<a name="l01058"></a>01058         m_mutex-&gt;unlock();
<a name="l01059"></a>01059     }
<a name="l01060"></a>01060 <span class="keyword">private</span>:
<a name="l01061"></a>01061     M* m_mutex;
<a name="l01062"></a>01062     ScopedLock(<span class="keywordtype">void</span>);
<a name="l01063"></a>01063 };
<a name="l01064"></a>01064 } <span class="comment">// namespace internal</span>
<a name="l01066"></a>01066 <span class="comment"></span><span class="keyword">static</span> <span class="keyword">inline</span> std::string getCurrentThreadId(<span class="keywordtype">void</span>)
<a name="l01067"></a>01067 {
<a name="l01068"></a>01068     std::stringstream ss;
<a name="l01069"></a>01069 <span class="preprocessor">#      if (ELPP_OS_WINDOWS)</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span>    ss &lt;&lt; GetCurrentThreadId();
<a name="l01071"></a>01071 <span class="preprocessor">#      endif  // (ELPP_OS_WINDOWS)</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ss.str();
<a name="l01073"></a>01073 }
<a name="l01074"></a>01074 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> msleep(<span class="keywordtype">int</span>)
<a name="l01075"></a>01075 {
<a name="l01076"></a>01076     <span class="comment">// No implementation for non std::thread version</span>
<a name="l01077"></a>01077 }
<a name="l01078"></a>01078 <span class="keyword">typedef</span> base::threading::internal::Mutex Mutex;
<a name="l01079"></a>01079 <span class="keyword">typedef</span> base::threading::internal::ScopedLock&lt;base::threading::Mutex&gt; ScopedLock;
<a name="l01080"></a>01080 <span class="preprocessor">#   else</span>
<a name="l01082"></a>01082 <span class="preprocessor">static inline std::string getCurrentThreadId(void)</span>
<a name="l01083"></a>01083 <span class="preprocessor"></span>{
<a name="l01084"></a>01084     std::stringstream ss;
<a name="l01085"></a>01085     ss &lt;&lt; std::this_thread::get_id();
<a name="l01086"></a>01086     <span class="keywordflow">return</span> ss.str();
<a name="l01087"></a>01087 }
<a name="l01088"></a>01088 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> msleep(<span class="keywordtype">int</span> ms)
<a name="l01089"></a>01089 {
<a name="l01090"></a>01090     <span class="comment">// Only when async logging enabled - this is because async is strict on compiler</span>
<a name="l01091"></a>01091 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l01092"></a>01092 <span class="preprocessor"></span>    std::this_thread::sleep_for(std::chrono::milliseconds(ms));
<a name="l01093"></a>01093 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l01094"></a>01094 <span class="preprocessor"></span>}
<a name="l01095"></a>01095 <span class="keyword">typedef</span> std::mutex Mutex;
<a name="l01096"></a>01096 <span class="keyword">typedef</span> std::lock_guard&lt;std::mutex&gt; ScopedLock;
<a name="l01097"></a>01097 <span class="preprocessor">#   endif  // !ELPP_USE_STD_THREADING</span>
<a name="l01098"></a>01098 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span><span class="keyword">namespace </span>internal {
<a name="l01101"></a>01101 <span class="keyword">class </span>NoMutex : base::NoCopy
<a name="l01102"></a>01102 {
<a name="l01103"></a>01103 <span class="keyword">public</span>:
<a name="l01104"></a>01104     NoMutex(<span class="keywordtype">void</span>) {}
<a name="l01105"></a>01105     <span class="keyword">inline</span> <span class="keywordtype">void</span> lock(<span class="keywordtype">void</span>) {}
<a name="l01106"></a>01106     <span class="keyword">inline</span> <span class="keywordtype">bool</span> try_lock(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l01107"></a>01107     <span class="keyword">inline</span> <span class="keywordtype">void</span> unlock(<span class="keywordtype">void</span>) {}
<a name="l01108"></a>01108 };
<a name="l01110"></a>01110 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mutex&gt;
<a name="l01111"></a>01111 <span class="keyword">class </span>NoScopedLock : base::NoCopy
<a name="l01112"></a>01112 {
<a name="l01113"></a>01113 <span class="keyword">public</span>:
<a name="l01114"></a>01114     <span class="keyword">explicit</span> NoScopedLock(Mutex&amp;)
<a name="l01115"></a>01115     {
<a name="l01116"></a>01116     }
<a name="l01117"></a>01117     <span class="keyword">virtual</span> ~NoScopedLock(<span class="keywordtype">void</span>)
<a name="l01118"></a>01118     {
<a name="l01119"></a>01119     }
<a name="l01120"></a>01120 <span class="keyword">private</span>:
<a name="l01121"></a>01121     NoScopedLock(<span class="keywordtype">void</span>);
<a name="l01122"></a>01122 };
<a name="l01123"></a>01123 }  <span class="comment">// namespace internal</span>
<a name="l01124"></a>01124 <span class="keyword">static</span> <span class="keyword">inline</span> std::string getCurrentThreadId(<span class="keywordtype">void</span>)
<a name="l01125"></a>01125 {
<a name="l01126"></a>01126     <span class="keywordflow">return</span> std::string();
<a name="l01127"></a>01127 }
<a name="l01128"></a>01128 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> msleep(<span class="keywordtype">int</span>)
<a name="l01129"></a>01129 {
<a name="l01130"></a>01130     <span class="comment">// No custom implementation</span>
<a name="l01131"></a>01131 }
<a name="l01132"></a>01132 <span class="keyword">typedef</span> base::threading::internal::NoMutex Mutex;
<a name="l01133"></a>01133 <span class="keyword">typedef</span> base::threading::internal::NoScopedLock&lt;base::threading::Mutex&gt; ScopedLock;
<a name="l01134"></a>01134 <span class="preprocessor">#endif  // ELPP_THREADING_ENABLED</span>
<a name="l01136"></a>01136 <span class="preprocessor">class ThreadSafe</span>
<a name="l01137"></a>01137 <span class="preprocessor"></span>{
<a name="l01138"></a>01138 <span class="keyword">public</span>:
<a name="l01139"></a>01139     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> acquireLock(<span class="keywordtype">void</span>) ELPP_FINAL { m_mutex.lock(); }
<a name="l01140"></a>01140     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> releaseLock(<span class="keywordtype">void</span>) ELPP_FINAL { m_mutex.unlock(); }
<a name="l01141"></a>01141     <span class="keyword">virtual</span> <span class="keyword">inline</span> base::threading::Mutex&amp; lock(<span class="keywordtype">void</span>) ELPP_FINAL { <span class="keywordflow">return</span> m_mutex; }
<a name="l01142"></a>01142 <span class="keyword">protected</span>:
<a name="l01143"></a>01143     ThreadSafe(<span class="keywordtype">void</span>) {}
<a name="l01144"></a>01144     <span class="keyword">virtual</span> ~ThreadSafe(<span class="keywordtype">void</span>) {}
<a name="l01145"></a>01145 <span class="keyword">private</span>:
<a name="l01146"></a>01146     base::threading::Mutex m_mutex;
<a name="l01147"></a>01147 };
<a name="l01148"></a>01148 }  <span class="comment">// namespace threading</span>
<a name="l01149"></a>01149 <span class="keyword">namespace </span>utils {
<a name="l01150"></a>01150 <span class="keyword">class </span>File : base::StaticClass
<a name="l01151"></a>01151 {
<a name="l01152"></a>01152 <span class="keyword">public</span>:
<a name="l01155"></a>01155     <span class="keyword">static</span> base::type::fstream_t* newFileStream(<span class="keyword">const</span> std::string&amp; filename)
<a name="l01156"></a>01156     {
<a name="l01157"></a>01157         base::type::fstream_t* fs = <span class="keyword">new</span> base::type::fstream_t(filename.c_str(),
<a name="l01158"></a>01158                 base::type::fstream_t::out | base::type::fstream_t::app);
<a name="l01159"></a>01159 <span class="preprocessor">#if defined(ELPP_UNICODE)</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>        std::locale elppUnicodeLocale(<span class="stringliteral">&quot;&quot;</span>);
<a name="l01161"></a>01161 <span class="preprocessor">#if ELPP_OS_WINDOWS</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span>        std::locale elppUnicodeLocaleWindows(elppUnicodeLocale, <span class="keyword">new</span> std::codecvt_utf8_utf16&lt;wchar_t&gt;);
<a name="l01163"></a>01163         elppUnicodeLocale = elppUnicodeLocaleWindows;
<a name="l01164"></a>01164 <span class="preprocessor">#endif</span>
<a name="l01165"></a>01165 <span class="preprocessor"></span>        fs-&gt;imbue(elppUnicodeLocale);
<a name="l01166"></a>01166 <span class="preprocessor">#endif  // defined(ELPP_UNICODE)</span>
<a name="l01167"></a>01167 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fs-&gt;is_open()) {
<a name="l01168"></a>01168             fs-&gt;flush();
<a name="l01169"></a>01169         } <span class="keywordflow">else</span> {
<a name="l01170"></a>01170             base::utils::safeDelete(fs);
<a name="l01171"></a>01171             ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Bad file [&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>, <span class="keyword">true</span>);
<a name="l01172"></a>01172         }
<a name="l01173"></a>01173         <span class="keywordflow">return</span> fs;
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175 
<a name="l01177"></a>01177     <span class="keyword">static</span> std::size_t getSizeOfFile(base::type::fstream_t* fs)
<a name="l01178"></a>01178     {
<a name="l01179"></a>01179         <span class="keywordflow">if</span> (fs == <span class="keyword">nullptr</span>) {
<a name="l01180"></a>01180             <span class="keywordflow">return</span> 0;
<a name="l01181"></a>01181         }
<a name="l01182"></a>01182         std::streampos currPos = fs-&gt;tellg();
<a name="l01183"></a>01183         fs-&gt;seekg(0, fs-&gt;end);
<a name="l01184"></a>01184         std::size_t size = <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(fs-&gt;tellg());
<a name="l01185"></a>01185         fs-&gt;seekg(currPos);
<a name="l01186"></a>01186         <span class="keywordflow">return</span> size;
<a name="l01187"></a>01187     }
<a name="l01188"></a>01188 
<a name="l01190"></a>01190     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> pathExists(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">bool</span> considerFile = <span class="keyword">false</span>)
<a name="l01191"></a>01191     {
<a name="l01192"></a>01192         <span class="keywordflow">if</span> (path == <span class="keyword">nullptr</span>) {
<a name="l01193"></a>01193             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195 <span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l01196"></a>01196 <span class="preprocessor"></span>        ELPP_UNUSED(considerFile);
<a name="l01197"></a>01197         <span class="keyword">struct </span>stat st;
<a name="l01198"></a>01198         <span class="keywordflow">return</span> (stat(path, &amp;st) == 0);
<a name="l01199"></a>01199 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l01200"></a>01200 <span class="preprocessor"></span>        DWORD fileType = GetFileAttributesA(path);
<a name="l01201"></a>01201         <span class="keywordflow">if</span> (fileType == INVALID_FILE_ATTRIBUTES) {
<a name="l01202"></a>01202             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01203"></a>01203         }
<a name="l01204"></a>01204         <span class="keywordflow">return</span> considerFile ? <span class="keyword">true</span> : ((fileType &amp; FILE_ATTRIBUTE_DIRECTORY) == 0 ? <span class="keyword">false</span> : <span class="keyword">true</span>);
<a name="l01205"></a>01205 <span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l01206"></a>01206 <span class="preprocessor"></span>    }
<a name="l01207"></a>01207 
<a name="l01210"></a>01210     <span class="keyword">static</span> <span class="keywordtype">bool</span> createPath(<span class="keyword">const</span> std::string&amp; path)
<a name="l01211"></a>01211     {
<a name="l01212"></a>01212         <span class="keywordflow">if</span> (path.empty()) {
<a name="l01213"></a>01213             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01214"></a>01214         }
<a name="l01215"></a>01215         <span class="keywordflow">if</span> (base::utils::File::pathExists(path.c_str())) {
<a name="l01216"></a>01216             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01217"></a>01217         }
<a name="l01218"></a>01218         <span class="keywordtype">int</span> status = -1;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         <span class="keywordtype">char</span>* currPath = <span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(path.c_str());
<a name="l01221"></a>01221         std::string builtPath = std::string();
<a name="l01222"></a>01222 <span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l01223"></a>01223 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (path[0] == <span class="charliteral">&apos;/&apos;</span>) {
<a name="l01224"></a>01224             builtPath = <span class="stringliteral">&quot;/&quot;</span>;
<a name="l01225"></a>01225         }
<a name="l01226"></a>01226         currPath = STRTOK(currPath, base::consts::kFilePathSeperator, 0);
<a name="l01227"></a>01227 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l01228"></a>01228 <span class="preprocessor"></span>        <span class="comment">// Use secure functions API</span>
<a name="l01229"></a>01229         <span class="keywordtype">char</span>* nextTok_ = <span class="keyword">nullptr</span>;
<a name="l01230"></a>01230         currPath = STRTOK(currPath, base::consts::kFilePathSeperator, &amp;nextTok_);
<a name="l01231"></a>01231         ELPP_UNUSED(nextTok_);
<a name="l01232"></a>01232 <span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l01233"></a>01233 <span class="preprocessor"></span>        <span class="keywordflow">while</span> (currPath != <span class="keyword">nullptr</span>) {
<a name="l01234"></a>01234             builtPath.append(currPath);
<a name="l01235"></a>01235             builtPath.append(base::consts::kFilePathSeperator);
<a name="l01236"></a>01236 <span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l01237"></a>01237 <span class="preprocessor"></span>            status = mkdir(builtPath.c_str(), ELPP_LOG_PERMS);
<a name="l01238"></a>01238             currPath = STRTOK(<span class="keyword">nullptr</span>, base::consts::kFilePathSeperator, 0);
<a name="l01239"></a>01239 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l01240"></a>01240 <span class="preprocessor"></span>            status = _mkdir(builtPath.c_str());
<a name="l01241"></a>01241             currPath = STRTOK(<span class="keyword">nullptr</span>, base::consts::kFilePathSeperator, &amp;nextTok_);
<a name="l01242"></a>01242 <span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l01243"></a>01243 <span class="preprocessor"></span>        }
<a name="l01244"></a>01244         <span class="keywordflow">if</span> (status == -1) {
<a name="l01245"></a>01245             ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Error while creating path [&quot;</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>, <span class="keyword">true</span>);
<a name="l01246"></a>01246             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01249"></a>01249     }
<a name="l01251"></a>01251     <span class="keyword">static</span> std::string extractPathFromFilename(<span class="keyword">const</span> std::string&amp; fullPath,
<a name="l01252"></a>01252             <span class="keyword">const</span> <span class="keywordtype">char</span>* seperator = base::consts::kFilePathSeperator)
<a name="l01253"></a>01253     {
<a name="l01254"></a>01254         <span class="keywordflow">if</span> ((fullPath == <span class="stringliteral">&quot;&quot;</span>) || (fullPath.find(seperator) == std::string::npos)) {
<a name="l01255"></a>01255             <span class="keywordflow">return</span> fullPath;
<a name="l01256"></a>01256         }
<a name="l01257"></a>01257         std::size_t lastSlashAt = fullPath.find_last_of(seperator);
<a name="l01258"></a>01258         <span class="keywordflow">if</span> (lastSlashAt == 0) {
<a name="l01259"></a>01259             <span class="keywordflow">return</span> std::string(seperator);
<a name="l01260"></a>01260         }
<a name="l01261"></a>01261         <span class="keywordflow">return</span> fullPath.substr(0, lastSlashAt + 1);
<a name="l01262"></a>01262     }
<a name="l01264"></a>01264     <span class="keyword">static</span> <span class="keywordtype">void</span> buildStrippedFilename(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">char</span> buff[],
<a name="l01265"></a>01265                                       std::size_t limit = base::consts::kSourceFilenameMaxLength)
<a name="l01266"></a>01266     {
<a name="l01267"></a>01267         std::size_t sizeOfFilename = strlen(filename);
<a name="l01268"></a>01268         <span class="keywordflow">if</span> (sizeOfFilename &gt;= limit) {
<a name="l01269"></a>01269             filename += (sizeOfFilename - limit);
<a name="l01270"></a>01270             <span class="keywordflow">if</span> (filename[0] != <span class="charliteral">&apos;.&apos;</span> &amp;&amp; filename[1] != <span class="charliteral">&apos;.&apos;</span>) {  <span class="comment">// prepend if not already</span>
<a name="l01271"></a>01271                 filename += 3;  <span class="comment">// 3 = &apos;..&apos;</span>
<a name="l01272"></a>01272                 STRCAT(buff, <span class="stringliteral">&quot;..&quot;</span>, limit);
<a name="l01273"></a>01273             }
<a name="l01274"></a>01274         }
<a name="l01275"></a>01275         STRCAT(buff, filename, limit);
<a name="l01276"></a>01276     }
<a name="l01278"></a>01278     <span class="keyword">static</span> <span class="keywordtype">void</span> buildBaseFilename(<span class="keyword">const</span> std::string&amp; fullPath, <span class="keywordtype">char</span> buff[],
<a name="l01279"></a>01279                                   std::size_t limit = base::consts::kSourceFilenameMaxLength,
<a name="l01280"></a>01280                                   <span class="keyword">const</span> <span class="keywordtype">char</span>* seperator = base::consts::kFilePathSeperator)
<a name="l01281"></a>01281     {
<a name="l01282"></a>01282         <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = fullPath.c_str();
<a name="l01283"></a>01283         std::size_t lastSlashAt = fullPath.find_last_of(seperator);
<a name="l01284"></a>01284         filename += lastSlashAt ? lastSlashAt + 1 : 0;
<a name="l01285"></a>01285         std::size_t sizeOfFilename = strlen(filename);
<a name="l01286"></a>01286         <span class="keywordflow">if</span> (sizeOfFilename &gt;= limit) {
<a name="l01287"></a>01287             filename += (sizeOfFilename - limit);
<a name="l01288"></a>01288             <span class="keywordflow">if</span> (filename[0] != <span class="charliteral">&apos;.&apos;</span> &amp;&amp; filename[1] != <span class="charliteral">&apos;.&apos;</span>) {  <span class="comment">// prepend if not already</span>
<a name="l01289"></a>01289                 filename += 3;  <span class="comment">// 3 = &apos;..&apos;</span>
<a name="l01290"></a>01290                 STRCAT(buff, <span class="stringliteral">&quot;..&quot;</span>, limit);
<a name="l01291"></a>01291             }
<a name="l01292"></a>01292         }
<a name="l01293"></a>01293         STRCAT(buff, filename, limit);
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295 };
<a name="l01297"></a>01297 <span class="keyword">class </span>Str : base::StaticClass
<a name="l01298"></a>01298 {
<a name="l01299"></a>01299 <span class="keyword">public</span>:
<a name="l01301"></a>01301     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isDigit(<span class="keywordtype">char</span> c)
<a name="l01302"></a>01302     {
<a name="l01303"></a>01303         <span class="keywordflow">return</span> c &gt;= <span class="charliteral">&apos;0&apos;</span> &amp;&amp; c &lt;= <span class="charliteral">&apos;9&apos;</span>;
<a name="l01304"></a>01304     }
<a name="l01305"></a>01305 
<a name="l01307"></a>01307     <span class="keyword">static</span> <span class="keywordtype">bool</span> wildCardMatch(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keyword">const</span> <span class="keywordtype">char</span>* pattern)
<a name="l01308"></a>01308     {
<a name="l01309"></a>01309         <span class="keywordflow">while</span> (*pattern) {
<a name="l01310"></a>01310             <span class="keywordflow">switch</span> (*pattern) {
<a name="l01311"></a>01311                 <span class="keywordflow">case</span> <span class="charliteral">&apos;?&apos;</span>:
<a name="l01312"></a>01312                     <span class="keywordflow">if</span> (!*str)
<a name="l01313"></a>01313                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01314"></a>01314                     ++str;
<a name="l01315"></a>01315                     ++pattern;
<a name="l01316"></a>01316                     <span class="keywordflow">break</span>;
<a name="l01317"></a>01317                 <span class="keywordflow">case</span> <span class="charliteral">&apos;*&apos;</span>:
<a name="l01318"></a>01318                     <span class="keywordflow">if</span> (wildCardMatch(str, pattern + 1))
<a name="l01319"></a>01319                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01320"></a>01320                     <span class="keywordflow">if</span> (*str &amp;&amp; wildCardMatch(str + 1, pattern))
<a name="l01321"></a>01321                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01322"></a>01322                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01323"></a>01323                     <span class="keywordflow">break</span>;
<a name="l01324"></a>01324                 <span class="keywordflow">default</span>:
<a name="l01325"></a>01325                     <span class="keywordflow">if</span> (*str++ != *pattern++)
<a name="l01326"></a>01326                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01327"></a>01327                     <span class="keywordflow">break</span>;
<a name="l01328"></a>01328             }
<a name="l01329"></a>01329         }
<a name="l01330"></a>01330         <span class="keywordflow">return</span> !*str &amp;&amp; !*pattern;
<a name="l01331"></a>01331     }
<a name="l01332"></a>01332 
<a name="l01335"></a>01335     <span class="keyword">static</span> <span class="keyword">inline</span> std::string&amp; ltrim(std::string&amp; str)
<a name="l01336"></a>01336     {
<a name="l01337"></a>01337         str.erase(str.begin(), std::find_if(str.begin(), str.end(), std::not1(std::ptr_fun&lt;int, int&gt;(&amp;std::isspace))));
<a name="l01338"></a>01338         <span class="keywordflow">return</span> str;
<a name="l01339"></a>01339     }
<a name="l01340"></a>01340 
<a name="l01343"></a>01343     <span class="keyword">static</span> <span class="keyword">inline</span> std::string&amp; rtrim(std::string&amp; str)
<a name="l01344"></a>01344     {
<a name="l01345"></a>01345         str.erase(std::find_if(str.rbegin(), str.rend(), std::not1(std::ptr_fun&lt;int, int&gt;(&amp;std::isspace))).base(), str.end());
<a name="l01346"></a>01346         <span class="keywordflow">return</span> str;
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348 
<a name="l01351"></a>01351     <span class="keyword">static</span> <span class="keyword">inline</span> std::string&amp; trim(std::string&amp; str)
<a name="l01352"></a>01352     {
<a name="l01353"></a>01353         <span class="keywordflow">return</span> ltrim(rtrim(str));
<a name="l01354"></a>01354     }
<a name="l01355"></a>01355 
<a name="l01360"></a>01360     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> startsWith(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> std::string&amp; start)
<a name="l01361"></a>01361     {
<a name="l01362"></a>01362         <span class="keywordflow">return</span> (str.length() &gt;= start.length()) &amp;&amp; (str.compare(0, start.length(), start) == 0);
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364 
<a name="l01369"></a>01369     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> endsWith(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">const</span> std::string&amp; end)
<a name="l01370"></a>01370     {
<a name="l01371"></a>01371         <span class="keywordflow">return</span> (str.length() &gt;= end.length()) &amp;&amp; (str.compare(str.length() - end.length(), end.length(), end) == 0);
<a name="l01372"></a>01372     }
<a name="l01373"></a>01373 
<a name="l01379"></a>01379     <span class="keyword">static</span> <span class="keyword">inline</span> std::string&amp; replaceAll(std::string&amp; str, <span class="keywordtype">char</span> replaceWhat, <span class="keywordtype">char</span> replaceWith)
<a name="l01380"></a>01380     {
<a name="l01381"></a>01381         std::replace(str.begin(), str.end(), replaceWhat, replaceWith);
<a name="l01382"></a>01382         <span class="keywordflow">return</span> str;
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384 
<a name="l01390"></a>01390     <span class="keyword">static</span> <span class="keyword">inline</span> std::string&amp; replaceAll(std::string&amp; str, <span class="keyword">const</span> std::string&amp; replaceWhat, <span class="comment">// NOLINT</span>
<a name="l01391"></a>01391                                           <span class="keyword">const</span> std::string&amp; replaceWith)
<a name="l01392"></a>01392     {
<a name="l01393"></a>01393         <span class="keywordflow">if</span> (replaceWhat == replaceWith)
<a name="l01394"></a>01394             <span class="keywordflow">return</span> str;
<a name="l01395"></a>01395         std::size_t foundAt = std::string::npos;
<a name="l01396"></a>01396         <span class="keywordflow">while</span> ((foundAt = str.find(replaceWhat, foundAt + 1)) != std::string::npos) {
<a name="l01397"></a>01397             str.replace(foundAt, replaceWhat.length(), replaceWith);
<a name="l01398"></a>01398         }
<a name="l01399"></a>01399         <span class="keywordflow">return</span> str;
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402     <span class="keyword">static</span> <span class="keywordtype">void</span> replaceFirstWithEscape(base::type::string_t&amp; str, <span class="keyword">const</span> base::type::string_t&amp; replaceWhat, <span class="comment">// NOLINT</span>
<a name="l01403"></a>01403                                        <span class="keyword">const</span> base::type::string_t&amp; replaceWith)
<a name="l01404"></a>01404     {
<a name="l01405"></a>01405         std::size_t foundAt = base::type::string_t::npos;
<a name="l01406"></a>01406         <span class="keywordflow">while</span> ((foundAt = str.find(replaceWhat, foundAt + 1)) != base::type::string_t::npos) {
<a name="l01407"></a>01407             <span class="keywordflow">if</span> (foundAt &gt; 0 &amp;&amp; str[foundAt - 1] == base::consts::kFormatSpecifierChar) {
<a name="l01408"></a>01408                 str.erase(foundAt &gt; 0 ? foundAt - 1 : 0, 1);
<a name="l01409"></a>01409                 ++foundAt;
<a name="l01410"></a>01410             } <span class="keywordflow">else</span> {
<a name="l01411"></a>01411                 str.replace(foundAt, replaceWhat.length(), replaceWith);
<a name="l01412"></a>01412                 <span class="keywordflow">return</span>;
<a name="l01413"></a>01413             }
<a name="l01414"></a>01414         }
<a name="l01415"></a>01415     }
<a name="l01416"></a>01416 <span class="preprocessor">#if defined(ELPP_UNICODE)</span>
<a name="l01417"></a>01417 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">void</span> replaceFirstWithEscape(base::type::string_t&amp; str, <span class="keyword">const</span> base::type::string_t&amp; replaceWhat, <span class="comment">// NOLINT</span>
<a name="l01418"></a>01418                                        <span class="keyword">const</span> std::string&amp; replaceWith)
<a name="l01419"></a>01419     {
<a name="l01420"></a>01420         replaceFirstWithEscape(str, replaceWhat, base::type::string_t(replaceWith.begin(), replaceWith.end()));
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422 <span class="preprocessor">#endif  // defined(ELPP_UNICODE)</span>
<a name="l01426"></a>01426 <span class="preprocessor">    static inline std::string&amp; toUpper(std::string&amp; str)</span>
<a name="l01427"></a>01427 <span class="preprocessor"></span>    {
<a name="l01428"></a>01428         std::transform(str.begin(), str.end(), str.begin(), ::toupper);
<a name="l01429"></a>01429         <span class="keywordflow">return</span> str;
<a name="l01430"></a>01430     }
<a name="l01431"></a>01431 
<a name="l01433"></a>01433     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> cStringEq(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1, <span class="keyword">const</span> <span class="keywordtype">char</span>* s2)
<a name="l01434"></a>01434     {
<a name="l01435"></a>01435         <span class="keywordflow">if</span> (s1 == <span class="keyword">nullptr</span> &amp;&amp; s2 == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01436"></a>01436         <span class="keywordflow">if</span> (s1 == <span class="keyword">nullptr</span> || s2 == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01437"></a>01437         <span class="keywordflow">return</span> strcmp(s1, s2) == 0;
<a name="l01438"></a>01438     }
<a name="l01439"></a>01439 
<a name="l01442"></a>01442     <span class="keyword">static</span> <span class="keywordtype">bool</span> cStringCaseEq(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1, <span class="keyword">const</span> <span class="keywordtype">char</span>* s2)
<a name="l01443"></a>01443     {
<a name="l01444"></a>01444         <span class="keywordflow">if</span> (s1 == <span class="keyword">nullptr</span> &amp;&amp; s2 == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01445"></a>01445         <span class="keywordflow">if</span> (s1 == <span class="keyword">nullptr</span> || s2 == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01446"></a>01446         <span class="keywordflow">if</span> (strlen(s1) != strlen(s2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01447"></a>01447         <span class="keywordflow">while</span> (*s1 != <span class="charliteral">&apos;\0&apos;</span> &amp;&amp; *s2 != <span class="charliteral">&apos;\0&apos;</span>) {
<a name="l01448"></a>01448             <span class="keywordflow">if</span> (::toupper(*s1) != ::toupper(*s2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01449"></a>01449             ++s1;
<a name="l01450"></a>01450             ++s2;
<a name="l01451"></a>01451         }
<a name="l01452"></a>01452         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01453"></a>01453     }
<a name="l01454"></a>01454 
<a name="l01456"></a>01456     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> contains(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">char</span> c)
<a name="l01457"></a>01457     {
<a name="l01458"></a>01458         <span class="keywordflow">for</span> (; *str; ++str) {
<a name="l01459"></a>01459             <span class="keywordflow">if</span> (*str == c)
<a name="l01460"></a>01460                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01461"></a>01461         }
<a name="l01462"></a>01462         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01463"></a>01463     }
<a name="l01464"></a>01464 
<a name="l01465"></a>01465     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* convertAndAddToBuff(std::size_t n, <span class="keywordtype">int</span> len, <span class="keywordtype">char</span>* buf, <span class="keyword">const</span> <span class="keywordtype">char</span>* bufLim, <span class="keywordtype">bool</span> zeroPadded = <span class="keyword">true</span>)
<a name="l01466"></a>01466     {
<a name="l01467"></a>01467         <span class="keywordtype">char</span> localBuff[10] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l01468"></a>01468         <span class="keywordtype">char</span>* p = localBuff + <span class="keyword">sizeof</span>(localBuff) - 2;
<a name="l01469"></a>01469         <span class="keywordflow">if</span> (n &gt; 0) {
<a name="l01470"></a>01470             <span class="keywordflow">for</span> (; n &gt; 0 &amp;&amp; p &gt; localBuff &amp;&amp; len &gt; 0; n /= 10, --len)
<a name="l01471"></a>01471                 * --p = static_cast&lt;char&gt;(n % 10 + <span class="charliteral">&apos;0&apos;</span>);
<a name="l01472"></a>01472         } <span class="keywordflow">else</span> {
<a name="l01473"></a>01473             *--p = <span class="charliteral">&apos;0&apos;</span>;
<a name="l01474"></a>01474             --len;
<a name="l01475"></a>01475         }
<a name="l01476"></a>01476         <span class="keywordflow">if</span> (zeroPadded)
<a name="l01477"></a>01477             <span class="keywordflow">while</span> (p &gt; localBuff &amp;&amp; len-- &gt; 0) *--p = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&apos;0&apos;</span>);
<a name="l01478"></a>01478         <span class="keywordflow">return</span> addToBuff(p, buf, bufLim);
<a name="l01479"></a>01479     }
<a name="l01480"></a>01480 
<a name="l01481"></a>01481     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* addToBuff(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">char</span>* buf, <span class="keyword">const</span> <span class="keywordtype">char</span>* bufLim)
<a name="l01482"></a>01482     {
<a name="l01483"></a>01483         <span class="keywordflow">while</span> ((buf &lt; bufLim) &amp;&amp; ((*buf = *str++) != <span class="charliteral">&apos;\0&apos;</span>))
<a name="l01484"></a>01484             ++buf;
<a name="l01485"></a>01485         <span class="keywordflow">return</span> buf;
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487 
<a name="l01488"></a>01488     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* clearBuff(<span class="keywordtype">char</span> buff[], std::size_t lim)
<a name="l01489"></a>01489     {
<a name="l01490"></a>01490         STRCPY(buff, <span class="stringliteral">&quot;&quot;</span>, lim);
<a name="l01491"></a>01491         ELPP_UNUSED(lim);  <span class="comment">// For *nix we dont have anything using lim in above STRCPY macro</span>
<a name="l01492"></a>01492         <span class="keywordflow">return</span> buff;
<a name="l01493"></a>01493     }
<a name="l01494"></a>01494 
<a name="l01497"></a>01497     <span class="keyword">static</span> <span class="keywordtype">char</span>* wcharPtrToCharPtr(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* line)
<a name="l01498"></a>01498     {
<a name="l01499"></a>01499         std::size_t len_ = wcslen(line) + 1;
<a name="l01500"></a>01500         <span class="keywordtype">char</span>* buff_ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(malloc(len_ + 1));
<a name="l01501"></a>01501 <span class="preprocessor">#      if ELPP_OS_UNIX || (ELPP_OS_WINDOWS &amp;&amp; !ELPP_CRT_DBG_WARNINGS)</span>
<a name="l01502"></a>01502 <span class="preprocessor"></span>        std::wcstombs(buff_, line, len_);
<a name="l01503"></a>01503 <span class="preprocessor">#      elif ELPP_OS_WINDOWS</span>
<a name="l01504"></a>01504 <span class="preprocessor"></span>        std::size_t convCount_ = 0;
<a name="l01505"></a>01505         mbstate_t mbState_;
<a name="l01506"></a>01506         ::memset(<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;mbState_), 0, <span class="keyword">sizeof</span>(mbState_));
<a name="l01507"></a>01507         wcsrtombs_s(&amp;convCount_, buff_, len_, &amp;line, len_, &amp;mbState_);
<a name="l01508"></a>01508 <span class="preprocessor">#      endif  // ELPP_OS_UNIX || (ELPP_OS_WINDOWS &amp;&amp; !ELPP_CRT_DBG_WARNINGS)</span>
<a name="l01509"></a>01509 <span class="preprocessor"></span>        <span class="keywordflow">return</span> buff_;
<a name="l01510"></a>01510     }
<a name="l01511"></a>01511 };
<a name="l01513"></a>01513 <span class="keyword">class </span>OS : base::StaticClass
<a name="l01514"></a>01514 {
<a name="l01515"></a>01515 <span class="keyword">public</span>:
<a name="l01516"></a>01516 <span class="preprocessor">#if ELPP_OS_WINDOWS</span>
<a name="l01521"></a>01521 <span class="preprocessor">    static const char* getWindowsEnvironmentVariable(const char* varname)</span>
<a name="l01522"></a>01522 <span class="preprocessor"></span>    {
<a name="l01523"></a>01523         <span class="keyword">const</span> DWORD bufferLen = 50;
<a name="l01524"></a>01524         <span class="keyword">static</span> <span class="keywordtype">char</span> buffer[bufferLen];
<a name="l01525"></a>01525         <span class="keywordflow">if</span> (GetEnvironmentVariableA(varname, buffer, bufferLen)) {
<a name="l01526"></a>01526             <span class="keywordflow">return</span> buffer;
<a name="l01527"></a>01527         }
<a name="l01528"></a>01528         <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530 <span class="preprocessor">#endif  // ELPP_OS_WINDOWS</span>
<a name="l01531"></a>01531 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_OS_ANDROID</span>
<a name="l01533"></a>01533 <span class="preprocessor">    static inline std::string getProperty(const char* prop)</span>
<a name="l01534"></a>01534 <span class="preprocessor"></span>    {
<a name="l01535"></a>01535         <span class="keywordtype">char</span> propVal[PROP_VALUE_MAX + 1];
<a name="l01536"></a>01536         <span class="keywordtype">int</span> ret = __system_property_get(prop, propVal);
<a name="l01537"></a>01537         <span class="keywordflow">return</span> ret == 0 ? std::string() : std::string(propVal);
<a name="l01538"></a>01538     }
<a name="l01539"></a>01539 
<a name="l01541"></a>01541     <span class="keyword">static</span> std::string getDeviceName(<span class="keywordtype">void</span>)
<a name="l01542"></a>01542     {
<a name="l01543"></a>01543         std::stringstream ss;
<a name="l01544"></a>01544         std::string manufacturer = getProperty(<span class="stringliteral">&quot;ro.product.manufacturer&quot;</span>);
<a name="l01545"></a>01545         std::string model = getProperty(<span class="stringliteral">&quot;ro.product.model&quot;</span>);
<a name="l01546"></a>01546         <span class="keywordflow">if</span> (manufacturer.empty() || model.empty()) {
<a name="l01547"></a>01547             <span class="keywordflow">return</span> std::string();
<a name="l01548"></a>01548         }
<a name="l01549"></a>01549         ss &lt;&lt; manufacturer &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; model;
<a name="l01550"></a>01550         <span class="keywordflow">return</span> ss.str();
<a name="l01551"></a>01551     }
<a name="l01552"></a>01552 <span class="preprocessor">#endif  // ELPP_OS_ANDROID</span>
<a name="l01553"></a>01553 <span class="preprocessor"></span>
<a name="l01559"></a>01559     <span class="keyword">static</span> <span class="keyword">const</span> std::string getBashOutput(<span class="keyword">const</span> <span class="keywordtype">char</span>* command)
<a name="l01560"></a>01560     {
<a name="l01561"></a>01561 <span class="preprocessor">#if (ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID &amp;&amp; !ELPP_CYGWIN)</span>
<a name="l01562"></a>01562 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (command == <span class="keyword">nullptr</span>) {
<a name="l01563"></a>01563             <span class="keywordflow">return</span> std::string();
<a name="l01564"></a>01564         }
<a name="l01565"></a>01565         FILE* proc = <span class="keyword">nullptr</span>;
<a name="l01566"></a>01566         <span class="keywordflow">if</span> ((proc = popen(command, <span class="stringliteral">&quot;r&quot;</span>)) == <span class="keyword">nullptr</span>) {
<a name="l01567"></a>01567             ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;\nUnable to run command [&quot;</span> &lt;&lt; command &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>, <span class="keyword">true</span>);
<a name="l01568"></a>01568             <span class="keywordflow">return</span> std::string();
<a name="l01569"></a>01569         }
<a name="l01570"></a>01570         <span class="keywordtype">char</span> hBuff[4096];
<a name="l01571"></a>01571         <span class="keywordflow">if</span> (fgets(hBuff, <span class="keyword">sizeof</span>(hBuff), proc) != <span class="keyword">nullptr</span>) {
<a name="l01572"></a>01572             pclose(proc);
<a name="l01573"></a>01573             <span class="keywordflow">if</span> (hBuff[strlen(hBuff) - 1] == <span class="charliteral">&apos;\n&apos;</span>) {
<a name="l01574"></a>01574                 hBuff[strlen(hBuff) - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01575"></a>01575             }
<a name="l01576"></a>01576             <span class="keywordflow">return</span> std::string(hBuff);
<a name="l01577"></a>01577         }
<a name="l01578"></a>01578         <span class="keywordflow">return</span> std::string();
<a name="l01579"></a>01579 <span class="preprocessor">#else</span>
<a name="l01580"></a>01580 <span class="preprocessor"></span>        ELPP_UNUSED(command);
<a name="l01581"></a>01581         <span class="keywordflow">return</span> std::string();
<a name="l01582"></a>01582 <span class="preprocessor">#endif  // (ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID &amp;&amp; !ELPP_CYGWIN)</span>
<a name="l01583"></a>01583 <span class="preprocessor"></span>    }
<a name="l01584"></a>01584 
<a name="l01590"></a>01590     <span class="keyword">static</span> std::string getEnvironmentVariable(<span class="keyword">const</span> <span class="keywordtype">char</span>* variableName, <span class="keyword">const</span> <span class="keywordtype">char</span>* defaultVal, <span class="keyword">const</span> <span class="keywordtype">char</span>* alternativeBashCommand = <span class="keyword">nullptr</span>)
<a name="l01591"></a>01591     {
<a name="l01592"></a>01592 <span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l01593"></a>01593 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">char</span>* val = getenv(variableName);
<a name="l01594"></a>01594 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l01595"></a>01595 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">char</span>* val = getWindowsEnvironmentVariable(variableName);
<a name="l01596"></a>01596 <span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l01597"></a>01597 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((val == <span class="keyword">nullptr</span>) || ((strcmp(val, <span class="stringliteral">&quot;&quot;</span>) == 0))) {
<a name="l01598"></a>01598 <span class="preprocessor">#if ELPP_OS_UNIX &amp;&amp; defined(ELPP_FORCE_ENV_VAR_FROM_BASH)</span>
<a name="l01599"></a>01599 <span class="preprocessor"></span>            <span class="comment">// Try harder on unix-based systems</span>
<a name="l01600"></a>01600             std::string valBash = base::utils::OS::getBashOutput(alternativeBashCommand);
<a name="l01601"></a>01601             <span class="keywordflow">if</span> (valBash.empty()) {
<a name="l01602"></a>01602                 <span class="keywordflow">return</span> std::string(defaultVal);
<a name="l01603"></a>01603             } <span class="keywordflow">else</span> {
<a name="l01604"></a>01604                 <span class="keywordflow">return</span> valBash;
<a name="l01605"></a>01605             }
<a name="l01606"></a>01606 <span class="preprocessor">#elif ELPP_OS_WINDOWS || ELPP_OS_UNIX</span>
<a name="l01607"></a>01607 <span class="preprocessor"></span>            ELPP_UNUSED(alternativeBashCommand);
<a name="l01608"></a>01608             <span class="keywordflow">return</span> std::string(defaultVal);
<a name="l01609"></a>01609 <span class="preprocessor">#endif  // ELPP_OS_UNIX &amp;&amp; defined(ELPP_FORCE_ENV_VAR_FROM_BASH)</span>
<a name="l01610"></a>01610 <span class="preprocessor"></span>        }
<a name="l01611"></a>01611         <span class="keywordflow">return</span> std::string(val);
<a name="l01612"></a>01612     }
<a name="l01614"></a>01614     <span class="keyword">static</span> <span class="keyword">inline</span> std::string currentUser(<span class="keywordtype">void</span>)
<a name="l01615"></a>01615     {
<a name="l01616"></a>01616 <span class="preprocessor">#if ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID</span>
<a name="l01617"></a>01617 <span class="preprocessor"></span>        <span class="keywordflow">return</span> getEnvironmentVariable(<span class="stringliteral">&quot;USER&quot;</span>, base::consts::kUnknownUser, <span class="stringliteral">&quot;whoami&quot;</span>);
<a name="l01618"></a>01618 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l01619"></a>01619 <span class="preprocessor"></span>        <span class="keywordflow">return</span> getEnvironmentVariable(<span class="stringliteral">&quot;USERNAME&quot;</span>, base::consts::kUnknownUser);
<a name="l01620"></a>01620 <span class="preprocessor">#elif ELPP_OS_ANDROID</span>
<a name="l01621"></a>01621 <span class="preprocessor"></span>        ELPP_UNUSED(base::consts::kUnknownUser);
<a name="l01622"></a>01622         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;android&quot;</span>);
<a name="l01623"></a>01623 <span class="preprocessor">#else</span>
<a name="l01624"></a>01624 <span class="preprocessor"></span>        <span class="keywordflow">return</span> std::string();
<a name="l01625"></a>01625 <span class="preprocessor">#endif  // ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID</span>
<a name="l01626"></a>01626 <span class="preprocessor"></span>    }
<a name="l01627"></a>01627 
<a name="l01631"></a>01631     <span class="keyword">static</span> <span class="keyword">inline</span> std::string currentHost(<span class="keywordtype">void</span>)
<a name="l01632"></a>01632     {
<a name="l01633"></a>01633 <span class="preprocessor">#if ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID</span>
<a name="l01634"></a>01634 <span class="preprocessor"></span>        <span class="keywordflow">return</span> getEnvironmentVariable(<span class="stringliteral">&quot;HOSTNAME&quot;</span>, base::consts::kUnknownHost, <span class="stringliteral">&quot;hostname&quot;</span>);
<a name="l01635"></a>01635 <span class="preprocessor">#elif ELPP_OS_WINDOWS</span>
<a name="l01636"></a>01636 <span class="preprocessor"></span>        <span class="keywordflow">return</span> getEnvironmentVariable(<span class="stringliteral">&quot;COMPUTERNAME&quot;</span>, base::consts::kUnknownHost);
<a name="l01637"></a>01637 <span class="preprocessor">#elif ELPP_OS_ANDROID</span>
<a name="l01638"></a>01638 <span class="preprocessor"></span>        ELPP_UNUSED(base::consts::kUnknownHost);
<a name="l01639"></a>01639         <span class="keywordflow">return</span> getDeviceName();
<a name="l01640"></a>01640 <span class="preprocessor">#else</span>
<a name="l01641"></a>01641 <span class="preprocessor"></span>        <span class="keywordflow">return</span> std::string();
<a name="l01642"></a>01642 <span class="preprocessor">#endif  // ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID</span>
<a name="l01643"></a>01643 <span class="preprocessor"></span>    }
<a name="l01645"></a>01645     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> termSupportsColor(<span class="keywordtype">void</span>)
<a name="l01646"></a>01646     {
<a name="l01647"></a>01647         std::string term = getEnvironmentVariable(<span class="stringliteral">&quot;TERM&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l01648"></a>01648         <span class="keywordflow">return</span> term == <span class="stringliteral">&quot;xterm&quot;</span> || term == <span class="stringliteral">&quot;xterm-color&quot;</span> || term == <span class="stringliteral">&quot;xterm-256color&quot;</span> ||
<a name="l01649"></a>01649                term == <span class="stringliteral">&quot;screen&quot;</span> || term == <span class="stringliteral">&quot;linux&quot;</span> || term == <span class="stringliteral">&quot;cygwin&quot;</span>;
<a name="l01650"></a>01650     }
<a name="l01651"></a>01651 };
<a name="l01652"></a>01652 <span class="keyword">extern</span> std::string s_currentUser;
<a name="l01653"></a>01653 <span class="keyword">extern</span> std::string s_currentHost;
<a name="l01654"></a>01654 <span class="keyword">extern</span> <span class="keywordtype">bool</span> s_termSupportsColor;
<a name="l01655"></a>01655 <span class="preprocessor">#define ELPP_INITI_BASIC_DECLR \</span>
<a name="l01656"></a>01656 <span class="preprocessor">    namespace el {\</span>
<a name="l01657"></a>01657 <span class="preprocessor">        namespace base {\</span>
<a name="l01658"></a>01658 <span class="preprocessor">            namespace utils {\</span>
<a name="l01659"></a>01659 <span class="preprocessor">                std::string s_currentUser = el::base::utils::OS::currentUser(); \</span>
<a name="l01660"></a>01660 <span class="preprocessor">                std::string s_currentHost = el::base::utils::OS::currentHost(); \</span>
<a name="l01661"></a>01661 <span class="preprocessor">                bool s_termSupportsColor = el::base::utils::OS::termSupportsColor(); \</span>
<a name="l01662"></a>01662 <span class="preprocessor">            }\</span>
<a name="l01663"></a>01663 <span class="preprocessor">        }\</span>
<a name="l01664"></a>01664 <span class="preprocessor">   }</span>
<a name="l01666"></a>01666 <span class="preprocessor">class DateTime : base::StaticClass</span>
<a name="l01667"></a>01667 <span class="preprocessor"></span>{
<a name="l01668"></a>01668 <span class="keyword">public</span>:
<a name="l01673"></a>01673     <span class="keyword">static</span> <span class="keywordtype">void</span> gettimeofday(<span class="keyword">struct</span> timeval* tv)
<a name="l01674"></a>01674     {
<a name="l01675"></a>01675 <span class="preprocessor">#if ELPP_OS_WINDOWS</span>
<a name="l01676"></a>01676 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (tv != <span class="keyword">nullptr</span>) {
<a name="l01677"></a>01677 <span class="preprocessor">#   if ELPP_COMPILER_MSVC || defined(_MSC_EXTENSIONS)</span>
<a name="l01678"></a>01678 <span class="preprocessor"></span>            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> __int64 delta_ = 11644473600000000Ui64;
<a name="l01679"></a>01679 <span class="preprocessor">#   else</span>
<a name="l01680"></a>01680 <span class="preprocessor"></span>            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> __int64 delta_ = 11644473600000000ULL;
<a name="l01681"></a>01681 <span class="preprocessor">#   endif  // ELPP_COMPILER_MSVC || defined(_MSC_EXTENSIONS)</span>
<a name="l01682"></a>01682 <span class="preprocessor"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> secOffSet = 0.000001;
<a name="l01683"></a>01683             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usecOffSet = 1000000;
<a name="l01684"></a>01684             FILETIME fileTime;
<a name="l01685"></a>01685             GetSystemTimeAsFileTime(&amp;fileTime);
<a name="l01686"></a>01686             <span class="keywordtype">unsigned</span> __int64 present = 0;
<a name="l01687"></a>01687             present |= fileTime.dwHighDateTime;
<a name="l01688"></a>01688             present = present &lt;&lt; 32;
<a name="l01689"></a>01689             present |= fileTime.dwLowDateTime;
<a name="l01690"></a>01690             present /= 10;  <span class="comment">// mic-sec</span>
<a name="l01691"></a>01691             <span class="comment">// Subtract the difference</span>
<a name="l01692"></a>01692             present -= delta_;
<a name="l01693"></a>01693             tv-&gt;tv_sec = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(present * secOffSet);
<a name="l01694"></a>01694             tv-&gt;tv_usec = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(present % usecOffSet);
<a name="l01695"></a>01695         }
<a name="l01696"></a>01696 <span class="preprocessor">#else</span>
<a name="l01697"></a>01697 <span class="preprocessor"></span>        ::gettimeofday(tv, <span class="keyword">nullptr</span>);
<a name="l01698"></a>01698 <span class="preprocessor">#endif  // ELPP_OS_WINDOWS</span>
<a name="l01699"></a>01699 <span class="preprocessor"></span>    }
<a name="l01700"></a>01700 
<a name="l01705"></a>01705     <span class="keyword">static</span> <span class="keyword">inline</span> std::string getDateTime(<span class="keyword">const</span> <span class="keywordtype">char</span>* format, <span class="keyword">const</span> base::MillisecondsWidth* msWidth)
<a name="l01706"></a>01706     {
<a name="l01707"></a>01707         <span class="keyword">struct </span>timeval currTime;
<a name="l01708"></a>01708         gettimeofday(&amp;currTime);
<a name="l01709"></a>01709         struct ::tm timeInfo;
<a name="l01710"></a>01710         buildTimeInfo(&amp;currTime, &amp;timeInfo);
<a name="l01711"></a>01711         <span class="keyword">const</span> <span class="keywordtype">int</span> kBuffSize = 30;
<a name="l01712"></a>01712         <span class="keywordtype">char</span> buff_[kBuffSize] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l01713"></a>01713         parseFormat(buff_, kBuffSize, format, &amp;timeInfo, static_cast&lt;std::size_t&gt;(currTime.tv_usec / msWidth-&gt;m_offset), msWidth);
<a name="l01714"></a>01714         <span class="keywordflow">return</span> std::string(buff_);
<a name="l01715"></a>01715     }
<a name="l01716"></a>01716 
<a name="l01718"></a>01718     <span class="keyword">static</span> base::type::string_t formatTime(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> time, base::TimestampUnit timestampUnit)
<a name="l01719"></a>01719     {
<a name="l01720"></a>01720         <span class="keywordtype">double</span> result = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(time);
<a name="l01721"></a>01721         base::type::EnumType start = <span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(timestampUnit);
<a name="l01722"></a>01722         <span class="keyword">const</span> base::type::char_t* unit = base::consts::kTimeFormats[start].unit;
<a name="l01723"></a>01723         <span class="keywordflow">for</span> (base::type::EnumType i = start; i &lt; base::consts::kTimeFormatsCount - 1; ++i) {
<a name="l01724"></a>01724             <span class="keywordflow">if</span> (result &lt;= base::consts::kTimeFormats[i].value) {
<a name="l01725"></a>01725                 <span class="keywordflow">break</span>;
<a name="l01726"></a>01726             }
<a name="l01727"></a>01727             result /= base::consts::kTimeFormats[i].value;
<a name="l01728"></a>01728             unit = base::consts::kTimeFormats[i + 1].unit;
<a name="l01729"></a>01729         }
<a name="l01730"></a>01730         base::type::stringstream_t ss;
<a name="l01731"></a>01731         ss &lt;&lt; result &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; unit;
<a name="l01732"></a>01732         <span class="keywordflow">return</span> ss.str();
<a name="l01733"></a>01733     }
<a name="l01734"></a>01734 
<a name="l01736"></a>01736     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> getTimeDifference(<span class="keyword">const</span> <span class="keyword">struct</span> timeval&amp; endTime, <span class="keyword">const</span> <span class="keyword">struct</span> timeval&amp; startTime, base::TimestampUnit timestampUnit)
<a name="l01737"></a>01737     {
<a name="l01738"></a>01738         <span class="keywordflow">if</span> (timestampUnit == base::TimestampUnit::Microsecond) {
<a name="l01739"></a>01739             <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(1000000 * endTime.tv_sec + endTime.tv_usec) -
<a name="l01740"></a>01740                                                    static_cast&lt;unsigned long long&gt;(1000000 * startTime.tv_sec + startTime.tv_usec));
<a name="l01741"></a>01741         } <span class="keywordflow">else</span> {
<a name="l01742"></a>01742             <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>((((endTime.tv_sec - startTime.tv_sec) * 1000000) + (endTime.tv_usec - startTime.tv_usec)) / 1000);
<a name="l01743"></a>01743         }
<a name="l01744"></a>01744     }
<a name="l01745"></a>01745 
<a name="l01746"></a>01746 <span class="keyword">private</span>:
<a name="l01747"></a>01747     <span class="keyword">static</span> <span class="keyword">inline</span> struct ::tm* buildTimeInfo(<span class="keyword">struct</span> timeval* currTime, struct ::tm* timeInfo)
<a name="l01748"></a>01748     {
<a name="l01749"></a>01749 <span class="preprocessor">#if ELPP_OS_UNIX</span>
<a name="l01750"></a>01750 <span class="preprocessor"></span>        time_t rawTime = currTime-&gt;tv_sec;
<a name="l01751"></a>01751         ::localtime_r(&amp;rawTime, timeInfo);
<a name="l01752"></a>01752         <span class="keywordflow">return</span> timeInfo;
<a name="l01753"></a>01753 <span class="preprocessor">#else</span>
<a name="l01754"></a>01754 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_COMPILER_MSVC</span>
<a name="l01755"></a>01755 <span class="preprocessor"></span>        ELPP_UNUSED(currTime);
<a name="l01756"></a>01756         time_t t;
<a name="l01757"></a>01757         _time64(&amp;t);
<a name="l01758"></a>01758         localtime_s(timeInfo, &amp;t);
<a name="l01759"></a>01759         <span class="keywordflow">return</span> timeInfo;
<a name="l01760"></a>01760 <span class="preprocessor">#   else</span>
<a name="l01761"></a>01761 <span class="preprocessor"></span>        <span class="comment">// For any other compilers that don&apos;t have CRT warnings issue e.g, MinGW or TDM GCC- we use different method</span>
<a name="l01762"></a>01762         time_t rawTime = currTime-&gt;tv_sec;
<a name="l01763"></a>01763         <span class="keyword">struct </span>tm* tmInf = localtime(&amp;rawTime);
<a name="l01764"></a>01764         *timeInfo = *tmInf;
<a name="l01765"></a>01765         <span class="keywordflow">return</span> timeInfo;
<a name="l01766"></a>01766 <span class="preprocessor">#   endif  // ELPP_COMPILER_MSVC</span>
<a name="l01767"></a>01767 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_OS_UNIX</span>
<a name="l01768"></a>01768 <span class="preprocessor"></span>    }
<a name="l01769"></a>01769     <span class="keyword">static</span> <span class="keywordtype">char</span>* parseFormat(<span class="keywordtype">char</span>* buf, std::size_t bufSz, <span class="keyword">const</span> <span class="keywordtype">char</span>* format, <span class="keyword">const</span> <span class="keyword">struct</span> tm* tInfo,
<a name="l01770"></a>01770                              std::size_t msec, <span class="keyword">const</span> base::MillisecondsWidth* msWidth)
<a name="l01771"></a>01771     {
<a name="l01772"></a>01772         <span class="keyword">const</span> <span class="keywordtype">char</span>* bufLim = buf + bufSz;
<a name="l01773"></a>01773         <span class="keywordflow">for</span> (; *format; ++format) {
<a name="l01774"></a>01774             <span class="keywordflow">if</span> (*format == base::consts::kFormatSpecifierChar) {
<a name="l01775"></a>01775                 <span class="keywordflow">switch</span> (*++format) {
<a name="l01776"></a>01776                     <span class="keywordflow">case</span> base::consts::kFormatSpecifierChar:  <span class="comment">// Escape</span>
<a name="l01777"></a>01777                         <span class="keywordflow">break</span>;
<a name="l01778"></a>01778                     <span class="keywordflow">case</span> <span class="charliteral">&apos;\0&apos;</span>:  <span class="comment">// End</span>
<a name="l01779"></a>01779                         --format;
<a name="l01780"></a>01780                         <span class="keywordflow">break</span>;
<a name="l01781"></a>01781                     <span class="keywordflow">case</span> <span class="charliteral">&apos;d&apos;</span>:  <span class="comment">// Day</span>
<a name="l01782"></a>01782                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_mday, 2, buf, bufLim);
<a name="l01783"></a>01783                         <span class="keywordflow">continue</span>;
<a name="l01784"></a>01784                     <span class="keywordflow">case</span> <span class="charliteral">&apos;a&apos;</span>:  <span class="comment">// Day of week (short)</span>
<a name="l01785"></a>01785                         buf = base::utils::Str::addToBuff(base::consts::kDaysAbbrev[tInfo-&gt;tm_wday], buf, bufLim);
<a name="l01786"></a>01786                         <span class="keywordflow">continue</span>;
<a name="l01787"></a>01787                     <span class="keywordflow">case</span> <span class="charliteral">&apos;A&apos;</span>:  <span class="comment">// Day of week (long)</span>
<a name="l01788"></a>01788                         buf = base::utils::Str::addToBuff(base::consts::kDays[tInfo-&gt;tm_wday], buf, bufLim);
<a name="l01789"></a>01789                         <span class="keywordflow">continue</span>;
<a name="l01790"></a>01790                     <span class="keywordflow">case</span> <span class="charliteral">&apos;M&apos;</span>:  <span class="comment">// month</span>
<a name="l01791"></a>01791                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_mon + 1, 2, buf, bufLim);
<a name="l01792"></a>01792                         <span class="keywordflow">continue</span>;
<a name="l01793"></a>01793                     <span class="keywordflow">case</span> <span class="charliteral">&apos;b&apos;</span>:  <span class="comment">// month (short)</span>
<a name="l01794"></a>01794                         buf = base::utils::Str::addToBuff(base::consts::kMonthsAbbrev[tInfo-&gt;tm_mon], buf, bufLim);
<a name="l01795"></a>01795                         <span class="keywordflow">continue</span>;
<a name="l01796"></a>01796                     <span class="keywordflow">case</span> <span class="charliteral">&apos;B&apos;</span>:  <span class="comment">// month (long)</span>
<a name="l01797"></a>01797                         buf = base::utils::Str::addToBuff(base::consts::kMonths[tInfo-&gt;tm_mon], buf, bufLim);
<a name="l01798"></a>01798                         <span class="keywordflow">continue</span>;
<a name="l01799"></a>01799                     <span class="keywordflow">case</span> <span class="charliteral">&apos;y&apos;</span>:  <span class="comment">// year (two digits)</span>
<a name="l01800"></a>01800                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_year + base::consts::kYearBase, 2, buf, bufLim);
<a name="l01801"></a>01801                         <span class="keywordflow">continue</span>;
<a name="l01802"></a>01802                     <span class="keywordflow">case</span> <span class="charliteral">&apos;Y&apos;</span>:  <span class="comment">// year (four digits)</span>
<a name="l01803"></a>01803                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_year + base::consts::kYearBase, 4, buf, bufLim);
<a name="l01804"></a>01804                         <span class="keywordflow">continue</span>;
<a name="l01805"></a>01805                     <span class="keywordflow">case</span> <span class="charliteral">&apos;h&apos;</span>:  <span class="comment">// hour (12-hour)</span>
<a name="l01806"></a>01806                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_hour % 12, 2, buf, bufLim);
<a name="l01807"></a>01807                         <span class="keywordflow">continue</span>;
<a name="l01808"></a>01808                     <span class="keywordflow">case</span> <span class="charliteral">&apos;H&apos;</span>:  <span class="comment">// hour (24-hour)</span>
<a name="l01809"></a>01809                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_hour, 2, buf, bufLim);
<a name="l01810"></a>01810                         <span class="keywordflow">continue</span>;
<a name="l01811"></a>01811                     <span class="keywordflow">case</span> <span class="charliteral">&apos;m&apos;</span>:  <span class="comment">// minute</span>
<a name="l01812"></a>01812                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_min, 2, buf, bufLim);
<a name="l01813"></a>01813                         <span class="keywordflow">continue</span>;
<a name="l01814"></a>01814                     <span class="keywordflow">case</span> <span class="charliteral">&apos;s&apos;</span>:  <span class="comment">// second</span>
<a name="l01815"></a>01815                         buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_sec, 2, buf, bufLim);
<a name="l01816"></a>01816                         <span class="keywordflow">continue</span>;
<a name="l01817"></a>01817                     <span class="keywordflow">case</span> <span class="charliteral">&apos;z&apos;</span>:  <span class="comment">// milliseconds</span>
<a name="l01818"></a>01818                     <span class="keywordflow">case</span> <span class="charliteral">&apos;g&apos;</span>:
<a name="l01819"></a>01819                         buf = base::utils::Str::convertAndAddToBuff(msec, msWidth-&gt;m_width, buf, bufLim);
<a name="l01820"></a>01820                         <span class="keywordflow">continue</span>;
<a name="l01821"></a>01821                     <span class="keywordflow">case</span> <span class="charliteral">&apos;F&apos;</span>:  <span class="comment">// AM/PM</span>
<a name="l01822"></a>01822                         buf = base::utils::Str::addToBuff((tInfo-&gt;tm_hour &gt;= 12) ? base::consts::kPm : base::consts::kAm, buf, bufLim);
<a name="l01823"></a>01823                         <span class="keywordflow">continue</span>;
<a name="l01824"></a>01824                     <span class="keywordflow">default</span>:
<a name="l01825"></a>01825                         <span class="keywordflow">continue</span>;
<a name="l01826"></a>01826                 }
<a name="l01827"></a>01827             }
<a name="l01828"></a>01828             <span class="keywordflow">if</span> (buf == bufLim) <span class="keywordflow">break</span>;
<a name="l01829"></a>01829             *buf++ = *format;
<a name="l01830"></a>01830         }
<a name="l01831"></a>01831         <span class="keywordflow">return</span> buf;
<a name="l01832"></a>01832     }
<a name="l01833"></a>01833 };
<a name="l01835"></a>01835 <span class="keyword">class </span>CommandLineArgs
<a name="l01836"></a>01836 {
<a name="l01837"></a>01837 <span class="keyword">public</span>:
<a name="l01838"></a>01838     CommandLineArgs(<span class="keywordtype">void</span>)
<a name="l01839"></a>01839     {
<a name="l01840"></a>01840         setArgs(0, static_cast&lt;char**&gt;(<span class="keyword">nullptr</span>));
<a name="l01841"></a>01841     }
<a name="l01842"></a>01842     CommandLineArgs(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)
<a name="l01843"></a>01843     {
<a name="l01844"></a>01844         setArgs(argc, argv);
<a name="l01845"></a>01845     }
<a name="l01846"></a>01846     CommandLineArgs(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
<a name="l01847"></a>01847     {
<a name="l01848"></a>01848         setArgs(argc, argv);
<a name="l01849"></a>01849     }
<a name="l01850"></a>01850     <span class="keyword">virtual</span> ~CommandLineArgs(<span class="keywordtype">void</span>) {}
<a name="l01852"></a>01852     <span class="keyword">inline</span> <span class="keywordtype">void</span> setArgs(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)
<a name="l01853"></a>01853     {
<a name="l01854"></a>01854         setArgs(argc, const_cast&lt;char**&gt;(argv));
<a name="l01855"></a>01855     }
<a name="l01857"></a>01857     <span class="keyword">inline</span> <span class="keywordtype">void</span> setArgs(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
<a name="l01858"></a>01858     {
<a name="l01859"></a>01859         m_params.clear();
<a name="l01860"></a>01860         m_paramsWithValue.clear();
<a name="l01861"></a>01861         <span class="keywordflow">if</span> (argc == 0 || argv == <span class="keyword">nullptr</span>) {
<a name="l01862"></a>01862             <span class="keywordflow">return</span>;
<a name="l01863"></a>01863         }
<a name="l01864"></a>01864         m_argc = argc;
<a name="l01865"></a>01865         m_argv = argv;
<a name="l01866"></a>01866         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; m_argc; ++i) {
<a name="l01867"></a>01867             <span class="keyword">const</span> <span class="keywordtype">char</span>* v = (strstr(m_argv[i], <span class="stringliteral">&quot;=&quot;</span>));
<a name="l01868"></a>01868             <span class="keywordflow">if</span> (v != <span class="keyword">nullptr</span> &amp;&amp; strlen(v) &gt; 0) {
<a name="l01869"></a>01869                 std::string key = std::string(m_argv[i]);
<a name="l01870"></a>01870                 key = key.substr(0, key.find_first_of(<span class="charliteral">&apos;=&apos;</span>));
<a name="l01871"></a>01871                 <span class="keywordflow">if</span> (hasParamWithValue(key.c_str())) {
<a name="l01872"></a>01872                     ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Skipping [&quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot;] arg since it already has value [&quot;</span>
<a name="l01873"></a>01873                                        &lt;&lt; getParamValue(key.c_str()) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l01874"></a>01874                 } <span class="keywordflow">else</span> {
<a name="l01875"></a>01875                     m_paramsWithValue.insert(std::make_pair(key, std::string(v + 1)));
<a name="l01876"></a>01876                 }
<a name="l01877"></a>01877             }
<a name="l01878"></a>01878             <span class="keywordflow">if</span> (v == <span class="keyword">nullptr</span>) {
<a name="l01879"></a>01879                 <span class="keywordflow">if</span> (hasParam(m_argv[i])) {
<a name="l01880"></a>01880                     ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Skipping [&quot;</span> &lt;&lt; m_argv[i] &lt;&lt; <span class="stringliteral">&quot;] arg since it already exists&quot;</span>);
<a name="l01881"></a>01881                 } <span class="keywordflow">else</span> {
<a name="l01882"></a>01882                     m_params.push_back(std::string(m_argv[i]));
<a name="l01883"></a>01883                 }
<a name="l01884"></a>01884             }
<a name="l01885"></a>01885         }
<a name="l01886"></a>01886     }
<a name="l01888"></a>01888     <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasParamWithValue(<span class="keyword">const</span> <span class="keywordtype">char</span>* paramKey)<span class="keyword"> const</span>
<a name="l01889"></a>01889 <span class="keyword">    </span>{
<a name="l01890"></a>01890         <span class="keywordflow">return</span> m_paramsWithValue.find(std::string(paramKey)) != m_paramsWithValue.end();
<a name="l01891"></a>01891     }
<a name="l01894"></a>01894     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* getParamValue(<span class="keyword">const</span> <span class="keywordtype">char</span>* paramKey)<span class="keyword"> const</span>
<a name="l01895"></a>01895 <span class="keyword">    </span>{
<a name="l01896"></a>01896         <span class="keywordflow">return</span> m_paramsWithValue.find(std::string(paramKey))-&gt;second.c_str();
<a name="l01897"></a>01897     }
<a name="l01899"></a>01899     <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasParam(<span class="keyword">const</span> <span class="keywordtype">char</span>* paramKey)<span class="keyword"> const</span>
<a name="l01900"></a>01900 <span class="keyword">    </span>{
<a name="l01901"></a>01901         <span class="keywordflow">return</span> std::find(m_params.begin(), m_params.end(), std::string(paramKey)) != m_params.end();
<a name="l01902"></a>01902     }
<a name="l01904"></a>01904     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l01905"></a>01905 <span class="keyword">    </span>{
<a name="l01906"></a>01906         <span class="keywordflow">return</span> m_params.empty() &amp;&amp; m_paramsWithValue.empty();
<a name="l01907"></a>01907     }
<a name="l01909"></a>01909     <span class="keyword">inline</span> std::size_t size(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l01910"></a>01910 <span class="keyword">    </span>{
<a name="l01911"></a>01911         <span class="keywordflow">return</span> m_params.size() + m_paramsWithValue.size();
<a name="l01912"></a>01912     }
<a name="l01913"></a>01913     <span class="keyword">inline</span> <span class="keyword">friend</span> base::type::ostream_t&amp; operator&lt;&lt;(base::type::ostream_t&amp; os, <span class="keyword">const</span> CommandLineArgs&amp; c)
<a name="l01914"></a>01914     {
<a name="l01915"></a>01915         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; c.m_argc; ++i) {
<a name="l01916"></a>01916             os &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;[&quot;</span>) &lt;&lt; c.m_argv[i] &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l01917"></a>01917             <span class="keywordflow">if</span> (i &lt; c.m_argc - 1) {
<a name="l01918"></a>01918                 os &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot; &quot;</span>);
<a name="l01919"></a>01919             }
<a name="l01920"></a>01920         }
<a name="l01921"></a>01921         <span class="keywordflow">return</span> os;
<a name="l01922"></a>01922     }
<a name="l01923"></a>01923 
<a name="l01924"></a>01924 <span class="keyword">private</span>:
<a name="l01925"></a>01925     <span class="keywordtype">int</span> m_argc;
<a name="l01926"></a>01926     <span class="keywordtype">char</span>** m_argv;
<a name="l01927"></a>01927     std::map&lt;std::string, std::string&gt; m_paramsWithValue;
<a name="l01928"></a>01928     std::vector&lt;std::string&gt; m_params;
<a name="l01929"></a>01929 };
<a name="l01936"></a>01936 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_Ptr, <span class="keyword">typename</span> Container&gt;
<a name="l01937"></a>01937 <span class="keyword">class </span>AbstractRegistry : <span class="keyword">public</span> base::threading::ThreadSafe
<a name="l01938"></a>01938 {
<a name="l01939"></a>01939 <span class="keyword">public</span>:
<a name="l01940"></a>01940     <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iterator;
<a name="l01941"></a>01941     <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::const_iterator const_iterator;
<a name="l01942"></a>01942 
<a name="l01944"></a>01944     AbstractRegistry(<span class="keywordtype">void</span>) {}
<a name="l01945"></a>01945 
<a name="l01947"></a>01947     AbstractRegistry(AbstractRegistry&amp;&amp; sr)
<a name="l01948"></a>01948     {
<a name="l01949"></a>01949         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;sr) {
<a name="l01950"></a>01950             <span class="keywordflow">return</span>;
<a name="l01951"></a>01951         }
<a name="l01952"></a>01952         unregisterAll();
<a name="l01953"></a>01953         m_list = std::move(sr.m_list);
<a name="l01954"></a>01954     }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956     <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> AbstractRegistry&lt;T_Ptr, Container&gt;&amp; other)
<a name="l01957"></a>01957     {
<a name="l01958"></a>01958         <span class="keywordflow">if</span> (size() != other.size()) {
<a name="l01959"></a>01959             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01960"></a>01960         }
<a name="l01961"></a>01961         <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; m_list.size(); ++i) {
<a name="l01962"></a>01962             <span class="keywordflow">if</span> (m_list.at(i) != other.m_list.at(i)) {
<a name="l01963"></a>01963                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01964"></a>01964             }
<a name="l01965"></a>01965         }
<a name="l01966"></a>01966         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01967"></a>01967     }
<a name="l01968"></a>01968 
<a name="l01969"></a>01969     <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> AbstractRegistry&lt;T_Ptr, Container&gt;&amp; other)
<a name="l01970"></a>01970     {
<a name="l01971"></a>01971         <span class="keywordflow">if</span> (size() != other.size()) {
<a name="l01972"></a>01972             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01973"></a>01973         }
<a name="l01974"></a>01974         <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; m_list.size(); ++i) {
<a name="l01975"></a>01975             <span class="keywordflow">if</span> (m_list.at(i) != other.m_list.at(i)) {
<a name="l01976"></a>01976                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01977"></a>01977             }
<a name="l01978"></a>01978         }
<a name="l01979"></a>01979         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01980"></a>01980     }
<a name="l01981"></a>01981 
<a name="l01983"></a>01983     AbstractRegistry&amp; operator=(AbstractRegistry&amp;&amp; sr)
<a name="l01984"></a>01984     {
<a name="l01985"></a>01985         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;sr) {
<a name="l01986"></a>01986             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01987"></a>01987         }
<a name="l01988"></a>01988         unregisterAll();
<a name="l01989"></a>01989         m_list = std::move(sr.m_list);
<a name="l01990"></a>01990         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01991"></a>01991     }
<a name="l01992"></a>01992 
<a name="l01993"></a>01993     <span class="keyword">virtual</span> ~AbstractRegistry(<span class="keywordtype">void</span>)
<a name="l01994"></a>01994     {
<a name="l01995"></a>01995     }
<a name="l01996"></a>01996 
<a name="l01998"></a>01998     <span class="keyword">virtual</span> <span class="keyword">inline</span> iterator begin(<span class="keywordtype">void</span>) ELPP_FINAL {
<a name="l01999"></a>01999         <span class="keywordflow">return</span> m_list.begin();
<a name="l02000"></a>02000     }
<a name="l02001"></a>02001 
<a name="l02003"></a>02003     <span class="keyword">virtual</span> <span class="keyword">inline</span> iterator end(<span class="keywordtype">void</span>) ELPP_FINAL {
<a name="l02004"></a>02004         <span class="keywordflow">return</span> m_list.end();
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 
<a name="l02009"></a>02009     <span class="keyword">virtual</span> <span class="keyword">inline</span> const_iterator cbegin(<span class="keywordtype">void</span>) const ELPP_FINAL
<a name="l02010"></a>02010     {
<a name="l02011"></a>02011         <span class="keywordflow">return</span> m_list.cbegin();
<a name="l02012"></a>02012     }
<a name="l02013"></a>02013 
<a name="l02015"></a>02015     <span class="keyword">virtual</span> <span class="keyword">inline</span> const_iterator cend(<span class="keywordtype">void</span>) const ELPP_FINAL
<a name="l02016"></a>02016     {
<a name="l02017"></a>02017         <span class="keywordflow">return</span> m_list.cend();
<a name="l02018"></a>02018     }
<a name="l02019"></a>02019 
<a name="l02021"></a>02021     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty(<span class="keywordtype">void</span>) const ELPP_FINAL
<a name="l02022"></a>02022     {
<a name="l02023"></a>02023         <span class="keywordflow">return</span> m_list.empty();
<a name="l02024"></a>02024     }
<a name="l02025"></a>02025 
<a name="l02027"></a>02027     <span class="keyword">virtual</span> <span class="keyword">inline</span> std::size_t size(<span class="keywordtype">void</span>) const ELPP_FINAL
<a name="l02028"></a>02028     {
<a name="l02029"></a>02029         <span class="keywordflow">return</span> m_list.size();
<a name="l02030"></a>02030     }
<a name="l02031"></a>02031 
<a name="l02033"></a>02033     <span class="keyword">virtual</span> <span class="keyword">inline</span> Container&amp; list(<span class="keywordtype">void</span>) ELPP_FINAL {
<a name="l02034"></a>02034         <span class="keywordflow">return</span> m_list;
<a name="l02035"></a>02035     }
<a name="l02036"></a>02036 
<a name="l02038"></a>02038     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keyword">const</span> Container&amp; list(<span class="keywordtype">void</span>) const ELPP_FINAL
<a name="l02039"></a>02039     {
<a name="l02040"></a>02040         <span class="keywordflow">return</span> m_list;
<a name="l02041"></a>02041     }
<a name="l02042"></a>02042 
<a name="l02044"></a>02044     <span class="keyword">virtual</span> <span class="keywordtype">void</span> unregisterAll(<span class="keywordtype">void</span>) = 0;
<a name="l02045"></a>02045 
<a name="l02046"></a>02046 <span class="keyword">protected</span>:
<a name="l02047"></a>02047     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deepCopy(<span class="keyword">const</span> AbstractRegistry&lt;T_Ptr, Container&gt;&amp;) = 0;
<a name="l02048"></a>02048     <span class="keywordtype">void</span> reinitDeepCopy(<span class="keyword">const</span> AbstractRegistry&lt;T_Ptr, Container&gt;&amp; sr)
<a name="l02049"></a>02049     {
<a name="l02050"></a>02050         unregisterAll();
<a name="l02051"></a>02051         deepCopy(sr);
<a name="l02052"></a>02052     }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="keyword">private</span>:
<a name="l02055"></a>02055     Container m_list;
<a name="l02056"></a>02056 };
<a name="l02057"></a>02057 
<a name="l02063"></a>02063 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_Ptr, <span class="keyword">typename</span> T_Key = const <span class="keywordtype">char</span>*&gt;
<a name="l02064"></a>02064 <span class="keyword">class </span>Registry : <span class="keyword">public</span> AbstractRegistry&lt;T_Ptr, std::map&lt;T_Key, T_Ptr*&gt;&gt;
<a name="l02065"></a>02065 {
<a name="l02066"></a>02066 <span class="keyword">public</span>:
<a name="l02067"></a>02067     <span class="keyword">typedef</span> <span class="keyword">typename</span> Registry&lt;T_Ptr, T_Key&gt;::iterator iterator;
<a name="l02068"></a>02068     <span class="keyword">typedef</span> <span class="keyword">typename</span> Registry&lt;T_Ptr, T_Key&gt;::const_iterator const_iterator;
<a name="l02069"></a>02069 
<a name="l02070"></a>02070     Registry(<span class="keywordtype">void</span>) {}
<a name="l02071"></a>02071 
<a name="l02073"></a>02073     Registry(<span class="keyword">const</span> Registry&amp; sr) : AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr * &gt;&gt;()
<a name="l02074"></a>02074     {
<a name="l02075"></a>02075         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;sr) {
<a name="l02076"></a>02076             <span class="keywordflow">return</span>;
<a name="l02077"></a>02077         }
<a name="l02078"></a>02078         this-&gt;reinitDeepCopy(sr);
<a name="l02079"></a>02079     }
<a name="l02080"></a>02080 
<a name="l02084"></a>02084     Registry&amp; operator=(<span class="keyword">const</span> Registry&amp; sr)
<a name="l02085"></a>02085     {
<a name="l02086"></a>02086         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;sr) {
<a name="l02087"></a>02087             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02088"></a>02088         }
<a name="l02089"></a>02089         this-&gt;reinitDeepCopy(sr);
<a name="l02090"></a>02090         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02091"></a>02091     }
<a name="l02092"></a>02092 
<a name="l02093"></a>02093     <span class="keyword">virtual</span> ~Registry(<span class="keywordtype">void</span>)
<a name="l02094"></a>02094     {
<a name="l02095"></a>02095         unregisterAll();
<a name="l02096"></a>02096     }
<a name="l02097"></a>02097 
<a name="l02098"></a>02098 <span class="keyword">protected</span>:
<a name="l02099"></a>02099     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> unregisterAll(<span class="keywordtype">void</span>) ELPP_FINAL {
<a name="l02100"></a>02100         <span class="keywordflow">if</span> (!this-&gt;empty())
<a name="l02101"></a>02101         {
<a name="l02102"></a>02102             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; curr : this-&gt;list()) {
<a name="l02103"></a>02103                 base::utils::safeDelete(curr.second);
<a name="l02104"></a>02104             }
<a name="l02105"></a>02105             this-&gt;list().clear();
<a name="l02106"></a>02106         }
<a name="l02107"></a>02107     }
<a name="l02108"></a>02108 
<a name="l02110"></a>02110     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> registerNew(<span class="keyword">const</span> T_Key&amp; uniqKey, T_Ptr* ptr) ELPP_FINAL {
<a name="l02111"></a>02111         unregister(uniqKey);
<a name="l02112"></a>02112         this-&gt;list().insert(std::make_pair(uniqKey, ptr));
<a name="l02113"></a>02113     }
<a name="l02114"></a>02114 
<a name="l02116"></a>02116     <span class="keyword">inline</span> <span class="keywordtype">void</span> unregister(<span class="keyword">const</span> T_Key&amp; uniqKey)
<a name="l02117"></a>02117     {
<a name="l02118"></a>02118         T_Ptr* existing = <span class="keyword">get</span>(uniqKey);
<a name="l02119"></a>02119         <span class="keywordflow">if</span> (existing != <span class="keyword">nullptr</span>) {
<a name="l02120"></a>02120             base::utils::safeDelete(existing);
<a name="l02121"></a>02121             this-&gt;list().erase(uniqKey);
<a name="l02122"></a>02122         }
<a name="l02123"></a>02123     }
<a name="l02124"></a>02124 
<a name="l02126"></a>02126     <span class="keyword">inline</span> T_Ptr* <span class="keyword">get</span>(<span class="keyword">const</span> T_Key&amp; uniqKey)
<a name="l02127"></a>02127     {
<a name="l02128"></a>02128         iterator it = this-&gt;list().find(uniqKey);
<a name="l02129"></a>02129         <span class="keywordflow">return</span> it == this-&gt;list().end()
<a name="l02130"></a>02130                ? <span class="keyword">nullptr</span>
<a name="l02131"></a>02131                : it-&gt;second;
<a name="l02132"></a>02132     }
<a name="l02133"></a>02133 
<a name="l02134"></a>02134 <span class="keyword">private</span>:
<a name="l02135"></a>02135     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> deepCopy(<span class="keyword">const</span> AbstractRegistry&lt;T_Ptr, std::map&lt;T_Key, T_Ptr*&gt;&gt;&amp; sr) ELPP_FINAL {
<a name="l02136"></a>02136         <span class="keywordflow">for</span> (const_iterator it = sr.cbegin(); it != sr.cend(); ++it)
<a name="l02137"></a>02137         {
<a name="l02138"></a>02138             registerNew(it-&gt;first, <span class="keyword">new</span> T_Ptr(*it-&gt;second));
<a name="l02139"></a>02139         }
<a name="l02140"></a>02140     }
<a name="l02141"></a>02141 };
<a name="l02142"></a>02142 
<a name="l02147"></a>02147 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_Ptr, <span class="keyword">typename</span> Pred&gt;
<a name="l02148"></a>02148 <span class="keyword">class </span>RegistryWithPred : <span class="keyword">public</span> AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr*&gt;&gt;
<a name="l02149"></a>02149 {
<a name="l02150"></a>02150 <span class="keyword">public</span>:
<a name="l02151"></a>02151     <span class="keyword">typedef</span> <span class="keyword">typename</span> RegistryWithPred&lt;T_Ptr, Pred&gt;::iterator iterator;
<a name="l02152"></a>02152     <span class="keyword">typedef</span> <span class="keyword">typename</span> RegistryWithPred&lt;T_Ptr, Pred&gt;::const_iterator const_iterator;
<a name="l02153"></a>02153 
<a name="l02154"></a>02154     RegistryWithPred(<span class="keywordtype">void</span>)
<a name="l02155"></a>02155     {
<a name="l02156"></a>02156     }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158     <span class="keyword">virtual</span> ~RegistryWithPred(<span class="keywordtype">void</span>)
<a name="l02159"></a>02159     {
<a name="l02160"></a>02160         unregisterAll();
<a name="l02161"></a>02161     }
<a name="l02162"></a>02162 
<a name="l02164"></a>02164     RegistryWithPred(<span class="keyword">const</span> RegistryWithPred&amp; sr) : AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr * &gt;&gt;()
<a name="l02165"></a>02165     {
<a name="l02166"></a>02166         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;sr) {
<a name="l02167"></a>02167             <span class="keywordflow">return</span>;
<a name="l02168"></a>02168         }
<a name="l02169"></a>02169         this-&gt;reinitDeepCopy(sr);
<a name="l02170"></a>02170     }
<a name="l02171"></a>02171 
<a name="l02175"></a>02175     RegistryWithPred&amp; operator=(<span class="keyword">const</span> RegistryWithPred&amp; sr)
<a name="l02176"></a>02176     {
<a name="l02177"></a>02177         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;sr) {
<a name="l02178"></a>02178             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02179"></a>02179         }
<a name="l02180"></a>02180         this-&gt;reinitDeepCopy(sr);
<a name="l02181"></a>02181         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02182"></a>02182     }
<a name="l02183"></a>02183 
<a name="l02184"></a>02184     <span class="keyword">friend</span> <span class="keyword">inline</span> base::type::ostream_t&amp; operator&lt;&lt;(base::type::ostream_t&amp; os, <span class="keyword">const</span> RegistryWithPred&amp; sr)
<a name="l02185"></a>02185     {
<a name="l02186"></a>02186         <span class="keywordflow">for</span> (const_iterator it = sr.list().begin(); it != sr.list().end(); ++it) {
<a name="l02187"></a>02187             os &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;    &quot;</span>) &lt;&lt; **it &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02188"></a>02188         }
<a name="l02189"></a>02189         <span class="keywordflow">return</span> os;
<a name="l02190"></a>02190     }
<a name="l02191"></a>02191 
<a name="l02192"></a>02192 <span class="keyword">protected</span>:
<a name="l02193"></a>02193     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> unregisterAll(<span class="keywordtype">void</span>) ELPP_FINAL {
<a name="l02194"></a>02194         <span class="keywordflow">if</span> (!this-&gt;empty())
<a name="l02195"></a>02195         {
<a name="l02196"></a>02196             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp; curr : this-&gt;list()) {
<a name="l02197"></a>02197                 base::utils::safeDelete(curr);
<a name="l02198"></a>02198             }
<a name="l02199"></a>02199             this-&gt;list().clear();
<a name="l02200"></a>02200         }
<a name="l02201"></a>02201     }
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     <span class="keyword">virtual</span> <span class="keywordtype">void</span> unregister(T_Ptr*&amp; ptr) ELPP_FINAL {
<a name="l02204"></a>02204         <span class="keywordflow">if</span> (ptr)
<a name="l02205"></a>02205         {
<a name="l02206"></a>02206             iterator iter = this-&gt;begin();
<a name="l02207"></a>02207             <span class="keywordflow">for</span> (; iter != this-&gt;end(); ++iter) {
<a name="l02208"></a>02208                 <span class="keywordflow">if</span> (ptr == *iter) {
<a name="l02209"></a>02209                     <span class="keywordflow">break</span>;
<a name="l02210"></a>02210                 }
<a name="l02211"></a>02211             }
<a name="l02212"></a>02212             <span class="keywordflow">if</span> (iter != this-&gt;end() &amp;&amp; *iter != <span class="keyword">nullptr</span>) {
<a name="l02213"></a>02213                 this-&gt;list().erase(iter);
<a name="l02214"></a>02214                 base::utils::safeDelete(*iter);
<a name="l02215"></a>02215             }
<a name="l02216"></a>02216         }
<a name="l02217"></a>02217     }
<a name="l02218"></a>02218 
<a name="l02219"></a>02219     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> registerNew(T_Ptr* ptr) ELPP_FINAL {
<a name="l02220"></a>02220         this-&gt;list().push_back(ptr);
<a name="l02221"></a>02221     }
<a name="l02222"></a>02222 
<a name="l02225"></a>02225     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T2&gt;
<a name="l02226"></a>02226     <span class="keyword">inline</span> T_Ptr* <span class="keyword">get</span>(<span class="keyword">const</span> T&amp; arg1, <span class="keyword">const</span> T2 arg2)
<a name="l02227"></a>02227     {
<a name="l02228"></a>02228         iterator iter = std::find_if(this-&gt;list().begin(), this-&gt;list().end(), Pred(arg1, arg2));
<a name="l02229"></a>02229         <span class="keywordflow">if</span> (iter != this-&gt;list().end() &amp;&amp; *iter != <span class="keyword">nullptr</span>) {
<a name="l02230"></a>02230             <span class="keywordflow">return</span> *iter;
<a name="l02231"></a>02231         }
<a name="l02232"></a>02232         <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l02233"></a>02233     }
<a name="l02234"></a>02234 
<a name="l02235"></a>02235 <span class="keyword">private</span>:
<a name="l02236"></a>02236     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> deepCopy(<span class="keyword">const</span> AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr*&gt;&gt;&amp; sr)
<a name="l02237"></a>02237     {
<a name="l02238"></a>02238         <span class="keywordflow">for</span> (const_iterator it = sr.list().begin(); it != sr.list().end(); ++it) {
<a name="l02239"></a>02239             registerNew(<span class="keyword">new</span> T_Ptr(**it));
<a name="l02240"></a>02240         }
<a name="l02241"></a>02241     }
<a name="l02242"></a>02242 };
<a name="l02243"></a>02243 
<a name="l02244"></a>02244 }  <span class="comment">// namespace utils</span>
<a name="l02245"></a>02245 } <span class="comment">// namespace base</span>
<a name="l02249"></a>02249 <span class="comment"></span><span class="keyword">class </span>Loggable
<a name="l02250"></a>02250 {
<a name="l02251"></a>02251 <span class="keyword">public</span>:
<a name="l02252"></a>02252     <span class="keyword">virtual</span> ~Loggable(<span class="keywordtype">void</span>) {}
<a name="l02253"></a>02253     <span class="keyword">virtual</span> <span class="keywordtype">void</span> log(el::base::type::ostream_t&amp;) <span class="keyword">const</span> = 0;
<a name="l02254"></a>02254 <span class="keyword">private</span>:
<a name="l02255"></a>02255     <span class="keyword">friend</span> <span class="keyword">inline</span> el::base::type::ostream_t&amp; operator&lt;&lt;(el::base::type::ostream_t&amp; os, <span class="keyword">const</span> Loggable&amp; loggable)
<a name="l02256"></a>02256     {
<a name="l02257"></a>02257         loggable.log(os);
<a name="l02258"></a>02258         <span class="keywordflow">return</span> os;
<a name="l02259"></a>02259     }
<a name="l02260"></a>02260 };
<a name="l02261"></a>02261 <span class="keyword">namespace </span>base {
<a name="l02263"></a>02263 <span class="keyword">class </span>LogFormat : <span class="keyword">public</span> Loggable
<a name="l02264"></a>02264 {
<a name="l02265"></a>02265 <span class="keyword">public</span>:
<a name="l02266"></a>02266     LogFormat(<span class="keywordtype">void</span>) :
<a name="l02267"></a>02267         m_level(Level::Unknown),
<a name="l02268"></a>02268         m_userFormat(base::type::string_t()),
<a name="l02269"></a>02269         m_format(base::type::string_t()),
<a name="l02270"></a>02270         m_dateTimeFormat(std::string()),
<a name="l02271"></a>02271         m_flags(0x0)
<a name="l02272"></a>02272     {
<a name="l02273"></a>02273     }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275     LogFormat(Level level, <span class="keyword">const</span> base::type::string_t&amp; format)
<a name="l02276"></a>02276         : m_level(level), m_userFormat(format)
<a name="l02277"></a>02277     {
<a name="l02278"></a>02278         parseFromFormat(m_userFormat);
<a name="l02279"></a>02279     }
<a name="l02280"></a>02280 
<a name="l02281"></a>02281     LogFormat(<span class="keyword">const</span> LogFormat&amp; logFormat)
<a name="l02282"></a>02282     {
<a name="l02283"></a>02283         m_level = logFormat.m_level;
<a name="l02284"></a>02284         m_userFormat = logFormat.m_userFormat;
<a name="l02285"></a>02285         m_format = logFormat.m_format;
<a name="l02286"></a>02286         m_dateTimeFormat = logFormat.m_dateTimeFormat;
<a name="l02287"></a>02287         m_flags = logFormat.m_flags;
<a name="l02288"></a>02288     }
<a name="l02289"></a>02289 
<a name="l02290"></a>02290     LogFormat(LogFormat&amp;&amp; logFormat)
<a name="l02291"></a>02291     {
<a name="l02292"></a>02292         m_level = std::move(logFormat.m_level);
<a name="l02293"></a>02293         m_userFormat = std::move(logFormat.m_userFormat);
<a name="l02294"></a>02294         m_format = std::move(logFormat.m_format);
<a name="l02295"></a>02295         m_dateTimeFormat = std::move(logFormat.m_dateTimeFormat);
<a name="l02296"></a>02296         m_flags = std::move(logFormat.m_flags);
<a name="l02297"></a>02297     }
<a name="l02298"></a>02298 
<a name="l02299"></a>02299     LogFormat&amp; operator=(<span class="keyword">const</span> LogFormat&amp; logFormat)
<a name="l02300"></a>02300     {
<a name="l02301"></a>02301         m_level = logFormat.m_level;
<a name="l02302"></a>02302         m_userFormat = logFormat.m_userFormat;
<a name="l02303"></a>02303         m_dateTimeFormat = logFormat.m_dateTimeFormat;
<a name="l02304"></a>02304         m_flags = logFormat.m_flags;
<a name="l02305"></a>02305         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02306"></a>02306     }
<a name="l02307"></a>02307 
<a name="l02308"></a>02308     <span class="keyword">virtual</span> ~LogFormat(<span class="keywordtype">void</span>)
<a name="l02309"></a>02309     {
<a name="l02310"></a>02310     }
<a name="l02311"></a>02311 
<a name="l02312"></a>02312     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> LogFormat&amp; other)
<a name="l02313"></a>02313     {
<a name="l02314"></a>02314         <span class="keywordflow">return</span> m_level == other.m_level &amp;&amp; m_userFormat == other.m_userFormat &amp;&amp; m_format == other.m_format &amp;&amp;
<a name="l02315"></a>02315                m_dateTimeFormat == other.m_dateTimeFormat &amp;&amp; m_flags == other.m_flags;
<a name="l02316"></a>02316     }
<a name="l02317"></a>02317 
<a name="l02320"></a>02320     <span class="keywordtype">void</span> parseFromFormat(<span class="keyword">const</span> base::type::string_t&amp; userFormat)
<a name="l02321"></a>02321     {
<a name="l02322"></a>02322         <span class="comment">// We make copy because we will be changing the format</span>
<a name="l02323"></a>02323         <span class="comment">// i.e, removing user provided date format from original format</span>
<a name="l02324"></a>02324         <span class="comment">// and then storing it.</span>
<a name="l02325"></a>02325         base::type::string_t formatCopy = userFormat;
<a name="l02326"></a>02326         m_flags = 0x0;
<a name="l02327"></a>02327         <span class="keyword">auto</span> conditionalAddFlag = [&amp;](<span class="keyword">const</span> base::type::char_t* specifier, base::FormatFlags flag) {
<a name="l02328"></a>02328             std::size_t foundAt = base::type::string_t::npos;
<a name="l02329"></a>02329             <span class="keywordflow">while</span> ((foundAt = formatCopy.find(specifier, foundAt + 1)) != base::type::string_t::npos) {
<a name="l02330"></a>02330                 <span class="keywordflow">if</span> (foundAt &gt; 0 &amp;&amp; formatCopy[foundAt - 1] == base::consts::kFormatSpecifierChar) {
<a name="l02331"></a>02331                     <span class="keywordflow">if</span> (hasFlag(flag)) {
<a name="l02332"></a>02332                         <span class="comment">// If we already have flag we remove the escape chars so that &apos;%%&apos; is turned to &apos;%&apos;</span>
<a name="l02333"></a>02333                         <span class="comment">// even after specifier resolution - this is because we only replaceFirst specifier</span>
<a name="l02334"></a>02334                         formatCopy.erase(foundAt &gt; 0 ? foundAt - 1 : 0, 1);
<a name="l02335"></a>02335                         ++foundAt;
<a name="l02336"></a>02336                     }
<a name="l02337"></a>02337                 } <span class="keywordflow">else</span> {
<a name="l02338"></a>02338                     <span class="keywordflow">if</span> (!hasFlag(flag)) addFlag(flag);
<a name="l02339"></a>02339                 }
<a name="l02340"></a>02340             }
<a name="l02341"></a>02341         };
<a name="l02342"></a>02342         conditionalAddFlag(base::consts::kAppNameFormatSpecifier, base::FormatFlags::AppName);
<a name="l02343"></a>02343         conditionalAddFlag(base::consts::kSeverityLevelFormatSpecifier, base::FormatFlags::Level);
<a name="l02344"></a>02344         conditionalAddFlag(base::consts::kSeverityLevelShortFormatSpecifier, base::FormatFlags::LevelShort);
<a name="l02345"></a>02345         conditionalAddFlag(base::consts::kLoggerIdFormatSpecifier, base::FormatFlags::LoggerId);
<a name="l02346"></a>02346         conditionalAddFlag(base::consts::kThreadIdFormatSpecifier, base::FormatFlags::ThreadId);
<a name="l02347"></a>02347         conditionalAddFlag(base::consts::kLogFileFormatSpecifier, base::FormatFlags::File);
<a name="l02348"></a>02348         conditionalAddFlag(base::consts::kLogFileBaseFormatSpecifier, base::FormatFlags::FileBase);
<a name="l02349"></a>02349         conditionalAddFlag(base::consts::kLogLineFormatSpecifier, base::FormatFlags::Line);
<a name="l02350"></a>02350         conditionalAddFlag(base::consts::kLogLocationFormatSpecifier, base::FormatFlags::Location);
<a name="l02351"></a>02351         conditionalAddFlag(base::consts::kLogFunctionFormatSpecifier, base::FormatFlags::Function);
<a name="l02352"></a>02352         conditionalAddFlag(base::consts::kCurrentUserFormatSpecifier, base::FormatFlags::User);
<a name="l02353"></a>02353         conditionalAddFlag(base::consts::kCurrentHostFormatSpecifier, base::FormatFlags::Host);
<a name="l02354"></a>02354         conditionalAddFlag(base::consts::kMessageFormatSpecifier, base::FormatFlags::LogMessage);
<a name="l02355"></a>02355         conditionalAddFlag(base::consts::kVerboseLevelFormatSpecifier, base::FormatFlags::VerboseLevel);
<a name="l02356"></a>02356         <span class="comment">// For date/time we need to extract user&apos;s date format first</span>
<a name="l02357"></a>02357         std::size_t dateIndex = std::string::npos;
<a name="l02358"></a>02358         <span class="keywordflow">if</span> ((dateIndex = formatCopy.find(base::consts::kDateTimeFormatSpecifier)) != std::string::npos) {
<a name="l02359"></a>02359             <span class="keywordflow">while</span> (dateIndex &gt; 0 &amp;&amp; formatCopy[dateIndex - 1] == base::consts::kFormatSpecifierChar) {
<a name="l02360"></a>02360                 dateIndex = formatCopy.find(base::consts::kDateTimeFormatSpecifier, dateIndex + 1);
<a name="l02361"></a>02361             }
<a name="l02362"></a>02362             <span class="keywordflow">if</span> (dateIndex != std::string::npos) {
<a name="l02363"></a>02363                 addFlag(base::FormatFlags::DateTime);
<a name="l02364"></a>02364                 updateDateFormat(dateIndex, formatCopy);
<a name="l02365"></a>02365             }
<a name="l02366"></a>02366         }
<a name="l02367"></a>02367         m_format = formatCopy;
<a name="l02368"></a>02368         updateFormatSpec();
<a name="l02369"></a>02369     }
<a name="l02370"></a>02370 
<a name="l02371"></a>02371     <span class="keyword">inline</span> Level level(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02372"></a>02372 <span class="keyword">    </span>{
<a name="l02373"></a>02373         <span class="keywordflow">return</span> m_level;
<a name="l02374"></a>02374     }
<a name="l02375"></a>02375 
<a name="l02376"></a>02376     <span class="keyword">inline</span> <span class="keyword">const</span> base::type::string_t&amp; userFormat(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02377"></a>02377 <span class="keyword">    </span>{
<a name="l02378"></a>02378         <span class="keywordflow">return</span> m_userFormat;
<a name="l02379"></a>02379     }
<a name="l02380"></a>02380 
<a name="l02381"></a>02381     <span class="keyword">inline</span> <span class="keyword">const</span> base::type::string_t&amp; format(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02382"></a>02382 <span class="keyword">    </span>{
<a name="l02383"></a>02383         <span class="keywordflow">return</span> m_format;
<a name="l02384"></a>02384     }
<a name="l02385"></a>02385 
<a name="l02386"></a>02386     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; dateTimeFormat(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02387"></a>02387 <span class="keyword">    </span>{
<a name="l02388"></a>02388         <span class="keywordflow">return</span> m_dateTimeFormat;
<a name="l02389"></a>02389     }
<a name="l02390"></a>02390 
<a name="l02391"></a>02391     <span class="keyword">inline</span> base::type::EnumType flags(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02392"></a>02392 <span class="keyword">    </span>{
<a name="l02393"></a>02393         <span class="keywordflow">return</span> m_flags;
<a name="l02394"></a>02394     }
<a name="l02395"></a>02395 
<a name="l02396"></a>02396     <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasFlag(base::FormatFlags flag)<span class="keyword"> const</span>
<a name="l02397"></a>02397 <span class="keyword">    </span>{
<a name="l02398"></a>02398         <span class="keywordflow">return</span> base::utils::hasFlag(flag, m_flags);
<a name="l02399"></a>02399     }
<a name="l02400"></a>02400 
<a name="l02401"></a>02401     <span class="keyword">virtual</span> <span class="keywordtype">void</span> log(el::base::type::ostream_t&amp; os)<span class="keyword"> const</span>
<a name="l02402"></a>02402 <span class="keyword">    </span>{
<a name="l02403"></a>02403         os &lt;&lt; m_format;
<a name="l02404"></a>02404     }
<a name="l02405"></a>02405 
<a name="l02406"></a>02406 <span class="keyword">protected</span>:
<a name="l02410"></a>02410     <span class="keyword">virtual</span> <span class="keywordtype">void</span> updateDateFormat(std::size_t index, base::type::string_t&amp; currFormat) ELPP_FINAL {
<a name="l02411"></a>02411         <span class="keywordflow">if</span> (hasFlag(base::FormatFlags::DateTime))
<a name="l02412"></a>02412         {
<a name="l02413"></a>02413             index += ELPP_STRLEN(base::consts::kDateTimeFormatSpecifier);
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415         <span class="keyword">const</span> base::type::char_t* ptr = currFormat.c_str() + index;
<a name="l02416"></a>02416         <span class="keywordflow">if</span> ((currFormat.size() &gt; index) &amp;&amp; (ptr[0] == <span class="charliteral">&apos;{&apos;</span>))
<a name="l02417"></a>02417         {
<a name="l02418"></a>02418             <span class="comment">// User has provided format for date/time</span>
<a name="l02419"></a>02419             ++ptr;
<a name="l02420"></a>02420             <span class="keywordtype">int</span> count = 1;  <span class="comment">// Start by 1 in order to remove starting brace</span>
<a name="l02421"></a>02421             std::stringstream ss;
<a name="l02422"></a>02422             <span class="keywordflow">for</span> (; *ptr; ++ptr, ++count) {
<a name="l02423"></a>02423                 <span class="keywordflow">if</span> (*ptr == <span class="charliteral">&apos;}&apos;</span>) {
<a name="l02424"></a>02424                     ++count;  <span class="comment">// In order to remove ending brace</span>
<a name="l02425"></a>02425                     <span class="keywordflow">break</span>;
<a name="l02426"></a>02426                 }
<a name="l02427"></a>02427                 ss &lt;&lt; *ptr;
<a name="l02428"></a>02428             }
<a name="l02429"></a>02429             currFormat.erase(index, count);
<a name="l02430"></a>02430             m_dateTimeFormat = ss.str();
<a name="l02431"></a>02431         } <span class="keywordflow">else</span> {
<a name="l02432"></a>02432             <span class="comment">// No format provided, use default</span>
<a name="l02433"></a>02433             <span class="keywordflow">if</span> (hasFlag(base::FormatFlags::DateTime))
<a name="l02434"></a>02434             {
<a name="l02435"></a>02435                 m_dateTimeFormat = std::string(base::consts::kDefaultDateTimeFormat);
<a name="l02436"></a>02436             }
<a name="l02437"></a>02437         }
<a name="l02438"></a>02438     }
<a name="l02439"></a>02439 
<a name="l02441"></a>02441     <span class="keyword">virtual</span> <span class="keywordtype">void</span> updateFormatSpec(<span class="keywordtype">void</span>) ELPP_FINAL {
<a name="l02442"></a>02442         <span class="comment">// Do not use switch over strongly typed enums because Intel C++ compilers dont support them yet.</span>
<a name="l02443"></a>02443         <span class="keywordflow">if</span> (m_level == Level::Debug)
<a name="l02444"></a>02444         {
<a name="l02445"></a>02445             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02446"></a>02446             base::consts::kDebugLevelLogValue);
<a name="l02447"></a>02447             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02448"></a>02448             base::consts::kDebugLevelShortLogValue);
<a name="l02449"></a>02449         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_level == Level::Info)
<a name="l02450"></a>02450         {
<a name="l02451"></a>02451             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02452"></a>02452             base::consts::kInfoLevelLogValue);
<a name="l02453"></a>02453             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02454"></a>02454             base::consts::kInfoLevelShortLogValue);
<a name="l02455"></a>02455         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_level == Level::Warning)
<a name="l02456"></a>02456         {
<a name="l02457"></a>02457             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02458"></a>02458             base::consts::kWarningLevelLogValue);
<a name="l02459"></a>02459             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02460"></a>02460             base::consts::kWarningLevelShortLogValue);
<a name="l02461"></a>02461         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_level == Level::Error)
<a name="l02462"></a>02462         {
<a name="l02463"></a>02463             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02464"></a>02464             base::consts::kErrorLevelLogValue);
<a name="l02465"></a>02465             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02466"></a>02466             base::consts::kErrorLevelShortLogValue);
<a name="l02467"></a>02467         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_level == Level::Fatal)
<a name="l02468"></a>02468         {
<a name="l02469"></a>02469             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02470"></a>02470             base::consts::kFatalLevelLogValue);
<a name="l02471"></a>02471             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02472"></a>02472             base::consts::kFatalLevelShortLogValue);
<a name="l02473"></a>02473         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_level == Level::Verbose)
<a name="l02474"></a>02474         {
<a name="l02475"></a>02475             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02476"></a>02476             base::consts::kVerboseLevelLogValue);
<a name="l02477"></a>02477             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02478"></a>02478             base::consts::kVerboseLevelShortLogValue);
<a name="l02479"></a>02479         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_level == Level::Trace)
<a name="l02480"></a>02480         {
<a name="l02481"></a>02481             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<a name="l02482"></a>02482             base::consts::kTraceLevelLogValue);
<a name="l02483"></a>02483             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<a name="l02484"></a>02484             base::consts::kTraceLevelShortLogValue);
<a name="l02485"></a>02485         }
<a name="l02486"></a>02486         <span class="keywordflow">if</span> (hasFlag(base::FormatFlags::User))
<a name="l02487"></a>02487         {
<a name="l02488"></a>02488             std::string s = base::utils::s_currentUser;
<a name="l02489"></a>02489             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kCurrentUserFormatSpecifier,
<a name="l02490"></a>02490             base::utils::s_currentUser);
<a name="l02491"></a>02491         }
<a name="l02492"></a>02492         <span class="keywordflow">if</span> (hasFlag(base::FormatFlags::Host))
<a name="l02493"></a>02493         {
<a name="l02494"></a>02494             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kCurrentHostFormatSpecifier,
<a name="l02495"></a>02495             base::utils::s_currentHost);
<a name="l02496"></a>02496         }
<a name="l02497"></a>02497         <span class="comment">// Ignore Level::Global and Level::Unknown</span>
<a name="l02498"></a>02498     }
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     <span class="keyword">inline</span> <span class="keywordtype">void</span> addFlag(base::FormatFlags flag)
<a name="l02501"></a>02501     {
<a name="l02502"></a>02502         base::utils::addFlag(flag, &amp;m_flags);
<a name="l02503"></a>02503     }
<a name="l02504"></a>02504 
<a name="l02505"></a>02505 <span class="keyword">private</span>:
<a name="l02506"></a>02506     Level m_level;
<a name="l02507"></a>02507     base::type::string_t m_userFormat;
<a name="l02508"></a>02508     base::type::string_t m_format;
<a name="l02509"></a>02509     std::string m_dateTimeFormat;
<a name="l02510"></a>02510     base::type::EnumType m_flags;
<a name="l02511"></a>02511     <span class="keyword">friend</span> <span class="keyword">class </span>el::Logger;  <span class="comment">// To resolve loggerId format specifier easily</span>
<a name="l02512"></a>02512 };
<a name="l02513"></a>02513 }  <span class="comment">// namespace base</span>
<a name="l02515"></a>02515 <span class="comment"></span><span class="keyword">typedef</span> std::function&lt;const char* (void)&gt; FormatSpecifierValueResolver;
<a name="l02519"></a>02519 <span class="keyword">class </span>CustomFormatSpecifier
<a name="l02520"></a>02520 {
<a name="l02521"></a>02521 <span class="keyword">public</span>:
<a name="l02522"></a>02522     CustomFormatSpecifier(<span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier, <span class="keyword">const</span> FormatSpecifierValueResolver&amp; resolver) :
<a name="l02523"></a>02523         m_formatSpecifier(formatSpecifier), m_resolver(resolver) {}
<a name="l02524"></a>02524     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_formatSpecifier; }
<a name="l02525"></a>02525     <span class="keyword">inline</span> <span class="keyword">const</span> FormatSpecifierValueResolver&amp; resolver(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_resolver; }
<a name="l02526"></a>02526     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier)
<a name="l02527"></a>02527     {
<a name="l02528"></a>02528         <span class="keywordflow">return</span> strcmp(m_formatSpecifier, formatSpecifier) == 0;
<a name="l02529"></a>02529     }
<a name="l02530"></a>02530 
<a name="l02531"></a>02531 <span class="keyword">private</span>:
<a name="l02532"></a>02532     <span class="keyword">const</span> <span class="keywordtype">char</span>* m_formatSpecifier;
<a name="l02533"></a>02533     FormatSpecifierValueResolver m_resolver;
<a name="l02534"></a>02534 };
<a name="l02544"></a>02544 <span class="keyword">class </span>Configuration : <span class="keyword">public</span> Loggable
<a name="l02545"></a>02545 {
<a name="l02546"></a>02546 <span class="keyword">public</span>:
<a name="l02547"></a>02547     Configuration(<span class="keyword">const</span> Configuration&amp; c) :
<a name="l02548"></a>02548         m_level(c.m_level),
<a name="l02549"></a>02549         m_configurationType(c.m_configurationType),
<a name="l02550"></a>02550         m_value(c.m_value)
<a name="l02551"></a>02551     {
<a name="l02552"></a>02552     }
<a name="l02553"></a>02553 
<a name="l02554"></a>02554     Configuration&amp; operator=(<span class="keyword">const</span> Configuration&amp; c)
<a name="l02555"></a>02555     {
<a name="l02556"></a>02556         m_level = c.m_level;
<a name="l02557"></a>02557         m_configurationType = c.m_configurationType;
<a name="l02558"></a>02558         m_value = c.m_value;
<a name="l02559"></a>02559         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02560"></a>02560     }
<a name="l02561"></a>02561 
<a name="l02562"></a>02562     <span class="keyword">virtual</span> ~Configuration(<span class="keywordtype">void</span>)
<a name="l02563"></a>02563     {
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 
<a name="l02567"></a>02567     Configuration(Level level, ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value) :
<a name="l02568"></a>02568         m_level(level),
<a name="l02569"></a>02569         m_configurationType(configurationType),
<a name="l02570"></a>02570         m_value(value)
<a name="l02571"></a>02571     {
<a name="l02572"></a>02572     }
<a name="l02573"></a>02573 
<a name="l02575"></a>02575     <span class="keyword">inline</span> Level level(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02576"></a>02576 <span class="keyword">    </span>{
<a name="l02577"></a>02577         <span class="keywordflow">return</span> m_level;
<a name="l02578"></a>02578     }
<a name="l02579"></a>02579 
<a name="l02581"></a>02581     <span class="keyword">inline</span> ConfigurationType configurationType(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02582"></a>02582 <span class="keyword">    </span>{
<a name="l02583"></a>02583         <span class="keywordflow">return</span> m_configurationType;
<a name="l02584"></a>02584     }
<a name="l02585"></a>02585 
<a name="l02587"></a>02587     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; value(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02588"></a>02588 <span class="keyword">    </span>{
<a name="l02589"></a>02589         <span class="keywordflow">return</span> m_value;
<a name="l02590"></a>02590     }
<a name="l02591"></a>02591 
<a name="l02595"></a>02595     <span class="keyword">inline</span> <span class="keywordtype">void</span> setValue(<span class="keyword">const</span> std::string&amp; value)
<a name="l02596"></a>02596     {
<a name="l02597"></a>02597         m_value = value;
<a name="l02598"></a>02598     }
<a name="l02599"></a>02599 
<a name="l02600"></a>02600     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> log(el::base::type::ostream_t&amp; os)<span class="keyword"> const</span>
<a name="l02601"></a>02601 <span class="keyword">    </span>{
<a name="l02602"></a>02602         os &lt;&lt; LevelHelper::convertToString(m_level)
<a name="l02603"></a>02603            &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot; &quot;</span>) &lt;&lt; ConfigurationTypeHelper::convertToString(m_configurationType)
<a name="l02604"></a>02604            &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot; = &quot;</span>) &lt;&lt; m_value.c_str();
<a name="l02605"></a>02605     }
<a name="l02606"></a>02606 
<a name="l02608"></a>02608     <span class="keyword">class </span>Predicate
<a name="l02609"></a>02609     {
<a name="l02610"></a>02610     <span class="keyword">public</span>:
<a name="l02611"></a>02611         Predicate(Level level, ConfigurationType configurationType) :
<a name="l02612"></a>02612             m_level(level),
<a name="l02613"></a>02613             m_configurationType(configurationType)
<a name="l02614"></a>02614         {
<a name="l02615"></a>02615         }
<a name="l02616"></a>02616 
<a name="l02617"></a>02617         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Configuration* conf)<span class="keyword"> const</span>
<a name="l02618"></a>02618 <span class="keyword">        </span>{
<a name="l02619"></a>02619             <span class="keywordflow">return</span> ((conf != <span class="keyword">nullptr</span>) &amp;&amp; (conf-&gt;level() == m_level) &amp;&amp; (conf-&gt;configurationType() == m_configurationType));
<a name="l02620"></a>02620         }
<a name="l02621"></a>02621 
<a name="l02622"></a>02622     <span class="keyword">private</span>:
<a name="l02623"></a>02623         Level m_level;
<a name="l02624"></a>02624         ConfigurationType m_configurationType;
<a name="l02625"></a>02625     };
<a name="l02626"></a>02626 
<a name="l02627"></a>02627 <span class="keyword">private</span>:
<a name="l02628"></a>02628     Level m_level;
<a name="l02629"></a>02629     ConfigurationType m_configurationType;
<a name="l02630"></a>02630     std::string m_value;
<a name="l02631"></a>02631 };
<a name="l02632"></a>02632 
<a name="l02636"></a>02636 <span class="keyword">class </span>Configurations : <span class="keyword">public</span> base::utils::RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;
<a name="l02637"></a>02637 {
<a name="l02638"></a>02638 <span class="keyword">public</span>:
<a name="l02640"></a>02640     Configurations(<span class="keywordtype">void</span>) :
<a name="l02641"></a>02641         m_configurationFile(std::string()),
<a name="l02642"></a>02642         m_isFromFile(false)
<a name="l02643"></a>02643     {
<a name="l02644"></a>02644     }
<a name="l02645"></a>02645 
<a name="l02652"></a>02652     Configurations(<span class="keyword">const</span> std::string&amp; configurationFile, <span class="keywordtype">bool</span> useDefaultsForRemaining = <span class="keyword">true</span>, Configurations* base = <span class="keyword">nullptr</span>) :
<a name="l02653"></a>02653         m_configurationFile(configurationFile),
<a name="l02654"></a>02654         m_isFromFile(false)
<a name="l02655"></a>02655     {
<a name="l02656"></a>02656         parseFromFile(configurationFile, base);
<a name="l02657"></a>02657         <span class="keywordflow">if</span> (useDefaultsForRemaining) {
<a name="l02658"></a>02658             setRemainingToDefault();
<a name="l02659"></a>02659         }
<a name="l02660"></a>02660     }
<a name="l02661"></a>02661 
<a name="l02662"></a>02662     <span class="keyword">virtual</span> ~Configurations(<span class="keywordtype">void</span>)
<a name="l02663"></a>02663     {
<a name="l02664"></a>02664     }
<a name="l02665"></a>02665 
<a name="l02672"></a>02672     <span class="keyword">inline</span> <span class="keywordtype">bool</span> parseFromFile(<span class="keyword">const</span> std::string&amp; configurationFile, Configurations* base = <span class="keyword">nullptr</span>)
<a name="l02673"></a>02673     {
<a name="l02674"></a>02674         <span class="comment">// We initial assertion with true because if we have assertion diabled, we want to pass this</span>
<a name="l02675"></a>02675         <span class="comment">// check and if assertion is enabled we will have values re-assigned any way.</span>
<a name="l02676"></a>02676         <span class="keywordtype">bool</span> assertionPassed = <span class="keyword">true</span>;
<a name="l02677"></a>02677         ELPP_ASSERT((assertionPassed = base::utils::File::pathExists(configurationFile.c_str(), <span class="keyword">true</span>)),
<a name="l02678"></a>02678                     <span class="stringliteral">&quot;Configuration file [&quot;</span> &lt;&lt; configurationFile &lt;&lt; <span class="stringliteral">&quot;] does not exist!&quot;</span>);
<a name="l02679"></a>02679         <span class="keywordflow">if</span> (!assertionPassed) {
<a name="l02680"></a>02680             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02681"></a>02681         }
<a name="l02682"></a>02682         <span class="keywordtype">bool</span> success = Parser::parseFromFile(configurationFile, <span class="keyword">this</span>, base);
<a name="l02683"></a>02683         m_isFromFile = success;
<a name="l02684"></a>02684         <span class="keywordflow">return</span> success;
<a name="l02685"></a>02685     }
<a name="l02686"></a>02686 
<a name="l02695"></a>02695     <span class="keyword">inline</span> <span class="keywordtype">bool</span> parseFromText(<span class="keyword">const</span> std::string&amp; configurationsString, Configurations* base = <span class="keyword">nullptr</span>)
<a name="l02696"></a>02696     {
<a name="l02697"></a>02697         <span class="keywordtype">bool</span> success = Parser::parseFromText(configurationsString, <span class="keyword">this</span>, base);
<a name="l02698"></a>02698         <span class="keywordflow">if</span> (success) {
<a name="l02699"></a>02699             m_isFromFile = <span class="keyword">false</span>;
<a name="l02700"></a>02700         }
<a name="l02701"></a>02701         <span class="keywordflow">return</span> success;
<a name="l02702"></a>02702     }
<a name="l02703"></a>02703 
<a name="l02706"></a>02706     <span class="keyword">inline</span> <span class="keywordtype">void</span> setFromBase(Configurations* base)
<a name="l02707"></a>02707     {
<a name="l02708"></a>02708         <span class="keywordflow">if</span> (base == <span class="keyword">nullptr</span> || base == <span class="keyword">this</span>) {
<a name="l02709"></a>02709             <span class="keywordflow">return</span>;
<a name="l02710"></a>02710         }
<a name="l02711"></a>02711         base::threading::ScopedLock scopedLock(base-&gt;lock());
<a name="l02712"></a>02712         <span class="keywordflow">for</span> (Configuration*&amp; conf : base-&gt;list()) {
<a name="l02713"></a>02713             <span class="keyword">set</span>(conf);
<a name="l02714"></a>02714         }
<a name="l02715"></a>02715     }
<a name="l02716"></a>02716 
<a name="l02721"></a>02721     <span class="keywordtype">bool</span> hasConfiguration(ConfigurationType configurationType)
<a name="l02722"></a>02722     {
<a name="l02723"></a>02723         base::type::EnumType lIndex = LevelHelper::kMinValid;
<a name="l02724"></a>02724         <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l02725"></a>02725         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](<span class="keywordtype">void</span>) -&gt; <span class="keywordtype">bool</span> {
<a name="l02726"></a>02726             <span class="keywordflow">if</span> (hasConfiguration(LevelHelper::castFromInt(lIndex), configurationType))
<a name="l02727"></a>02727             {
<a name="l02728"></a>02728                 result = <span class="keyword">true</span>;
<a name="l02729"></a>02729             }
<a name="l02730"></a>02730             <span class="keywordflow">return</span> result;
<a name="l02731"></a>02731         });
<a name="l02732"></a>02732         <span class="keywordflow">return</span> result;
<a name="l02733"></a>02733     }
<a name="l02734"></a>02734 
<a name="l02738"></a>02738     <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasConfiguration(Level level, ConfigurationType configurationType)
<a name="l02739"></a>02739     {
<a name="l02740"></a>02740         base::threading::ScopedLock scopedLock(lock());
<a name="l02741"></a>02741 <span class="preprocessor">#if ELPP_COMPILER_INTEL</span>
<a name="l02742"></a>02742 <span class="preprocessor"></span>        <span class="comment">// We cant specify template types here, Intel C++ throws compilation error</span>
<a name="l02743"></a>02743         <span class="comment">// &quot;error: type name is not allowed&quot;</span>
<a name="l02744"></a>02744         <span class="keywordflow">return</span> RegistryWithPred::get(level, configurationType) != <span class="keyword">nullptr</span>;
<a name="l02745"></a>02745 <span class="preprocessor">#else</span>
<a name="l02746"></a>02746 <span class="preprocessor"></span>        <span class="keywordflow">return</span> RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType) != <span class="keyword">nullptr</span>;
<a name="l02747"></a>02747 <span class="preprocessor">#endif  // ELPP_COMPILER_INTEL</span>
<a name="l02748"></a>02748 <span class="preprocessor"></span>    }
<a name="l02749"></a>02749 
<a name="l02762"></a>02762     <span class="keyword">inline</span> <span class="keywordtype">void</span> <span class="keyword">set</span>(Level level, ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value)
<a name="l02763"></a>02763     {
<a name="l02764"></a>02764         base::threading::ScopedLock scopedLock(lock());
<a name="l02765"></a>02765         unsafeSet(level, configurationType, value);  <span class="comment">// This is not unsafe anymore as we have locked mutex</span>
<a name="l02766"></a>02766         <span class="keywordflow">if</span> (level == Level::Global) {
<a name="l02767"></a>02767             unsafeSetGlobally(configurationType, value, <span class="keyword">false</span>);  <span class="comment">// Again this is not unsafe either</span>
<a name="l02768"></a>02768         }
<a name="l02769"></a>02769     }
<a name="l02770"></a>02770 
<a name="l02773"></a>02773     <span class="keyword">inline</span> <span class="keywordtype">void</span> <span class="keyword">set</span>(Configuration* conf)
<a name="l02774"></a>02774     {
<a name="l02775"></a>02775         <span class="keywordflow">if</span> (conf == <span class="keyword">nullptr</span>) {
<a name="l02776"></a>02776             <span class="keywordflow">return</span>;
<a name="l02777"></a>02777         }
<a name="l02778"></a>02778         <span class="keyword">set</span>(conf-&gt;level(), conf-&gt;configurationType(), conf-&gt;value());
<a name="l02779"></a>02779     }
<a name="l02780"></a>02780 
<a name="l02781"></a>02781     <span class="keyword">inline</span> Configuration* <span class="keyword">get</span>(Level level, ConfigurationType configurationType)
<a name="l02782"></a>02782     {
<a name="l02783"></a>02783         base::threading::ScopedLock scopedLock(lock());
<a name="l02784"></a>02784         <span class="keywordflow">return</span> RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType);
<a name="l02785"></a>02785     }
<a name="l02786"></a>02786 
<a name="l02791"></a>02791     <span class="keyword">inline</span> <span class="keywordtype">void</span> setGlobally(ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value)
<a name="l02792"></a>02792     {
<a name="l02793"></a>02793         setGlobally(configurationType, value, <span class="keyword">false</span>);
<a name="l02794"></a>02794     }
<a name="l02795"></a>02795 
<a name="l02797"></a>02797     <span class="keyword">inline</span> <span class="keywordtype">void</span> clear(<span class="keywordtype">void</span>)
<a name="l02798"></a>02798     {
<a name="l02799"></a>02799         base::threading::ScopedLock scopedLock(lock());
<a name="l02800"></a>02800         unregisterAll();
<a name="l02801"></a>02801     }
<a name="l02802"></a>02802 
<a name="l02806"></a>02806     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; configurationFile(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02807"></a>02807 <span class="keyword">    </span>{
<a name="l02808"></a>02808         <span class="keywordflow">return</span> m_configurationFile;
<a name="l02809"></a>02809     }
<a name="l02810"></a>02810 
<a name="l02812"></a>02812     <span class="keywordtype">void</span> setToDefault(<span class="keywordtype">void</span>)
<a name="l02813"></a>02813     {
<a name="l02814"></a>02814         setGlobally(ConfigurationType::Enabled, std::string(<span class="stringliteral">&quot;true&quot;</span>), <span class="keyword">true</span>);
<a name="l02815"></a>02815 <span class="preprocessor">#if !defined(ELPP_NO_DEFAULT_LOG_FILE)</span>
<a name="l02816"></a>02816 <span class="preprocessor"></span>        setGlobally(ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile), <span class="keyword">true</span>);
<a name="l02817"></a>02817 <span class="preprocessor">#else</span>
<a name="l02818"></a>02818 <span class="preprocessor"></span>        ELPP_UNUSED(base::consts::kDefaultLogFile);
<a name="l02819"></a>02819 <span class="preprocessor">#endif  // !defined(ELPP_NO_DEFAULT_LOG_FILE)</span>
<a name="l02820"></a>02820 <span class="preprocessor"></span>        setGlobally(ConfigurationType::ToFile, std::string(<span class="stringliteral">&quot;true&quot;</span>), <span class="keyword">true</span>);
<a name="l02821"></a>02821         setGlobally(ConfigurationType::ToStandardOutput, std::string(<span class="stringliteral">&quot;true&quot;</span>), <span class="keyword">true</span>);
<a name="l02822"></a>02822         setGlobally(ConfigurationType::MillisecondsWidth, std::string(<span class="stringliteral">&quot;3&quot;</span>), <span class="keyword">true</span>);
<a name="l02823"></a>02823         setGlobally(ConfigurationType::PerformanceTracking, std::string(<span class="stringliteral">&quot;true&quot;</span>), <span class="keyword">true</span>);
<a name="l02824"></a>02824         setGlobally(ConfigurationType::MaxLogFileSize, std::string(<span class="stringliteral">&quot;0&quot;</span>), <span class="keyword">true</span>);
<a name="l02825"></a>02825         setGlobally(ConfigurationType::LogFlushThreshold, std::string(<span class="stringliteral">&quot;0&quot;</span>), <span class="keyword">true</span>);
<a name="l02826"></a>02826 
<a name="l02827"></a>02827         setGlobally(ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] %msg&quot;</span>), <span class="keyword">true</span>);
<a name="l02828"></a>02828         <span class="keyword">set</span>(Level::Debug, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] [%user@%host] [%func] [%loc] %msg&quot;</span>));
<a name="l02829"></a>02829         <span class="comment">// INFO and WARNING are set to default by Level::Global</span>
<a name="l02830"></a>02830         <span class="keyword">set</span>(Level::Error, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] %msg&quot;</span>));
<a name="l02831"></a>02831         <span class="keyword">set</span>(Level::Fatal, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] %msg&quot;</span>));
<a name="l02832"></a>02832         <span class="keyword">set</span>(Level::Verbose, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level-%vlevel [%logger] %msg&quot;</span>));
<a name="l02833"></a>02833         <span class="keyword">set</span>(Level::Trace, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] [%func] [%loc] %msg&quot;</span>));
<a name="l02834"></a>02834     }
<a name="l02835"></a>02835 
<a name="l02843"></a>02843     <span class="keywordtype">void</span> setRemainingToDefault(<span class="keywordtype">void</span>)
<a name="l02844"></a>02844     {
<a name="l02845"></a>02845         base::threading::ScopedLock scopedLock(lock());
<a name="l02846"></a>02846         unsafeSetIfNotExist(Level::Global, ConfigurationType::Enabled, std::string(<span class="stringliteral">&quot;true&quot;</span>));
<a name="l02847"></a>02847 <span class="preprocessor">#if !defined(ELPP_NO_DEFAULT_LOG_FILE)</span>
<a name="l02848"></a>02848 <span class="preprocessor"></span>        unsafeSetIfNotExist(Level::Global, ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile));
<a name="l02849"></a>02849 <span class="preprocessor">#endif  // !defined(ELPP_NO_DEFAULT_LOG_FILE)</span>
<a name="l02850"></a>02850 <span class="preprocessor"></span>        unsafeSetIfNotExist(Level::Global, ConfigurationType::ToFile, std::string(<span class="stringliteral">&quot;true&quot;</span>));
<a name="l02851"></a>02851         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToStandardOutput, std::string(<span class="stringliteral">&quot;true&quot;</span>));
<a name="l02852"></a>02852         unsafeSetIfNotExist(Level::Global, ConfigurationType::MillisecondsWidth, std::string(<span class="stringliteral">&quot;3&quot;</span>));
<a name="l02853"></a>02853         unsafeSetIfNotExist(Level::Global, ConfigurationType::PerformanceTracking, std::string(<span class="stringliteral">&quot;true&quot;</span>));
<a name="l02854"></a>02854         unsafeSetIfNotExist(Level::Global, ConfigurationType::MaxLogFileSize, std::string(<span class="stringliteral">&quot;0&quot;</span>));
<a name="l02855"></a>02855         unsafeSetIfNotExist(Level::Global, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] %msg&quot;</span>));
<a name="l02856"></a>02856         unsafeSetIfNotExist(Level::Debug, ConfigurationType::Format,
<a name="l02857"></a>02857                             std::string(<span class="stringliteral">&quot;%datetime %level [%logger] [%user@%host] [%func] [%loc] %msg&quot;</span>));
<a name="l02858"></a>02858         <span class="comment">// INFO and WARNING are set to default by Level::Global</span>
<a name="l02859"></a>02859         unsafeSetIfNotExist(Level::Error, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] %msg&quot;</span>));
<a name="l02860"></a>02860         unsafeSetIfNotExist(Level::Fatal, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] %msg&quot;</span>));
<a name="l02861"></a>02861         unsafeSetIfNotExist(Level::Verbose, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level-%vlevel [%logger] %msg&quot;</span>));
<a name="l02862"></a>02862         unsafeSetIfNotExist(Level::Trace, ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level [%logger] [%func] [%loc] %msg&quot;</span>));
<a name="l02863"></a>02863     }
<a name="l02864"></a>02864 
<a name="l02869"></a>02869     <span class="keyword">class </span>Parser : base::StaticClass
<a name="l02870"></a>02870     {
<a name="l02871"></a>02871     <span class="keyword">public</span>:
<a name="l02879"></a>02879         <span class="keyword">static</span> <span class="keywordtype">bool</span> parseFromFile(<span class="keyword">const</span> std::string&amp; configurationFile, Configurations* sender, Configurations* base = <span class="keyword">nullptr</span>)
<a name="l02880"></a>02880         {
<a name="l02881"></a>02881             sender-&gt;setFromBase(base);
<a name="l02882"></a>02882             std::ifstream fileStream_(configurationFile.c_str(), std::ifstream::in);
<a name="l02883"></a>02883             ELPP_ASSERT(fileStream_.is_open(), <span class="stringliteral">&quot;Unable to open configuration file [&quot;</span> &lt;&lt; configurationFile &lt;&lt; <span class="stringliteral">&quot;] for parsing.&quot;</span>);
<a name="l02884"></a>02884             <span class="keywordtype">bool</span> parsedSuccessfully = <span class="keyword">false</span>;
<a name="l02885"></a>02885             std::string line = std::string();
<a name="l02886"></a>02886             Level currLevel = Level::Unknown;
<a name="l02887"></a>02887             std::string currConfigStr = std::string();
<a name="l02888"></a>02888             std::string currLevelStr = std::string();
<a name="l02889"></a>02889             <span class="keywordflow">while</span> (fileStream_.good()) {
<a name="l02890"></a>02890                 std::getline(fileStream_, line);
<a name="l02891"></a>02891                 parsedSuccessfully = parseLine(&amp;line, &amp;currConfigStr, &amp;currLevelStr, &amp;currLevel, sender);
<a name="l02892"></a>02892                 ELPP_ASSERT(parsedSuccessfully, <span class="stringliteral">&quot;Unable to parse configuration line: &quot;</span> &lt;&lt; line);
<a name="l02893"></a>02893             }
<a name="l02894"></a>02894             <span class="keywordflow">return</span> parsedSuccessfully;
<a name="l02895"></a>02895         }
<a name="l02896"></a>02896 
<a name="l02907"></a>02907         <span class="keyword">static</span> <span class="keywordtype">bool</span> parseFromText(<span class="keyword">const</span> std::string&amp; configurationsString, Configurations* sender, Configurations* base = <span class="keyword">nullptr</span>)
<a name="l02908"></a>02908         {
<a name="l02909"></a>02909             sender-&gt;setFromBase(base);
<a name="l02910"></a>02910             <span class="keywordtype">bool</span> parsedSuccessfully = <span class="keyword">false</span>;
<a name="l02911"></a>02911             std::stringstream ss(configurationsString);
<a name="l02912"></a>02912             std::string line = std::string();
<a name="l02913"></a>02913             Level currLevel = Level::Unknown;
<a name="l02914"></a>02914             std::string currConfigStr = std::string();
<a name="l02915"></a>02915             std::string currLevelStr = std::string();
<a name="l02916"></a>02916             <span class="keywordflow">while</span> (std::getline(ss, line)) {
<a name="l02917"></a>02917                 parsedSuccessfully = parseLine(&amp;line, &amp;currConfigStr, &amp;currLevelStr, &amp;currLevel, sender);
<a name="l02918"></a>02918                 ELPP_ASSERT(parsedSuccessfully, <span class="stringliteral">&quot;Unable to parse configuration line: &quot;</span> &lt;&lt; line);
<a name="l02919"></a>02919             }
<a name="l02920"></a>02920             <span class="keywordflow">return</span> parsedSuccessfully;
<a name="l02921"></a>02921         }
<a name="l02922"></a>02922 
<a name="l02923"></a>02923     <span class="keyword">private</span>:
<a name="l02924"></a>02924         <span class="keyword">friend</span> <span class="keyword">class </span>el::Loggers;
<a name="l02925"></a>02925         <span class="keyword">static</span> <span class="keywordtype">void</span> ignoreComments(std::string* line)
<a name="l02926"></a>02926         {
<a name="l02927"></a>02927             std::size_t foundAt = 0;
<a name="l02928"></a>02928             std::size_t quotesStart = line-&gt;find(<span class="stringliteral">&quot;\&quot;&quot;</span>);
<a name="l02929"></a>02929             std::size_t quotesEnd = std::string::npos;
<a name="l02930"></a>02930             <span class="keywordflow">if</span> (quotesStart != std::string::npos) {
<a name="l02931"></a>02931                 quotesEnd = line-&gt;find(<span class="stringliteral">&quot;\&quot;&quot;</span>, quotesStart + 1);
<a name="l02932"></a>02932                 <span class="keywordflow">while</span> (quotesEnd != std::string::npos &amp;&amp; line-&gt;at(quotesEnd - 1) == <span class="charliteral">&apos;\\&apos;</span>) {
<a name="l02933"></a>02933                     <span class="comment">// Do not erase slash yet - we will erase it in parseLine(..) while loop</span>
<a name="l02934"></a>02934                     quotesEnd = line-&gt;find(<span class="stringliteral">&quot;\&quot;&quot;</span>, quotesEnd + 2);
<a name="l02935"></a>02935                 }
<a name="l02936"></a>02936             }
<a name="l02937"></a>02937             <span class="keywordflow">if</span> ((foundAt = line-&gt;find(base::consts::kConfigurationComment)) != std::string::npos) {
<a name="l02938"></a>02938                 <span class="keywordflow">if</span> (foundAt &lt; quotesEnd) {
<a name="l02939"></a>02939                     foundAt = line-&gt;find(base::consts::kConfigurationComment, quotesEnd + 1);
<a name="l02940"></a>02940                 }
<a name="l02941"></a>02941                 *line = line-&gt;substr(0, foundAt);
<a name="l02942"></a>02942             }
<a name="l02943"></a>02943         }
<a name="l02944"></a>02944         <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isLevel(<span class="keyword">const</span> std::string&amp; line)
<a name="l02945"></a>02945         {
<a name="l02946"></a>02946             <span class="keywordflow">return</span> base::utils::Str::startsWith(line, std::string(base::consts::kConfigurationLevel));
<a name="l02947"></a>02947         }
<a name="l02948"></a>02948 
<a name="l02949"></a>02949         <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isComment(<span class="keyword">const</span> std::string&amp; line)
<a name="l02950"></a>02950         {
<a name="l02951"></a>02951             <span class="keywordflow">return</span> base::utils::Str::startsWith(line, std::string(base::consts::kConfigurationComment));
<a name="l02952"></a>02952         }
<a name="l02953"></a>02953 
<a name="l02954"></a>02954         <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isConfig(<span class="keyword">const</span> std::string&amp; line)
<a name="l02955"></a>02955         {
<a name="l02956"></a>02956             std::size_t assignment = line.find(<span class="charliteral">&apos;=&apos;</span>);
<a name="l02957"></a>02957             <span class="keywordflow">return</span> line != <span class="stringliteral">&quot;&quot;</span> &amp;&amp;
<a name="l02958"></a>02958                    (line[0] &gt;= 65 || line[0] &lt;= 90 || line[0] &gt;= 97 || line[0] &lt;= 122) &amp;&amp;
<a name="l02959"></a>02959                    (assignment != std::string::npos) &amp;&amp;
<a name="l02960"></a>02960                    (line.size() &gt; assignment);
<a name="l02961"></a>02961         }
<a name="l02962"></a>02962 
<a name="l02963"></a>02963         <span class="keyword">static</span> <span class="keywordtype">bool</span> parseLine(std::string* line, std::string* currConfigStr, std::string* currLevelStr, Level* currLevel, Configurations* conf)
<a name="l02964"></a>02964         {
<a name="l02965"></a>02965             ConfigurationType currConfig = ConfigurationType::Unknown;
<a name="l02966"></a>02966             std::string currValue = std::string();
<a name="l02967"></a>02967             *line = base::utils::Str::trim(*line);
<a name="l02968"></a>02968             <span class="keywordflow">if</span> (isComment(*line)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02969"></a>02969             ignoreComments(line);
<a name="l02970"></a>02970             *line = base::utils::Str::trim(*line);
<a name="l02971"></a>02971             <span class="keywordflow">if</span> (line-&gt;empty()) {
<a name="l02972"></a>02972                 <span class="comment">// Comment ignored</span>
<a name="l02973"></a>02973                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02974"></a>02974             }
<a name="l02975"></a>02975             <span class="keywordflow">if</span> (isLevel(*line)) {
<a name="l02976"></a>02976                 <span class="keywordflow">if</span> (line-&gt;size() &lt;= 2) {
<a name="l02977"></a>02977                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02978"></a>02978                 }
<a name="l02979"></a>02979                 *currLevelStr = line-&gt;substr(1, line-&gt;size() - 2);
<a name="l02980"></a>02980                 *currLevelStr = base::utils::Str::toUpper(*currLevelStr);
<a name="l02981"></a>02981                 *currLevelStr = base::utils::Str::trim(*currLevelStr);
<a name="l02982"></a>02982                 *currLevel = LevelHelper::convertFromString(currLevelStr-&gt;c_str());
<a name="l02983"></a>02983                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02984"></a>02984             }
<a name="l02985"></a>02985             <span class="keywordflow">if</span> (isConfig(*line)) {
<a name="l02986"></a>02986                 std::size_t assignment = line-&gt;find(<span class="charliteral">&apos;=&apos;</span>);
<a name="l02987"></a>02987                 *currConfigStr = line-&gt;substr(0, assignment);
<a name="l02988"></a>02988                 *currConfigStr = base::utils::Str::toUpper(*currConfigStr);
<a name="l02989"></a>02989                 *currConfigStr = base::utils::Str::trim(*currConfigStr);
<a name="l02990"></a>02990                 currConfig = ConfigurationTypeHelper::convertFromString(currConfigStr-&gt;c_str());
<a name="l02991"></a>02991                 currValue = line-&gt;substr(assignment + 1);
<a name="l02992"></a>02992                 currValue = base::utils::Str::trim(currValue);
<a name="l02993"></a>02993                 std::size_t quotesStart = currValue.find(<span class="stringliteral">&quot;\&quot;&quot;</span>, 0);
<a name="l02994"></a>02994                 std::size_t quotesEnd = std::string::npos;
<a name="l02995"></a>02995                 <span class="keywordflow">if</span> (quotesStart != std::string::npos) {
<a name="l02996"></a>02996                     quotesEnd = currValue.find(<span class="stringliteral">&quot;\&quot;&quot;</span>, quotesStart + 1);
<a name="l02997"></a>02997                     <span class="keywordflow">while</span> (quotesEnd != std::string::npos &amp;&amp; currValue.at(quotesEnd - 1) == <span class="charliteral">&apos;\\&apos;</span>) {
<a name="l02998"></a>02998                         currValue = currValue.erase(quotesEnd - 1, 1);
<a name="l02999"></a>02999                         quotesEnd = currValue.find(<span class="stringliteral">&quot;\&quot;&quot;</span>, quotesEnd + 2);
<a name="l03000"></a>03000                     }
<a name="l03001"></a>03001                 }
<a name="l03002"></a>03002                 <span class="keywordflow">if</span> (quotesStart != std::string::npos &amp;&amp; quotesEnd != std::string::npos) {
<a name="l03003"></a>03003                     <span class="comment">// Quote provided - check and strip if valid</span>
<a name="l03004"></a>03004                     ELPP_ASSERT((quotesStart &lt; quotesEnd), <span class="stringliteral">&quot;Configuration error - No ending quote found in [&quot;</span>
<a name="l03005"></a>03005                                 &lt;&lt; currConfigStr &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03006"></a>03006                     ELPP_ASSERT((quotesStart + 1 != quotesEnd), <span class="stringliteral">&quot;Empty configuration value for [&quot;</span> &lt;&lt; currConfigStr &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03007"></a>03007                     <span class="keywordflow">if</span> ((quotesStart != quotesEnd) &amp;&amp; (quotesStart + 1 != quotesEnd)) {
<a name="l03008"></a>03008                         <span class="comment">// Explicit check in case if assertion is disabled</span>
<a name="l03009"></a>03009                         currValue = currValue.substr(quotesStart + 1, quotesEnd - 1);
<a name="l03010"></a>03010                     }
<a name="l03011"></a>03011                 }
<a name="l03012"></a>03012             }
<a name="l03013"></a>03013             ELPP_ASSERT(*currLevel != Level::Unknown, <span class="stringliteral">&quot;Unrecognized severity level [&quot;</span> &lt;&lt; *currLevelStr &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03014"></a>03014             ELPP_ASSERT(currConfig != ConfigurationType::Unknown, <span class="stringliteral">&quot;Unrecognized configuration [&quot;</span> &lt;&lt; *currConfigStr &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03015"></a>03015             <span class="keywordflow">if</span> (*currLevel == Level::Unknown || currConfig == ConfigurationType::Unknown) {
<a name="l03016"></a>03016                 <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// unrecognizable level or config</span>
<a name="l03017"></a>03017             }
<a name="l03018"></a>03018             conf-&gt;set(*currLevel, currConfig, currValue);
<a name="l03019"></a>03019             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03020"></a>03020         }
<a name="l03021"></a>03021     };
<a name="l03022"></a>03022 
<a name="l03023"></a>03023 <span class="keyword">private</span>:
<a name="l03024"></a>03024     std::string m_configurationFile;
<a name="l03025"></a>03025     <span class="keywordtype">bool</span> m_isFromFile;
<a name="l03026"></a>03026     <span class="keyword">friend</span> <span class="keyword">class </span>el::Loggers;
<a name="l03027"></a>03027 
<a name="l03029"></a>03029     <span class="keywordtype">void</span> unsafeSetIfNotExist(Level level, ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value)
<a name="l03030"></a>03030     {
<a name="l03031"></a>03031         Configuration* conf = RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType);
<a name="l03032"></a>03032         <span class="keywordflow">if</span> (conf == <span class="keyword">nullptr</span>) {
<a name="l03033"></a>03033             unsafeSet(level, configurationType, value);
<a name="l03034"></a>03034         }
<a name="l03035"></a>03035     }
<a name="l03036"></a>03036 
<a name="l03038"></a>03038     <span class="keywordtype">void</span> unsafeSet(Level level, ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value)
<a name="l03039"></a>03039     {
<a name="l03040"></a>03040         Configuration* conf = RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType);
<a name="l03041"></a>03041         <span class="keywordflow">if</span> (conf == <span class="keyword">nullptr</span>) {
<a name="l03042"></a>03042             registerNew(<span class="keyword">new</span> Configuration(level, configurationType, value));
<a name="l03043"></a>03043         } <span class="keywordflow">else</span> {
<a name="l03044"></a>03044             conf-&gt;setValue(value);
<a name="l03045"></a>03045         }
<a name="l03046"></a>03046         <span class="keywordflow">if</span> (level == Level::Global) {
<a name="l03047"></a>03047             unsafeSetGlobally(configurationType, value, <span class="keyword">false</span>);
<a name="l03048"></a>03048         }
<a name="l03049"></a>03049     }
<a name="l03050"></a>03050 
<a name="l03053"></a>03053     <span class="keywordtype">void</span> setGlobally(ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">bool</span> includeGlobalLevel)
<a name="l03054"></a>03054     {
<a name="l03055"></a>03055         <span class="keywordflow">if</span> (includeGlobalLevel) {
<a name="l03056"></a>03056             <span class="keyword">set</span>(Level::Global, configurationType, value);
<a name="l03057"></a>03057         }
<a name="l03058"></a>03058         base::type::EnumType lIndex = LevelHelper::kMinValid;
<a name="l03059"></a>03059         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](<span class="keywordtype">void</span>) -&gt; <span class="keywordtype">bool</span> {
<a name="l03060"></a>03060             <span class="keyword">set</span>(LevelHelper::castFromInt(lIndex), configurationType, value);
<a name="l03061"></a>03061             <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Do not break lambda function yet as we need to set all levels regardless</span>
<a name="l03062"></a>03062         });
<a name="l03063"></a>03063     }
<a name="l03064"></a>03064 
<a name="l03067"></a>03067     <span class="keywordtype">void</span> unsafeSetGlobally(ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value, <span class="keywordtype">bool</span> includeGlobalLevel)
<a name="l03068"></a>03068     {
<a name="l03069"></a>03069         <span class="keywordflow">if</span> (includeGlobalLevel) {
<a name="l03070"></a>03070             unsafeSet(Level::Global, configurationType, value);
<a name="l03071"></a>03071         }
<a name="l03072"></a>03072         base::type::EnumType lIndex = LevelHelper::kMinValid;
<a name="l03073"></a>03073         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](<span class="keywordtype">void</span>) -&gt; <span class="keywordtype">bool</span>  {
<a name="l03074"></a>03074             unsafeSet(LevelHelper::castFromInt(lIndex), configurationType, value);
<a name="l03075"></a>03075             <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Do not break lambda function yet as we need to set all levels regardless</span>
<a name="l03076"></a>03076         });
<a name="l03077"></a>03077     }
<a name="l03078"></a>03078 };
<a name="l03079"></a>03079 
<a name="l03080"></a>03080 <span class="keyword">namespace </span>base {
<a name="l03081"></a>03081 <span class="keyword">typedef</span> std::shared_ptr&lt;base::type::fstream_t&gt; FileStreamPtr;
<a name="l03082"></a>03082 <span class="keyword">typedef</span> std::map&lt;std::string, FileStreamPtr&gt; LogStreamsReferenceMap;
<a name="l03089"></a>03089 <span class="keyword">class </span>TypedConfigurations : <span class="keyword">public</span> base::threading::ThreadSafe
<a name="l03090"></a>03090 {
<a name="l03091"></a>03091 <span class="keyword">public</span>:
<a name="l03095"></a>03095     TypedConfigurations(Configurations* configurations, base::LogStreamsReferenceMap* logStreamsReference)
<a name="l03096"></a>03096     {
<a name="l03097"></a>03097         m_configurations = configurations;
<a name="l03098"></a>03098         m_logStreamsReference = logStreamsReference;
<a name="l03099"></a>03099         build(m_configurations);
<a name="l03100"></a>03100     }
<a name="l03101"></a>03101 
<a name="l03102"></a>03102     TypedConfigurations(<span class="keyword">const</span> TypedConfigurations&amp; other)
<a name="l03103"></a>03103     {
<a name="l03104"></a>03104         this-&gt;m_configurations = other.m_configurations;
<a name="l03105"></a>03105         this-&gt;m_logStreamsReference = other.m_logStreamsReference;
<a name="l03106"></a>03106         build(m_configurations);
<a name="l03107"></a>03107     }
<a name="l03108"></a>03108 
<a name="l03109"></a>03109     <span class="keyword">virtual</span> ~TypedConfigurations(<span class="keywordtype">void</span>)
<a name="l03110"></a>03110     {
<a name="l03111"></a>03111     }
<a name="l03112"></a>03112 
<a name="l03113"></a>03113     <span class="keyword">const</span> Configurations* configurations(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03114"></a>03114 <span class="keyword">    </span>{
<a name="l03115"></a>03115         <span class="keywordflow">return</span> m_configurations;
<a name="l03116"></a>03116     }
<a name="l03117"></a>03117 
<a name="l03118"></a>03118     <span class="keyword">inline</span> <span class="keywordtype">bool</span> enabled(Level level)
<a name="l03119"></a>03119     {
<a name="l03120"></a>03120         <span class="keywordflow">return</span> getConfigByVal&lt;bool&gt;(level, &amp;m_enabledMap, <span class="stringliteral">&quot;enabled&quot;</span>);
<a name="l03121"></a>03121     }
<a name="l03122"></a>03122 
<a name="l03123"></a>03123     <span class="keyword">inline</span> <span class="keywordtype">bool</span> toFile(Level level)
<a name="l03124"></a>03124     {
<a name="l03125"></a>03125         <span class="keywordflow">return</span> getConfigByVal&lt;bool&gt;(level, &amp;m_toFileMap, <span class="stringliteral">&quot;toFile&quot;</span>);
<a name="l03126"></a>03126     }
<a name="l03127"></a>03127 
<a name="l03128"></a>03128     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; filename(Level level)
<a name="l03129"></a>03129     {
<a name="l03130"></a>03130         <span class="keywordflow">return</span> getConfigByRef&lt;std::string&gt;(level, &amp;m_filenameMap, <span class="stringliteral">&quot;filename&quot;</span>);
<a name="l03131"></a>03131     }
<a name="l03132"></a>03132 
<a name="l03133"></a>03133     <span class="keyword">inline</span> <span class="keywordtype">bool</span> toStandardOutput(Level level)
<a name="l03134"></a>03134     {
<a name="l03135"></a>03135         <span class="keywordflow">return</span> getConfigByVal&lt;bool&gt;(level, &amp;m_toStandardOutputMap, <span class="stringliteral">&quot;toStandardOutput&quot;</span>);
<a name="l03136"></a>03136     }
<a name="l03137"></a>03137 
<a name="l03138"></a>03138     <span class="keyword">inline</span> <span class="keyword">const</span> base::LogFormat&amp; logFormat(Level level)
<a name="l03139"></a>03139     {
<a name="l03140"></a>03140         <span class="keywordflow">return</span> getConfigByRef&lt;base::LogFormat&gt;(level, &amp;m_logFormatMap, <span class="stringliteral">&quot;logFormat&quot;</span>);
<a name="l03141"></a>03141     }
<a name="l03142"></a>03142 
<a name="l03143"></a>03143     <span class="keyword">inline</span> <span class="keyword">const</span> base::MillisecondsWidth&amp; millisecondsWidth(Level level = Level::Global)
<a name="l03144"></a>03144     {
<a name="l03145"></a>03145         <span class="keywordflow">return</span> getConfigByRef&lt;base::MillisecondsWidth&gt;(level, &amp;m_millisecondsWidthMap, <span class="stringliteral">&quot;millisecondsWidth&quot;</span>);
<a name="l03146"></a>03146     }
<a name="l03147"></a>03147 
<a name="l03148"></a>03148     <span class="keyword">inline</span> <span class="keywordtype">bool</span> performanceTracking(Level level = Level::Global)
<a name="l03149"></a>03149     {
<a name="l03150"></a>03150         <span class="keywordflow">return</span> getConfigByVal&lt;bool&gt;(level, &amp;m_performanceTrackingMap, <span class="stringliteral">&quot;performanceTracking&quot;</span>);
<a name="l03151"></a>03151     }
<a name="l03152"></a>03152 
<a name="l03153"></a>03153     <span class="keyword">inline</span> base::type::fstream_t* fileStream(Level level)
<a name="l03154"></a>03154     {
<a name="l03155"></a>03155         <span class="keywordflow">return</span> getConfigByRef&lt;base::FileStreamPtr&gt;(level, &amp;m_fileStreamMap, <span class="stringliteral">&quot;fileStream&quot;</span>).<span class="keyword">get</span>();
<a name="l03156"></a>03156     }
<a name="l03157"></a>03157 
<a name="l03158"></a>03158     <span class="keyword">inline</span> std::size_t maxLogFileSize(Level level)
<a name="l03159"></a>03159     {
<a name="l03160"></a>03160         <span class="keywordflow">return</span> getConfigByVal&lt;std::size_t&gt;(level, &amp;m_maxLogFileSizeMap, <span class="stringliteral">&quot;maxLogFileSize&quot;</span>);
<a name="l03161"></a>03161     }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163     <span class="keyword">inline</span> std::size_t logFlushThreshold(Level level)
<a name="l03164"></a>03164     {
<a name="l03165"></a>03165         <span class="keywordflow">return</span> getConfigByVal&lt;std::size_t&gt;(level, &amp;m_logFlushThresholdMap, <span class="stringliteral">&quot;logFlushThreshold&quot;</span>);
<a name="l03166"></a>03166     }
<a name="l03167"></a>03167 
<a name="l03168"></a>03168 <span class="keyword">private</span>:
<a name="l03169"></a>03169     Configurations* m_configurations;
<a name="l03170"></a>03170     std::map&lt;Level, bool&gt; m_enabledMap;
<a name="l03171"></a>03171     std::map&lt;Level, bool&gt; m_toFileMap;
<a name="l03172"></a>03172     std::map&lt;Level, std::string&gt; m_filenameMap;
<a name="l03173"></a>03173     std::map&lt;Level, bool&gt; m_toStandardOutputMap;
<a name="l03174"></a>03174     std::map&lt;Level, base::LogFormat&gt; m_logFormatMap;
<a name="l03175"></a>03175     std::map&lt;Level, base::MillisecondsWidth&gt; m_millisecondsWidthMap;
<a name="l03176"></a>03176     std::map&lt;Level, bool&gt; m_performanceTrackingMap;
<a name="l03177"></a>03177     std::map&lt;Level, base::FileStreamPtr&gt; m_fileStreamMap;
<a name="l03178"></a>03178     std::map&lt;Level, std::size_t&gt; m_maxLogFileSizeMap;
<a name="l03179"></a>03179     std::map&lt;Level, std::size_t&gt; m_logFlushThresholdMap;
<a name="l03180"></a>03180     base::LogStreamsReferenceMap* m_logStreamsReference;
<a name="l03181"></a>03181 
<a name="l03182"></a>03182     <span class="keyword">friend</span> <span class="keyword">class </span>el::Helpers;
<a name="l03183"></a>03183     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::MessageBuilder;
<a name="l03184"></a>03184     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::Writer;
<a name="l03185"></a>03185     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::DefaultLogDispatchCallback;
<a name="l03186"></a>03186     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::LogDispatcher;
<a name="l03187"></a>03187 
<a name="l03188"></a>03188     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Conf_T&gt;
<a name="l03189"></a>03189     <span class="keyword">inline</span> Conf_T getConfigByVal(Level level, <span class="keyword">const</span> std::map&lt;Level, Conf_T&gt;* confMap, <span class="keyword">const</span> <span class="keywordtype">char</span>* confName)
<a name="l03190"></a>03190     {
<a name="l03191"></a>03191         base::threading::ScopedLock scopedLock(lock());
<a name="l03192"></a>03192         <span class="keywordflow">return</span> unsafeGetConfigByVal(level, confMap, confName);  <span class="comment">// This is not unsafe anymore - mutex locked in scope</span>
<a name="l03193"></a>03193     }
<a name="l03194"></a>03194 
<a name="l03195"></a>03195     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Conf_T&gt;
<a name="l03196"></a>03196     <span class="keyword">inline</span> Conf_T&amp; getConfigByRef(Level level, std::map&lt;Level, Conf_T&gt;* confMap, <span class="keyword">const</span> <span class="keywordtype">char</span>* confName)
<a name="l03197"></a>03197     {
<a name="l03198"></a>03198         base::threading::ScopedLock scopedLock(lock());
<a name="l03199"></a>03199         <span class="keywordflow">return</span> unsafeGetConfigByRef(level, confMap, confName);  <span class="comment">// This is not unsafe anymore - mutex locked in scope</span>
<a name="l03200"></a>03200     }
<a name="l03201"></a>03201 
<a name="l03202"></a>03202     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Conf_T&gt;
<a name="l03203"></a>03203     <span class="keyword">inline</span> Conf_T unsafeGetConfigByVal(Level level, <span class="keyword">const</span> std::map&lt;Level, Conf_T&gt;* confMap, <span class="keyword">const</span> <span class="keywordtype">char</span>* confName)
<a name="l03204"></a>03204     {
<a name="l03205"></a>03205         ELPP_UNUSED(confName);
<a name="l03206"></a>03206         <span class="keyword">typename</span> std::map&lt;Level, Conf_T&gt;::const_iterator it = confMap-&gt;find(level);
<a name="l03207"></a>03207         <span class="keywordflow">if</span> (it == confMap-&gt;end()) {
<a name="l03208"></a>03208             <span class="keywordflow">try</span> {
<a name="l03209"></a>03209                 <span class="keywordflow">return</span> confMap-&gt;at(Level::Global);
<a name="l03210"></a>03210             } <span class="keywordflow">catch</span> (...) {
<a name="l03211"></a>03211                 ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Unable to get configuration [&quot;</span> &lt;&lt; confName &lt;&lt; <span class="stringliteral">&quot;] for level [&quot;</span>
<a name="l03212"></a>03212                                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>
<a name="l03213"></a>03213                                     &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Please ensure you have properly configured logger.&quot;</span>, <span class="keyword">false</span>);
<a name="l03214"></a>03214                 <span class="keywordflow">return</span> Conf_T();
<a name="l03215"></a>03215             }
<a name="l03216"></a>03216         }
<a name="l03217"></a>03217         <span class="keywordflow">return</span> it-&gt;second;
<a name="l03218"></a>03218     }
<a name="l03219"></a>03219 
<a name="l03220"></a>03220     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Conf_T&gt;
<a name="l03221"></a>03221     <span class="keyword">inline</span> Conf_T&amp; unsafeGetConfigByRef(Level level, std::map&lt;Level, Conf_T&gt;* confMap, <span class="keyword">const</span> <span class="keywordtype">char</span>* confName)
<a name="l03222"></a>03222     {
<a name="l03223"></a>03223         ELPP_UNUSED(confName);
<a name="l03224"></a>03224         <span class="keyword">typename</span> std::map&lt;Level, Conf_T&gt;::iterator it = confMap-&gt;find(level);
<a name="l03225"></a>03225         <span class="keywordflow">if</span> (it == confMap-&gt;end()) {
<a name="l03226"></a>03226             <span class="keywordflow">try</span> {
<a name="l03227"></a>03227                 <span class="keywordflow">return</span> confMap-&gt;at(Level::Global);
<a name="l03228"></a>03228             } <span class="keywordflow">catch</span> (...) {
<a name="l03229"></a>03229                 ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Unable to get configuration [&quot;</span> &lt;&lt; confName &lt;&lt; <span class="stringliteral">&quot;] for level [&quot;</span>
<a name="l03230"></a>03230                                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>
<a name="l03231"></a>03231                                     &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Please ensure you have properly configured logger.&quot;</span>, <span class="keyword">false</span>);
<a name="l03232"></a>03232             }
<a name="l03233"></a>03233         }
<a name="l03234"></a>03234         <span class="keywordflow">return</span> it-&gt;second;
<a name="l03235"></a>03235     }
<a name="l03236"></a>03236 
<a name="l03237"></a>03237     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Conf_T&gt;
<a name="l03238"></a>03238     <span class="keywordtype">void</span> setValue(Level level, <span class="keyword">const</span> Conf_T&amp; value, std::map&lt;Level, Conf_T&gt;* confMap, <span class="keywordtype">bool</span> includeGlobalLevel = <span class="keyword">true</span>)
<a name="l03239"></a>03239     {
<a name="l03240"></a>03240         <span class="comment">// If map is empty and we are allowed to add into generic level (Level::Global), do it!</span>
<a name="l03241"></a>03241         <span class="keywordflow">if</span> (confMap-&gt;empty() &amp;&amp; includeGlobalLevel) {
<a name="l03242"></a>03242             confMap-&gt;insert(std::make_pair(Level::Global, value));
<a name="l03243"></a>03243             <span class="keywordflow">return</span>;
<a name="l03244"></a>03244         }
<a name="l03245"></a>03245         <span class="comment">// If same value exist in generic level already, dont add it to explicit level</span>
<a name="l03246"></a>03246         <span class="keyword">typename</span> std::map&lt;Level, Conf_T&gt;::iterator it = confMap-&gt;find(Level::Global);
<a name="l03247"></a>03247         <span class="keywordflow">if</span> (it != confMap-&gt;end() &amp;&amp; it-&gt;second == value) {
<a name="l03248"></a>03248             <span class="keywordflow">return</span>;
<a name="l03249"></a>03249         }
<a name="l03250"></a>03250         <span class="comment">// Now make sure we dont double up values if we really need to add it to explicit level</span>
<a name="l03251"></a>03251         it = confMap-&gt;find(level);
<a name="l03252"></a>03252         <span class="keywordflow">if</span> (it == confMap-&gt;end()) {
<a name="l03253"></a>03253             <span class="comment">// Value not found for level, add new</span>
<a name="l03254"></a>03254             confMap-&gt;insert(std::make_pair(level, value));
<a name="l03255"></a>03255         } <span class="keywordflow">else</span> {
<a name="l03256"></a>03256             <span class="comment">// Value found, just update value</span>
<a name="l03257"></a>03257             confMap-&gt;at(level) = value;
<a name="l03258"></a>03258         }
<a name="l03259"></a>03259     }
<a name="l03260"></a>03260 
<a name="l03261"></a>03261     <span class="keywordtype">void</span> build(Configurations* configurations)
<a name="l03262"></a>03262     {
<a name="l03263"></a>03263         base::threading::ScopedLock scopedLock(lock());
<a name="l03264"></a>03264         <span class="keyword">auto</span> getBool = [] (std::string boolStr) -&gt; <span class="keywordtype">bool</span> {  <span class="comment">// Pass by value for trimming</span>
<a name="l03265"></a>03265             base::utils::Str::trim(boolStr);
<a name="l03266"></a>03266             <span class="keywordflow">return</span> (boolStr == <span class="stringliteral">&quot;TRUE&quot;</span> || boolStr == <span class="stringliteral">&quot;true&quot;</span> || boolStr == <span class="stringliteral">&quot;1&quot;</span>);
<a name="l03267"></a>03267         };
<a name="l03268"></a>03268         std::vector&lt;Configuration*&gt; withFileSizeLimit;
<a name="l03269"></a>03269         <span class="keywordflow">for</span> (Configurations::const_iterator it = configurations-&gt;begin(); it != configurations-&gt;end(); ++it) {
<a name="l03270"></a>03270             Configuration* conf = *it;
<a name="l03271"></a>03271             <span class="comment">// We cannot use switch on strong enums because Intel C++ dont support them yet</span>
<a name="l03272"></a>03272             <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::Enabled) {
<a name="l03273"></a>03273                 setValue(conf-&gt;level(), getBool(conf-&gt;value()), &amp;m_enabledMap);
<a name="l03274"></a>03274             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::ToFile) {
<a name="l03275"></a>03275                 setValue(conf-&gt;level(), getBool(conf-&gt;value()), &amp;m_toFileMap);
<a name="l03276"></a>03276             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::ToStandardOutput) {
<a name="l03277"></a>03277                 setValue(conf-&gt;level(), getBool(conf-&gt;value()), &amp;m_toStandardOutputMap);
<a name="l03278"></a>03278             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::Filename) {
<a name="l03279"></a>03279                 <span class="comment">// We do not yet configure filename but we will configure in another</span>
<a name="l03280"></a>03280                 <span class="comment">// loop. This is because if file cannot be created, we will force ToFile</span>
<a name="l03281"></a>03281                 <span class="comment">// to be false. Because configuring logger is not necessarily performance</span>
<a name="l03282"></a>03282                 <span class="comment">// sensative operation, we can live with another loop; (by the way this loop</span>
<a name="l03283"></a>03283                 <span class="comment">// is not very heavy either)</span>
<a name="l03284"></a>03284             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::Format) {
<a name="l03285"></a>03285                 setValue(conf-&gt;level(), base::LogFormat(conf-&gt;level(),
<a name="l03286"></a>03286                                                         base::type::string_t(conf-&gt;value().begin(), conf-&gt;value().end())), &amp;m_logFormatMap);
<a name="l03287"></a>03287             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::MillisecondsWidth) {
<a name="l03288"></a>03288                 setValue(Level::Global,
<a name="l03289"></a>03289                          base::MillisecondsWidth(static_cast&lt;int&gt;(getULong(conf-&gt;value()))), &amp;m_millisecondsWidthMap);
<a name="l03290"></a>03290             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::PerformanceTracking) {
<a name="l03291"></a>03291                 setValue(Level::Global, getBool(conf-&gt;value()), &amp;m_performanceTrackingMap);
<a name="l03292"></a>03292             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::MaxLogFileSize) {
<a name="l03293"></a>03293                 setValue(conf-&gt;level(), <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(getULong(conf-&gt;value())), &amp;m_maxLogFileSizeMap);
<a name="l03294"></a>03294 <span class="preprocessor">#if !defined(ELPP_NO_DEFAULT_LOG_FILE)</span>
<a name="l03295"></a>03295 <span class="preprocessor"></span>                withFileSizeLimit.push_back(conf);
<a name="l03296"></a>03296 <span class="preprocessor">#endif  // !defined(ELPP_NO_DEFAULT_LOG_FILE)</span>
<a name="l03297"></a>03297 <span class="preprocessor"></span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::LogFlushThreshold) {
<a name="l03298"></a>03298                 setValue(conf-&gt;level(), <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(getULong(conf-&gt;value())), &amp;m_logFlushThresholdMap);
<a name="l03299"></a>03299             }
<a name="l03300"></a>03300         }
<a name="l03301"></a>03301         <span class="comment">// As mentioned early, we will now set filename configuration in separate loop to deal with non-existent files</span>
<a name="l03302"></a>03302         <span class="keywordflow">for</span> (Configurations::const_iterator it = configurations-&gt;begin(); it != configurations-&gt;end(); ++it) {
<a name="l03303"></a>03303             Configuration* conf = *it;
<a name="l03304"></a>03304             <span class="keywordflow">if</span> (conf-&gt;configurationType() == ConfigurationType::Filename) {
<a name="l03305"></a>03305                 insertFile(conf-&gt;level(), conf-&gt;value());
<a name="l03306"></a>03306             }
<a name="l03307"></a>03307         }
<a name="l03308"></a>03308         <span class="keywordflow">for</span> (std::vector&lt;Configuration*&gt;::iterator conf = withFileSizeLimit.begin();
<a name="l03309"></a>03309                 conf != withFileSizeLimit.end(); ++conf) {
<a name="l03310"></a>03310             <span class="comment">// This is not unsafe as mutex is locked in currect scope</span>
<a name="l03311"></a>03311             unsafeValidateFileRolling((*conf)-&gt;level(), base::defaultPreRollOutCallback);
<a name="l03312"></a>03312         }
<a name="l03313"></a>03313     }
<a name="l03314"></a>03314 
<a name="l03315"></a>03315     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> getULong(std::string confVal)
<a name="l03316"></a>03316     {
<a name="l03317"></a>03317         <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;
<a name="l03318"></a>03318         base::utils::Str::trim(confVal);
<a name="l03319"></a>03319         valid = !confVal.empty() &amp;&amp; std::find_if(confVal.begin(), confVal.end(),
<a name="l03320"></a>03320         [](<span class="keywordtype">char</span> c) { <span class="keywordflow">return</span> !base::utils::Str::isDigit(c); }) == confVal.end();
<a name="l03321"></a>03321         <span class="keywordflow">if</span> (!valid) {
<a name="l03322"></a>03322             valid = <span class="keyword">false</span>;
<a name="l03323"></a>03323             ELPP_ASSERT(valid, <span class="stringliteral">&quot;Configuration value not a valid integer [&quot;</span> &lt;&lt; confVal &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03324"></a>03324             <span class="keywordflow">return</span> 0;
<a name="l03325"></a>03325         }
<a name="l03326"></a>03326         <span class="keywordflow">return</span> atol(confVal.c_str());
<a name="l03327"></a>03327     }
<a name="l03328"></a>03328 
<a name="l03329"></a>03329     std::string resolveFilename(<span class="keyword">const</span> std::string&amp; filename)
<a name="l03330"></a>03330     {
<a name="l03331"></a>03331         std::string resultingFilename = filename;
<a name="l03332"></a>03332         std::size_t dateIndex = std::string::npos;
<a name="l03333"></a>03333         std::string dateTimeFormatSpecifierStr = std::string(base::consts::kDateTimeFormatSpecifierForFilename);
<a name="l03334"></a>03334         <span class="keywordflow">if</span> ((dateIndex = resultingFilename.find(dateTimeFormatSpecifierStr.c_str())) != std::string::npos) {
<a name="l03335"></a>03335             <span class="keywordflow">while</span> (dateIndex &gt; 0 &amp;&amp; resultingFilename[dateIndex - 1] == base::consts::kFormatSpecifierChar) {
<a name="l03336"></a>03336                 dateIndex = resultingFilename.find(dateTimeFormatSpecifierStr.c_str(), dateIndex + 1);
<a name="l03337"></a>03337             }
<a name="l03338"></a>03338             <span class="keywordflow">if</span> (dateIndex != std::string::npos) {
<a name="l03339"></a>03339                 <span class="keyword">const</span> <span class="keywordtype">char</span>* ptr = resultingFilename.c_str() + dateIndex;
<a name="l03340"></a>03340                 <span class="comment">// Goto end of specifier</span>
<a name="l03341"></a>03341                 ptr += dateTimeFormatSpecifierStr.size();
<a name="l03342"></a>03342                 std::string fmt;
<a name="l03343"></a>03343                 <span class="keywordflow">if</span> ((resultingFilename.size() &gt; dateIndex) &amp;&amp; (ptr[0] == <span class="charliteral">&apos;{&apos;</span>)) {
<a name="l03344"></a>03344                     <span class="comment">// User has provided format for date/time</span>
<a name="l03345"></a>03345                     ++ptr;
<a name="l03346"></a>03346                     <span class="keywordtype">int</span> count = 1;  <span class="comment">// Start by 1 in order to remove starting brace</span>
<a name="l03347"></a>03347                     std::stringstream ss;
<a name="l03348"></a>03348                     <span class="keywordflow">for</span> (; *ptr; ++ptr, ++count) {
<a name="l03349"></a>03349                         <span class="keywordflow">if</span> (*ptr == <span class="charliteral">&apos;}&apos;</span>) {
<a name="l03350"></a>03350                             ++count;  <span class="comment">// In order to remove ending brace</span>
<a name="l03351"></a>03351                             <span class="keywordflow">break</span>;
<a name="l03352"></a>03352                         }
<a name="l03353"></a>03353                         ss &lt;&lt; *ptr;
<a name="l03354"></a>03354                     }
<a name="l03355"></a>03355                     resultingFilename.erase(dateIndex + dateTimeFormatSpecifierStr.size(), count);
<a name="l03356"></a>03356                     fmt = ss.str();
<a name="l03357"></a>03357                 } <span class="keywordflow">else</span> {
<a name="l03358"></a>03358                     fmt = std::string(base::consts::kDefaultDateTimeFormatInFilename);
<a name="l03359"></a>03359                 }
<a name="l03360"></a>03360                 base::MillisecondsWidth msWidth(3);
<a name="l03361"></a>03361                 std::string now = base::utils::DateTime::getDateTime(fmt.c_str(), &amp;msWidth);
<a name="l03362"></a>03362                 base::utils::Str::replaceAll(now, <span class="charliteral">&apos;/&apos;</span>, <span class="charliteral">&apos;-&apos;</span>); <span class="comment">// Replace path element since we are dealing with filename</span>
<a name="l03363"></a>03363                 base::utils::Str::replaceAll(resultingFilename, dateTimeFormatSpecifierStr, now);
<a name="l03364"></a>03364             }
<a name="l03365"></a>03365         }
<a name="l03366"></a>03366         <span class="keywordflow">return</span> resultingFilename;
<a name="l03367"></a>03367     }
<a name="l03368"></a>03368 
<a name="l03369"></a>03369     <span class="keywordtype">void</span> insertFile(Level level, <span class="keyword">const</span> std::string&amp; fullFilename)
<a name="l03370"></a>03370     {
<a name="l03371"></a>03371         std::string resolvedFilename = resolveFilename(fullFilename);
<a name="l03372"></a>03372         <span class="keywordflow">if</span> (resolvedFilename.empty()) {
<a name="l03373"></a>03373             std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not load empty file for logging, please re-check your configurations for level [&quot;</span>
<a name="l03374"></a>03374                       &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l03375"></a>03375         }
<a name="l03376"></a>03376         std::string filePath = base::utils::File::extractPathFromFilename(resolvedFilename, base::consts::kFilePathSeperator);
<a name="l03377"></a>03377         <span class="keywordflow">if</span> (filePath.size() &lt; resolvedFilename.size()) {
<a name="l03378"></a>03378             base::utils::File::createPath(filePath);
<a name="l03379"></a>03379         }
<a name="l03380"></a>03380         <span class="keyword">auto</span> create = [&amp;](Level level) {
<a name="l03381"></a>03381             base::LogStreamsReferenceMap::iterator filestreamIter = m_logStreamsReference-&gt;find(resolvedFilename);
<a name="l03382"></a>03382             base::type::fstream_t* fs = <span class="keyword">nullptr</span>;
<a name="l03383"></a>03383             <span class="keywordflow">if</span> (filestreamIter == m_logStreamsReference-&gt;end()) {
<a name="l03384"></a>03384                 <span class="comment">// We need a completely new stream, nothing to share with</span>
<a name="l03385"></a>03385                 fs = base::utils::File::newFileStream(resolvedFilename);
<a name="l03386"></a>03386                 m_filenameMap.insert(std::make_pair(level, resolvedFilename));
<a name="l03387"></a>03387                 m_fileStreamMap.insert(std::make_pair(level, base::FileStreamPtr(fs)));
<a name="l03388"></a>03388                 m_logStreamsReference-&gt;insert(std::make_pair(resolvedFilename, base::FileStreamPtr(m_fileStreamMap.at(level))));
<a name="l03389"></a>03389             } <span class="keywordflow">else</span> {
<a name="l03390"></a>03390                 <span class="comment">// Woops! we have an existing one, share it!</span>
<a name="l03391"></a>03391                 m_filenameMap.insert(std::make_pair(level, filestreamIter-&gt;first));
<a name="l03392"></a>03392                 m_fileStreamMap.insert(std::make_pair(level, base::FileStreamPtr(filestreamIter-&gt;second)));
<a name="l03393"></a>03393                 fs = filestreamIter-&gt;second.get();
<a name="l03394"></a>03394             }
<a name="l03395"></a>03395             <span class="keywordflow">if</span> (fs == <span class="keyword">nullptr</span>) {
<a name="l03396"></a>03396                 <span class="comment">// We display bad file error from newFileStream()</span>
<a name="l03397"></a>03397                 ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Setting [TO_FILE] of [&quot;</span>
<a name="l03398"></a>03398                                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; <span class="stringliteral">&quot;] to FALSE&quot;</span>, <span class="keyword">false</span>);
<a name="l03399"></a>03399                 setValue(level, <span class="keyword">false</span>, &amp;m_toFileMap);
<a name="l03400"></a>03400             }
<a name="l03401"></a>03401         };
<a name="l03402"></a>03402         <span class="comment">// If we dont have file conf for any level, create it for Level::Global first</span>
<a name="l03403"></a>03403         <span class="comment">// otherwise create for specified level</span>
<a name="l03404"></a>03404         create(m_filenameMap.empty() &amp;&amp; m_fileStreamMap.empty() ? Level::Global : level);
<a name="l03405"></a>03405     }
<a name="l03406"></a>03406 
<a name="l03407"></a>03407     <span class="keywordtype">bool</span> unsafeValidateFileRolling(Level level, <span class="keyword">const</span> PreRollOutCallback&amp; PreRollOutCallback)
<a name="l03408"></a>03408     {
<a name="l03409"></a>03409         base::type::fstream_t* fs = unsafeGetConfigByRef(level, &amp;m_fileStreamMap, <span class="stringliteral">&quot;fileStream&quot;</span>).get();
<a name="l03410"></a>03410         <span class="keywordflow">if</span> (fs == <span class="keyword">nullptr</span>) {
<a name="l03411"></a>03411             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03412"></a>03412         }
<a name="l03413"></a>03413         std::size_t maxLogFileSize = unsafeGetConfigByVal(level, &amp;m_maxLogFileSizeMap, <span class="stringliteral">&quot;maxLogFileSize&quot;</span>);
<a name="l03414"></a>03414         std::size_t currFileSize = base::utils::File::getSizeOfFile(fs);
<a name="l03415"></a>03415         <span class="keywordflow">if</span> (maxLogFileSize != 0 &amp;&amp; currFileSize &gt;= maxLogFileSize) {
<a name="l03416"></a>03416             std::string fname = unsafeGetConfigByRef(level, &amp;m_filenameMap, <span class="stringliteral">&quot;filename&quot;</span>);
<a name="l03417"></a>03417             ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Truncating log file [&quot;</span> &lt;&lt; fname &lt;&lt; <span class="stringliteral">&quot;] as a result of configurations for level [&quot;</span>
<a name="l03418"></a>03418                                &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03419"></a>03419             fs-&gt;close();
<a name="l03420"></a>03420             PreRollOutCallback(fname.c_str(), currFileSize);
<a name="l03421"></a>03421             fs-&gt;open(fname, std::fstream::out | std::fstream::trunc);
<a name="l03422"></a>03422             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03423"></a>03423         }
<a name="l03424"></a>03424         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03425"></a>03425     }
<a name="l03426"></a>03426 
<a name="l03427"></a>03427     <span class="keywordtype">bool</span> validateFileRolling(Level level, <span class="keyword">const</span> PreRollOutCallback&amp; PreRollOutCallback)
<a name="l03428"></a>03428     {
<a name="l03429"></a>03429         base::threading::ScopedLock scopedLock(lock());
<a name="l03430"></a>03430         <span class="keywordflow">return</span> unsafeValidateFileRolling(level, PreRollOutCallback);
<a name="l03431"></a>03431     }
<a name="l03432"></a>03432 };
<a name="l03434"></a>03434 <span class="keyword">class </span>HitCounter
<a name="l03435"></a>03435 {
<a name="l03436"></a>03436 <span class="keyword">public</span>:
<a name="l03437"></a>03437     HitCounter(<span class="keywordtype">void</span>) :
<a name="l03438"></a>03438         m_filename(<span class="stringliteral">&quot;&quot;</span>),
<a name="l03439"></a>03439         m_lineNumber(0),
<a name="l03440"></a>03440         m_hitCounts(0)
<a name="l03441"></a>03441     {
<a name="l03442"></a>03442     }
<a name="l03443"></a>03443 
<a name="l03444"></a>03444     HitCounter(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber) :
<a name="l03445"></a>03445         m_filename(filename),
<a name="l03446"></a>03446         m_lineNumber(lineNumber),
<a name="l03447"></a>03447         m_hitCounts(0)
<a name="l03448"></a>03448     {
<a name="l03449"></a>03449     }
<a name="l03450"></a>03450 
<a name="l03451"></a>03451     HitCounter(<span class="keyword">const</span> HitCounter&amp; hitCounter) :
<a name="l03452"></a>03452         m_filename(hitCounter.m_filename),
<a name="l03453"></a>03453         m_lineNumber(hitCounter.m_lineNumber),
<a name="l03454"></a>03454         m_hitCounts(hitCounter.m_hitCounts)
<a name="l03455"></a>03455     {
<a name="l03456"></a>03456     }
<a name="l03457"></a>03457 
<a name="l03458"></a>03458     HitCounter&amp; operator=(<span class="keyword">const</span> HitCounter&amp; hitCounter)
<a name="l03459"></a>03459     {
<a name="l03460"></a>03460         m_filename = hitCounter.m_filename;
<a name="l03461"></a>03461         m_lineNumber = hitCounter.m_lineNumber;
<a name="l03462"></a>03462         m_hitCounts = hitCounter.m_hitCounts;
<a name="l03463"></a>03463         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03464"></a>03464     }
<a name="l03465"></a>03465 
<a name="l03466"></a>03466     <span class="keyword">virtual</span> ~HitCounter(<span class="keywordtype">void</span>)
<a name="l03467"></a>03467     {
<a name="l03468"></a>03468     }
<a name="l03469"></a>03469 
<a name="l03471"></a>03471     <span class="keyword">inline</span> <span class="keywordtype">void</span> resetLocation(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber)
<a name="l03472"></a>03472     {
<a name="l03473"></a>03473         m_filename = filename;
<a name="l03474"></a>03474         m_lineNumber = lineNumber;
<a name="l03475"></a>03475     }
<a name="l03476"></a>03476 
<a name="l03478"></a>03478     <span class="keyword">inline</span> <span class="keywordtype">void</span> validateHitCounts(std::size_t n)
<a name="l03479"></a>03479     {
<a name="l03480"></a>03480         <span class="keywordflow">if</span> (m_hitCounts &gt;= base::consts::kMaxLogPerCounter) {
<a name="l03481"></a>03481             m_hitCounts = (n &gt;= 1 ? base::consts::kMaxLogPerCounter % n : 0);
<a name="l03482"></a>03482         }
<a name="l03483"></a>03483         ++m_hitCounts;
<a name="l03484"></a>03484     }
<a name="l03485"></a>03485 
<a name="l03486"></a>03486     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* filename(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03487"></a>03487 <span class="keyword">    </span>{
<a name="l03488"></a>03488         <span class="keywordflow">return</span> m_filename;
<a name="l03489"></a>03489     }
<a name="l03490"></a>03490 
<a name="l03491"></a>03491     <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03492"></a>03492 <span class="keyword">    </span>{
<a name="l03493"></a>03493         <span class="keywordflow">return</span> m_lineNumber;
<a name="l03494"></a>03494     }
<a name="l03495"></a>03495 
<a name="l03496"></a>03496     <span class="keyword">inline</span> std::size_t hitCounts(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03497"></a>03497 <span class="keyword">    </span>{
<a name="l03498"></a>03498         <span class="keywordflow">return</span> m_hitCounts;
<a name="l03499"></a>03499     }
<a name="l03500"></a>03500 
<a name="l03501"></a>03501     <span class="keyword">inline</span> <span class="keywordtype">void</span> increment(<span class="keywordtype">void</span>)
<a name="l03502"></a>03502     {
<a name="l03503"></a>03503         ++m_hitCounts;
<a name="l03504"></a>03504     }
<a name="l03505"></a>03505 
<a name="l03506"></a>03506     <span class="keyword">class </span>Predicate
<a name="l03507"></a>03507     {
<a name="l03508"></a>03508     <span class="keyword">public</span>:
<a name="l03509"></a>03509         Predicate(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber)
<a name="l03510"></a>03510             : m_filename(filename),
<a name="l03511"></a>03511               m_lineNumber(lineNumber)
<a name="l03512"></a>03512         {
<a name="l03513"></a>03513         }
<a name="l03514"></a>03514         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> HitCounter* counter)
<a name="l03515"></a>03515         {
<a name="l03516"></a>03516             <span class="keywordflow">return</span> ((counter != <span class="keyword">nullptr</span>) &amp;&amp;
<a name="l03517"></a>03517                     (strcmp(counter-&gt;m_filename, m_filename) == 0) &amp;&amp;
<a name="l03518"></a>03518                     (counter-&gt;m_lineNumber == m_lineNumber));
<a name="l03519"></a>03519         }
<a name="l03520"></a>03520 
<a name="l03521"></a>03521     <span class="keyword">private</span>:
<a name="l03522"></a>03522         <span class="keyword">const</span> <span class="keywordtype">char</span>* m_filename;
<a name="l03523"></a>03523         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> m_lineNumber;
<a name="l03524"></a>03524     };
<a name="l03525"></a>03525 
<a name="l03526"></a>03526 <span class="keyword">private</span>:
<a name="l03527"></a>03527     <span class="keyword">const</span> <span class="keywordtype">char</span>* m_filename;
<a name="l03528"></a>03528     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> m_lineNumber;
<a name="l03529"></a>03529     std::size_t m_hitCounts;
<a name="l03530"></a>03530 };
<a name="l03532"></a>03532 <span class="keyword">class </span>RegisteredHitCounters : <span class="keyword">public</span> base::utils::RegistryWithPred&lt;base::HitCounter, base::HitCounter::Predicate&gt;
<a name="l03533"></a>03533 {
<a name="l03534"></a>03534 <span class="keyword">public</span>:
<a name="l03537"></a>03537     <span class="keywordtype">bool</span> validateEveryN(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber, std::size_t n)
<a name="l03538"></a>03538     {
<a name="l03539"></a>03539         base::threading::ScopedLock scopedLock(lock());
<a name="l03540"></a>03540         base::HitCounter* counter = <span class="keyword">get</span>(filename, lineNumber);
<a name="l03541"></a>03541         <span class="keywordflow">if</span> (counter == <span class="keyword">nullptr</span>) {
<a name="l03542"></a>03542             registerNew(counter = <span class="keyword">new</span> base::HitCounter(filename, lineNumber));
<a name="l03543"></a>03543         }
<a name="l03544"></a>03544         counter-&gt;validateHitCounts(n);
<a name="l03545"></a>03545         <span class="keywordtype">bool</span> result = (n &gt;= 1 &amp;&amp; counter-&gt;hitCounts() != 0 &amp;&amp; counter-&gt;hitCounts() % n == 0);
<a name="l03546"></a>03546         <span class="keywordflow">return</span> result;
<a name="l03547"></a>03547     }
<a name="l03548"></a>03548 
<a name="l03551"></a>03551     <span class="keywordtype">bool</span> validateAfterN(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber, std::size_t n)
<a name="l03552"></a>03552     {
<a name="l03553"></a>03553         base::threading::ScopedLock scopedLock(lock());
<a name="l03554"></a>03554         base::HitCounter* counter = <span class="keyword">get</span>(filename, lineNumber);
<a name="l03555"></a>03555         <span class="keywordflow">if</span> (counter == <span class="keyword">nullptr</span>) {
<a name="l03556"></a>03556             registerNew(counter = <span class="keyword">new</span> base::HitCounter(filename, lineNumber));
<a name="l03557"></a>03557         }
<a name="l03558"></a>03558         <span class="comment">// Do not use validateHitCounts here since we do not want to reset counter here</span>
<a name="l03559"></a>03559         <span class="comment">// Note the &gt;= instead of &gt; because we are incrementing</span>
<a name="l03560"></a>03560         <span class="comment">// after this check</span>
<a name="l03561"></a>03561         <span class="keywordflow">if</span> (counter-&gt;hitCounts() &gt;= n)
<a name="l03562"></a>03562             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03563"></a>03563         counter-&gt;increment();
<a name="l03564"></a>03564         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03565"></a>03565     }
<a name="l03566"></a>03566 
<a name="l03569"></a>03569     <span class="keywordtype">bool</span> validateNTimes(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber, std::size_t n)
<a name="l03570"></a>03570     {
<a name="l03571"></a>03571         base::threading::ScopedLock scopedLock(lock());
<a name="l03572"></a>03572         base::HitCounter* counter = <span class="keyword">get</span>(filename, lineNumber);
<a name="l03573"></a>03573         <span class="keywordflow">if</span> (counter == <span class="keyword">nullptr</span>) {
<a name="l03574"></a>03574             registerNew(counter = <span class="keyword">new</span> base::HitCounter(filename, lineNumber));
<a name="l03575"></a>03575         }
<a name="l03576"></a>03576         counter-&gt;increment();
<a name="l03577"></a>03577         <span class="comment">// Do not use validateHitCounts here since we do not want to reset counter here</span>
<a name="l03578"></a>03578         <span class="keywordflow">if</span> (counter-&gt;hitCounts() &lt;= n)
<a name="l03579"></a>03579             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03580"></a>03580         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03581"></a>03581     }
<a name="l03582"></a>03582 
<a name="l03584"></a>03584     <span class="keyword">inline</span> <span class="keyword">const</span> base::HitCounter* getCounter(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber)
<a name="l03585"></a>03585     {
<a name="l03586"></a>03586         base::threading::ScopedLock scopedLock(lock());
<a name="l03587"></a>03587         <span class="keywordflow">return</span> <span class="keyword">get</span>(filename, lineNumber);
<a name="l03588"></a>03588     }
<a name="l03589"></a>03589 };
<a name="l03591"></a>03591 <span class="keyword">enum class</span> DispatchAction : base::type::EnumType {
<a name="l03592"></a>03592     None = 1, NormalLog = 2, SysLog = 4
<a name="l03593"></a>03593 };
<a name="l03594"></a>03594 }  <span class="comment">// namespace base</span>
<a name="l03595"></a>03595 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l03596"></a>03596 <span class="keyword">class </span>Callback : <span class="keyword">protected</span> base::threading::ThreadSafe
<a name="l03597"></a>03597 {
<a name="l03598"></a>03598 <span class="keyword">public</span>:
<a name="l03599"></a>03599     Callback(<span class="keywordtype">void</span>) : m_enabled(true) {}
<a name="l03600"></a>03600     <span class="keyword">inline</span> <span class="keywordtype">bool</span> enabled(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_enabled; }
<a name="l03601"></a>03601     <span class="keyword">inline</span> <span class="keywordtype">void</span> setEnabled(<span class="keywordtype">bool</span> enabled)
<a name="l03602"></a>03602     {
<a name="l03603"></a>03603         base::threading::ScopedLock scopedLock(lock());
<a name="l03604"></a>03604         m_enabled = enabled;
<a name="l03605"></a>03605     }
<a name="l03606"></a>03606 <span class="keyword">protected</span>:
<a name="l03607"></a>03607     <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(<span class="keyword">const</span> T* handlePtr) = 0;
<a name="l03608"></a>03608 <span class="keyword">private</span>:
<a name="l03609"></a>03609     <span class="keywordtype">bool</span> m_enabled;
<a name="l03610"></a>03610 };
<a name="l03611"></a>03611 <span class="keyword">class </span>LogDispatchData
<a name="l03612"></a>03612 {
<a name="l03613"></a>03613 <span class="keyword">public</span>:
<a name="l03614"></a>03614     LogDispatchData() : m_logMessage(nullptr), m_dispatchAction(base::DispatchAction::None) {}
<a name="l03615"></a>03615     <span class="keyword">inline</span> <span class="keyword">const</span> LogMessage* logMessage(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_logMessage; }
<a name="l03616"></a>03616     <span class="keyword">inline</span> base::DispatchAction dispatchAction(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_dispatchAction; }
<a name="l03617"></a>03617 <span class="keyword">private</span>:
<a name="l03618"></a>03618     LogMessage* m_logMessage;
<a name="l03619"></a>03619     base::DispatchAction m_dispatchAction;
<a name="l03620"></a>03620     <span class="keyword">friend</span> <span class="keyword">class </span>base::LogDispatcher;
<a name="l03621"></a>03621 
<a name="l03622"></a>03622     <span class="keyword">inline</span> <span class="keywordtype">void</span> setLogMessage(LogMessage* logMessage) { m_logMessage = logMessage; }
<a name="l03623"></a>03623     <span class="keyword">inline</span> <span class="keywordtype">void</span> setDispatchAction(base::DispatchAction dispatchAction) { m_dispatchAction = dispatchAction; }
<a name="l03624"></a>03624 };
<a name="l03625"></a>03625 <span class="keyword">class </span>LogDispatchCallback : <span class="keyword">public</span> Callback&lt;LogDispatchData&gt;
<a name="l03626"></a>03626 {
<a name="l03627"></a>03627 <span class="keyword">private</span>:
<a name="l03628"></a>03628     <span class="keyword">friend</span> <span class="keyword">class </span>base::LogDispatcher;
<a name="l03629"></a>03629 };
<a name="l03630"></a>03630 <span class="keyword">class </span>PerformanceTrackingCallback : <span class="keyword">public</span> Callback&lt;PerformanceTrackingData&gt;
<a name="l03631"></a>03631 {
<a name="l03632"></a>03632 <span class="keyword">private</span>:
<a name="l03633"></a>03633     <span class="keyword">friend</span> <span class="keyword">class </span>base::PerformanceTracker;
<a name="l03634"></a>03634 };
<a name="l03635"></a>03635 <span class="keyword">class </span>LogBuilder : base::NoCopy
<a name="l03636"></a>03636 {
<a name="l03637"></a>03637 <span class="keyword">public</span>:
<a name="l03638"></a>03638     <span class="keyword">virtual</span> ~LogBuilder(<span class="keywordtype">void</span>) { ELPP_INTERNAL_INFO(3, <span class="stringliteral">&quot;Destroying log builder...&quot;</span>)}
<a name="l03639"></a>03639     <span class="keyword">virtual</span> base::type::string_t build(<span class="keyword">const</span> LogMessage* logMessage, <span class="keywordtype">bool</span> appendNewLine) <span class="keyword">const</span> = 0;
<a name="l03640"></a>03640     <span class="keywordtype">void</span> convertToColoredOutput(base::type::string_t* logLine, Level level)
<a name="l03641"></a>03641     {
<a name="l03642"></a>03642         <span class="keywordflow">if</span> (!base::utils::s_termSupportsColor) <span class="keywordflow">return</span>;
<a name="l03643"></a>03643         <span class="keyword">const</span> base::type::char_t* resetColor = ELPP_LITERAL(<span class="stringliteral">&quot;\x1b[0m&quot;</span>);
<a name="l03644"></a>03644         <span class="keywordflow">if</span> (level == Level::Error || level == Level::Fatal)
<a name="l03645"></a>03645             *logLine = ELPP_LITERAL(<span class="stringliteral">&quot;\x1b[31m&quot;</span>) + *logLine + resetColor;
<a name="l03646"></a>03646         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (level == Level::Warning)
<a name="l03647"></a>03647             *logLine = ELPP_LITERAL(<span class="stringliteral">&quot;\x1b[33m&quot;</span>) + *logLine + resetColor;
<a name="l03648"></a>03648     }
<a name="l03649"></a>03649 <span class="keyword">private</span>:
<a name="l03650"></a>03650     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::DefaultLogDispatchCallback;
<a name="l03651"></a>03651 };
<a name="l03652"></a>03652 <span class="keyword">typedef</span> std::shared_ptr&lt;LogBuilder&gt; LogBuilderPtr;
<a name="l03656"></a>03656 <span class="keyword">class </span>Logger : <span class="keyword">public</span> base::threading::ThreadSafe, <span class="keyword">public</span> Loggable
<a name="l03657"></a>03657 {
<a name="l03658"></a>03658 <span class="keyword">public</span>:
<a name="l03659"></a>03659     Logger(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, base::LogStreamsReferenceMap* logStreamsReference) :
<a name="l03660"></a>03660         m_id(id),
<a name="l03661"></a>03661         m_typedConfigurations(nullptr),
<a name="l03662"></a>03662         m_parentApplicationName(std::string()),
<a name="l03663"></a>03663         m_isConfigured(false),
<a name="l03664"></a>03664         m_logStreamsReference(logStreamsReference)
<a name="l03665"></a>03665     {
<a name="l03666"></a>03666         initUnflushedCount();
<a name="l03667"></a>03667     }
<a name="l03668"></a>03668 
<a name="l03669"></a>03669     Logger(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, <span class="keyword">const</span> Configurations&amp; configurations, base::LogStreamsReferenceMap* logStreamsReference) :
<a name="l03670"></a>03670         m_id(id),
<a name="l03671"></a>03671         m_typedConfigurations(nullptr),
<a name="l03672"></a>03672         m_parentApplicationName(std::string()),
<a name="l03673"></a>03673         m_isConfigured(false),
<a name="l03674"></a>03674         m_logStreamsReference(logStreamsReference)
<a name="l03675"></a>03675     {
<a name="l03676"></a>03676         initUnflushedCount();
<a name="l03677"></a>03677         configure(configurations);
<a name="l03678"></a>03678     }
<a name="l03679"></a>03679 
<a name="l03680"></a>03680     Logger(<span class="keyword">const</span> Logger&amp; logger)
<a name="l03681"></a>03681     {
<a name="l03682"></a>03682         base::utils::safeDelete(m_typedConfigurations);
<a name="l03683"></a>03683         m_id = logger.m_id;
<a name="l03684"></a>03684         m_typedConfigurations = logger.m_typedConfigurations;
<a name="l03685"></a>03685         m_parentApplicationName = logger.m_parentApplicationName;
<a name="l03686"></a>03686         m_isConfigured = logger.m_isConfigured;
<a name="l03687"></a>03687         m_configurations = logger.m_configurations;
<a name="l03688"></a>03688         m_unflushedCount = logger.m_unflushedCount;
<a name="l03689"></a>03689         m_logStreamsReference = logger.m_logStreamsReference;
<a name="l03690"></a>03690     }
<a name="l03691"></a>03691 
<a name="l03692"></a>03692     Logger&amp; operator=(<span class="keyword">const</span> Logger&amp; logger)
<a name="l03693"></a>03693     {
<a name="l03694"></a>03694         base::utils::safeDelete(m_typedConfigurations);
<a name="l03695"></a>03695         m_id = logger.m_id;
<a name="l03696"></a>03696         m_typedConfigurations = logger.m_typedConfigurations;
<a name="l03697"></a>03697         m_parentApplicationName = logger.m_parentApplicationName;
<a name="l03698"></a>03698         m_isConfigured = logger.m_isConfigured;
<a name="l03699"></a>03699         m_configurations = logger.m_configurations;
<a name="l03700"></a>03700         m_unflushedCount = logger.m_unflushedCount;
<a name="l03701"></a>03701         m_logStreamsReference = logger.m_logStreamsReference;
<a name="l03702"></a>03702         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03703"></a>03703     }
<a name="l03704"></a>03704 
<a name="l03705"></a>03705     <span class="keyword">virtual</span> ~Logger(<span class="keywordtype">void</span>)
<a name="l03706"></a>03706     {
<a name="l03707"></a>03707         base::utils::safeDelete(m_typedConfigurations);
<a name="l03708"></a>03708     }
<a name="l03709"></a>03709 
<a name="l03710"></a>03710     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> log(el::base::type::ostream_t&amp; os)<span class="keyword"> const</span>
<a name="l03711"></a>03711 <span class="keyword">    </span>{
<a name="l03712"></a>03712         os &lt;&lt; m_id.c_str();
<a name="l03713"></a>03713     }
<a name="l03714"></a>03714 
<a name="l03716"></a>03716     <span class="keywordtype">void</span> configure(<span class="keyword">const</span> Configurations&amp; configurations)
<a name="l03717"></a>03717     {
<a name="l03718"></a>03718         m_isConfigured = <span class="keyword">false</span>;  <span class="comment">// we set it to false in case if we fail</span>
<a name="l03719"></a>03719         initUnflushedCount();
<a name="l03720"></a>03720         <span class="keywordflow">if</span> (m_typedConfigurations != <span class="keyword">nullptr</span>) {
<a name="l03721"></a>03721             Configurations* c = <span class="keyword">const_cast&lt;</span>Configurations*<span class="keyword">&gt;</span>(m_typedConfigurations-&gt;configurations());
<a name="l03722"></a>03722             <span class="keywordflow">if</span> (c-&gt;hasConfiguration(Level::Global, ConfigurationType::Filename)) {
<a name="l03723"></a>03723                 <span class="comment">// This check is definitely needed for cases like ELPP_NO_DEFAULT_LOG_FILE</span>
<a name="l03724"></a>03724                 flush();
<a name="l03725"></a>03725             }
<a name="l03726"></a>03726         }
<a name="l03727"></a>03727         base::threading::ScopedLock scopedLock(lock());
<a name="l03728"></a>03728         <span class="keywordflow">if</span> (m_configurations != configurations) {
<a name="l03729"></a>03729             m_configurations.setFromBase(const_cast&lt;Configurations*&gt;(&amp;configurations));
<a name="l03730"></a>03730         }
<a name="l03731"></a>03731         base::utils::safeDelete(m_typedConfigurations);
<a name="l03732"></a>03732         m_typedConfigurations = <span class="keyword">new</span> base::TypedConfigurations(&amp;m_configurations, m_logStreamsReference);
<a name="l03733"></a>03733         resolveLoggerFormatSpec();
<a name="l03734"></a>03734         m_isConfigured = <span class="keyword">true</span>;
<a name="l03735"></a>03735     }
<a name="l03736"></a>03736 
<a name="l03738"></a>03738     <span class="keyword">inline</span> <span class="keywordtype">void</span> reconfigure(<span class="keywordtype">void</span>)
<a name="l03739"></a>03739     {
<a name="l03740"></a>03740         ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Reconfiguring logger [&quot;</span> &lt;&lt; m_id &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>);
<a name="l03741"></a>03741         configure(m_configurations);
<a name="l03742"></a>03742     }
<a name="l03743"></a>03743 
<a name="l03744"></a>03744     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; id(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03745"></a>03745 <span class="keyword">    </span>{
<a name="l03746"></a>03746         <span class="keywordflow">return</span> m_id;
<a name="l03747"></a>03747     }
<a name="l03748"></a>03748 
<a name="l03749"></a>03749     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; parentApplicationName(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03750"></a>03750 <span class="keyword">    </span>{
<a name="l03751"></a>03751         <span class="keywordflow">return</span> m_parentApplicationName;
<a name="l03752"></a>03752     }
<a name="l03753"></a>03753 
<a name="l03754"></a>03754     <span class="keyword">inline</span> <span class="keywordtype">void</span> setParentApplicationName(<span class="keyword">const</span> std::string&amp; parentApplicationName)
<a name="l03755"></a>03755     {
<a name="l03756"></a>03756         m_parentApplicationName = parentApplicationName;
<a name="l03757"></a>03757     }
<a name="l03758"></a>03758 
<a name="l03759"></a>03759     <span class="keyword">inline</span> Configurations* configurations(<span class="keywordtype">void</span>)
<a name="l03760"></a>03760     {
<a name="l03761"></a>03761         <span class="keywordflow">return</span> &amp;m_configurations;
<a name="l03762"></a>03762     }
<a name="l03763"></a>03763 
<a name="l03764"></a>03764     <span class="keyword">inline</span> base::TypedConfigurations* typedConfigurations(<span class="keywordtype">void</span>)
<a name="l03765"></a>03765     {
<a name="l03766"></a>03766         <span class="keywordflow">return</span> m_typedConfigurations;
<a name="l03767"></a>03767     }
<a name="l03768"></a>03768 
<a name="l03769"></a>03769     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isValidId(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l03770"></a>03770     {
<a name="l03771"></a>03771         <span class="keywordflow">for</span> (std::string::const_iterator it = <span class="keywordtype">id</span>.begin(); it != <span class="keywordtype">id</span>.end(); ++it) {
<a name="l03772"></a>03772             <span class="keywordflow">if</span> (!base::utils::Str::contains(base::consts::kValidLoggerIdSymbols, *it)) {
<a name="l03773"></a>03773                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03774"></a>03774             }
<a name="l03775"></a>03775         }
<a name="l03776"></a>03776         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03777"></a>03777     }
<a name="l03779"></a>03779     <span class="keyword">inline</span> <span class="keywordtype">void</span> flush(<span class="keywordtype">void</span>)
<a name="l03780"></a>03780     {
<a name="l03781"></a>03781         ELPP_INTERNAL_INFO(3, <span class="stringliteral">&quot;Flushing logger [&quot;</span> &lt;&lt; m_id &lt;&lt; <span class="stringliteral">&quot;] all levels&quot;</span>);
<a name="l03782"></a>03782         base::threading::ScopedLock scopedLock(lock());
<a name="l03783"></a>03783         base::type::EnumType lIndex = LevelHelper::kMinValid;
<a name="l03784"></a>03784         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](<span class="keywordtype">void</span>) -&gt; <span class="keywordtype">bool</span> {
<a name="l03785"></a>03785             flush(LevelHelper::castFromInt(lIndex), <span class="keyword">nullptr</span>);
<a name="l03786"></a>03786             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03787"></a>03787         });
<a name="l03788"></a>03788     }
<a name="l03789"></a>03789 
<a name="l03790"></a>03790     <span class="keyword">inline</span> <span class="keywordtype">void</span> flush(Level level, base::type::fstream_t* fs)
<a name="l03791"></a>03791     {
<a name="l03792"></a>03792         <span class="keywordflow">if</span> (fs == <span class="keyword">nullptr</span> &amp;&amp; m_typedConfigurations-&gt;toFile(level)) {
<a name="l03793"></a>03793             fs = m_typedConfigurations-&gt;fileStream(level);
<a name="l03794"></a>03794         }
<a name="l03795"></a>03795         <span class="keywordflow">if</span> (fs != <span class="keyword">nullptr</span>) {
<a name="l03796"></a>03796             fs-&gt;flush();
<a name="l03797"></a>03797             m_unflushedCount.find(level)-&gt;second = 0;
<a name="l03798"></a>03798         }
<a name="l03799"></a>03799     }
<a name="l03800"></a>03800 
<a name="l03801"></a>03801     <span class="keyword">inline</span> <span class="keywordtype">bool</span> isFlushNeeded(Level level)
<a name="l03802"></a>03802     {
<a name="l03803"></a>03803         <span class="keywordflow">return</span> ++m_unflushedCount.find(level)-&gt;second &gt;= m_typedConfigurations-&gt;logFlushThreshold(level);
<a name="l03804"></a>03804     }
<a name="l03805"></a>03805 
<a name="l03806"></a>03806     <span class="keyword">inline</span> LogBuilder* logBuilder(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03807"></a>03807 <span class="keyword">    </span>{
<a name="l03808"></a>03808         <span class="keywordflow">return</span> m_logBuilder.get();
<a name="l03809"></a>03809     }
<a name="l03810"></a>03810 
<a name="l03811"></a>03811     <span class="keyword">inline</span> <span class="keywordtype">void</span> setLogBuilder(<span class="keyword">const</span> LogBuilderPtr&amp; logBuilder)
<a name="l03812"></a>03812     {
<a name="l03813"></a>03813         m_logBuilder = logBuilder;
<a name="l03814"></a>03814     }
<a name="l03815"></a>03815 
<a name="l03816"></a>03816     <span class="keyword">inline</span> <span class="keywordtype">bool</span> enabled(Level level)<span class="keyword"> const</span>
<a name="l03817"></a>03817 <span class="keyword">    </span>{
<a name="l03818"></a>03818         <span class="keywordflow">return</span> m_typedConfigurations-&gt;enabled(level);
<a name="l03819"></a>03819     }
<a name="l03820"></a>03820 
<a name="l03821"></a>03821 <span class="preprocessor">#if ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l03822"></a>03822 <span class="preprocessor"></span><span class="preprocessor">#   define LOGGER_LEVEL_WRITERS_SIGNATURES(FUNCTION_NAME)\</span>
<a name="l03823"></a>03823 <span class="preprocessor">    template &lt;typename T, typename... Args&gt;\</span>
<a name="l03824"></a>03824 <span class="preprocessor">    inline void FUNCTION_NAME(const char*, const T&amp;, const Args&amp;...);\</span>
<a name="l03825"></a>03825 <span class="preprocessor">    template &lt;typename T&gt;\</span>
<a name="l03826"></a>03826 <span class="preprocessor">    inline void FUNCTION_NAME(const T&amp;);</span>
<a name="l03827"></a>03827 <span class="preprocessor"></span>
<a name="l03828"></a>03828     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l03829"></a>03829     <span class="keyword">inline</span> <span class="keywordtype">void</span> verbose(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> Args&amp; ...);
<a name="l03830"></a>03830 
<a name="l03831"></a>03831     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l03832"></a>03832     <span class="keyword">inline</span> <span class="keywordtype">void</span> verbose(<span class="keywordtype">int</span>, <span class="keyword">const</span> T&amp;);
<a name="l03833"></a>03833 
<a name="l03834"></a>03834     LOGGER_LEVEL_WRITERS_SIGNATURES(info)
<a name="l03835"></a>03835     LOGGER_LEVEL_WRITERS_SIGNATURES(debug)
<a name="l03836"></a>03836     LOGGER_LEVEL_WRITERS_SIGNATURES(warn)
<a name="l03837"></a>03837     LOGGER_LEVEL_WRITERS_SIGNATURES(error)
<a name="l03838"></a>03838     LOGGER_LEVEL_WRITERS_SIGNATURES(fatal)
<a name="l03839"></a>03839     LOGGER_LEVEL_WRITERS_SIGNATURES(trace)
<a name="l03840"></a>03840 <span class="preprocessor">#   undef LOGGER_LEVEL_WRITERS_SIGNATURES</span>
<a name="l03841"></a>03841 <span class="preprocessor"></span><span class="preprocessor">#endif // ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l03842"></a>03842 <span class="preprocessor"></span><span class="keyword">private</span>:
<a name="l03843"></a>03843     std::string m_id;
<a name="l03844"></a>03844     base::TypedConfigurations* m_typedConfigurations;
<a name="l03845"></a>03845     base::type::stringstream_t m_stream;
<a name="l03846"></a>03846     std::string m_parentApplicationName;
<a name="l03847"></a>03847     <span class="keywordtype">bool</span> m_isConfigured;
<a name="l03848"></a>03848     Configurations m_configurations;
<a name="l03849"></a>03849     std::map&lt;Level, unsigned int&gt; m_unflushedCount;
<a name="l03850"></a>03850     base::LogStreamsReferenceMap* m_logStreamsReference;
<a name="l03851"></a>03851     LogBuilderPtr m_logBuilder;
<a name="l03852"></a>03852 
<a name="l03853"></a>03853     <span class="keyword">friend</span> <span class="keyword">class </span>el::LogMessage;
<a name="l03854"></a>03854     <span class="keyword">friend</span> <span class="keyword">class </span>el::Loggers;
<a name="l03855"></a>03855     <span class="keyword">friend</span> <span class="keyword">class </span>el::Helpers;
<a name="l03856"></a>03856     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::RegisteredLoggers;
<a name="l03857"></a>03857     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::DefaultLogDispatchCallback;
<a name="l03858"></a>03858     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::MessageBuilder;
<a name="l03859"></a>03859     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::Writer;
<a name="l03860"></a>03860     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::PErrorWriter;
<a name="l03861"></a>03861     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::Storage;
<a name="l03862"></a>03862     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::PerformanceTracker;
<a name="l03863"></a>03863     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::LogDispatcher;
<a name="l03864"></a>03864 
<a name="l03865"></a>03865     Logger(<span class="keywordtype">void</span>);
<a name="l03866"></a>03866 
<a name="l03867"></a>03867 <span class="preprocessor">#if ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l03868"></a>03868 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l03869"></a>03869     <span class="keywordtype">void</span> log_(Level, <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> Args&amp; ...);
<a name="l03870"></a>03870 
<a name="l03871"></a>03871     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l03872"></a>03872     <span class="keyword">inline</span> <span class="keywordtype">void</span> log_(Level, <span class="keywordtype">int</span>, <span class="keyword">const</span> T&amp;);
<a name="l03873"></a>03873 
<a name="l03874"></a>03874     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l03875"></a>03875     <span class="keywordtype">void</span> log(Level, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> Args&amp; ...);
<a name="l03876"></a>03876 
<a name="l03877"></a>03877     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l03878"></a>03878     <span class="keyword">inline</span> <span class="keywordtype">void</span> log(Level, <span class="keyword">const</span> T&amp;);
<a name="l03879"></a>03879 <span class="preprocessor">#endif // ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l03880"></a>03880 <span class="preprocessor"></span>
<a name="l03881"></a>03881     <span class="keywordtype">void</span> initUnflushedCount(<span class="keywordtype">void</span>)
<a name="l03882"></a>03882     {
<a name="l03883"></a>03883         m_unflushedCount.clear();
<a name="l03884"></a>03884         base::type::EnumType lIndex = LevelHelper::kMinValid;
<a name="l03885"></a>03885         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](<span class="keywordtype">void</span>) -&gt; <span class="keywordtype">bool</span> {
<a name="l03886"></a>03886             m_unflushedCount.insert(std::make_pair(LevelHelper::castFromInt(lIndex), 0));
<a name="l03887"></a>03887             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03888"></a>03888         });
<a name="l03889"></a>03889     }
<a name="l03890"></a>03890 
<a name="l03891"></a>03891     <span class="keyword">inline</span> base::type::stringstream_t&amp; stream(<span class="keywordtype">void</span>)
<a name="l03892"></a>03892     {
<a name="l03893"></a>03893         <span class="keywordflow">return</span> m_stream;
<a name="l03894"></a>03894     }
<a name="l03895"></a>03895 
<a name="l03896"></a>03896     <span class="keywordtype">void</span> resolveLoggerFormatSpec(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03897"></a>03897 <span class="keyword">    </span>{
<a name="l03898"></a>03898         base::type::EnumType lIndex = LevelHelper::kMinValid;
<a name="l03899"></a>03899         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](<span class="keywordtype">void</span>) -&gt; <span class="keywordtype">bool</span> {
<a name="l03900"></a>03900             base::LogFormat* logFormat =
<a name="l03901"></a>03901             <span class="keyword">const_cast&lt;</span>base::LogFormat*<span class="keyword">&gt;</span>(&amp;m_typedConfigurations-&gt;logFormat(LevelHelper::castFromInt(lIndex)));
<a name="l03902"></a>03902             base::utils::Str::replaceFirstWithEscape(logFormat-&gt;m_format, base::consts::kLoggerIdFormatSpecifier, m_id);
<a name="l03903"></a>03903             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03904"></a>03904         });
<a name="l03905"></a>03905     }
<a name="l03906"></a>03906 };
<a name="l03907"></a>03907 <span class="keyword">namespace </span>base {
<a name="l03909"></a>03909 <span class="keyword">class </span>RegisteredLoggers : <span class="keyword">public</span> base::utils::Registry&lt;Logger, std::string&gt;
<a name="l03910"></a>03910 {
<a name="l03911"></a>03911 <span class="keyword">public</span>:
<a name="l03912"></a>03912     <span class="keyword">explicit</span> RegisteredLoggers(<span class="keyword">const</span> LogBuilderPtr&amp; defaultLogBuilder) :
<a name="l03913"></a>03913         m_defaultLogBuilder(defaultLogBuilder)
<a name="l03914"></a>03914     {
<a name="l03915"></a>03915         m_defaultConfigurations.setToDefault();
<a name="l03916"></a>03916     }
<a name="l03917"></a>03917 
<a name="l03918"></a>03918     <span class="keyword">virtual</span> ~RegisteredLoggers(<span class="keywordtype">void</span>)
<a name="l03919"></a>03919     {
<a name="l03920"></a>03920         flushAll();
<a name="l03921"></a>03921     }
<a name="l03922"></a>03922 
<a name="l03923"></a>03923     <span class="keyword">inline</span> <span class="keywordtype">void</span> setDefaultConfigurations(<span class="keyword">const</span> Configurations&amp; configurations)
<a name="l03924"></a>03924     {
<a name="l03925"></a>03925         base::threading::ScopedLock scopedLock(lock());
<a name="l03926"></a>03926         m_defaultConfigurations.setFromBase(const_cast&lt;Configurations*&gt;(&amp;configurations));
<a name="l03927"></a>03927     }
<a name="l03928"></a>03928 
<a name="l03929"></a>03929     <span class="keyword">inline</span> Configurations* defaultConfigurations(<span class="keywordtype">void</span>)
<a name="l03930"></a>03930     {
<a name="l03931"></a>03931         <span class="keywordflow">return</span> &amp;m_defaultConfigurations;
<a name="l03932"></a>03932     }
<a name="l03933"></a>03933 
<a name="l03934"></a>03934     Logger* <span class="keyword">get</span>(<span class="keyword">const</span> std::string&amp; id, <span class="keywordtype">bool</span> forceCreation = <span class="keyword">true</span>)
<a name="l03935"></a>03935     {
<a name="l03936"></a>03936         base::threading::ScopedLock scopedLock(lock());
<a name="l03937"></a>03937         Logger* logger_ = base::utils::Registry&lt;Logger, std::string&gt;::get(<span class="keywordtype">id</span>);
<a name="l03938"></a>03938         <span class="keywordflow">if</span> (logger_ == <span class="keyword">nullptr</span> &amp;&amp; forceCreation) {
<a name="l03939"></a>03939             <span class="keywordtype">bool</span> validId = Logger::isValidId(<span class="keywordtype">id</span>);
<a name="l03940"></a>03940             <span class="keywordflow">if</span> (!validId) {
<a name="l03941"></a>03941                 ELPP_ASSERT(validId, <span class="stringliteral">&quot;Invalid logger ID [&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;]. Not registering this logger.&quot;</span>);
<a name="l03942"></a>03942                 <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l03943"></a>03943             }
<a name="l03944"></a>03944             logger_ = <span class="keyword">new</span> Logger(<span class="keywordtype">id</span>, m_defaultConfigurations, &amp;m_logStreamsReference);
<a name="l03945"></a>03945             logger_-&gt;m_logBuilder = m_defaultLogBuilder;
<a name="l03946"></a>03946             registerNew(<span class="keywordtype">id</span>, logger_);
<a name="l03947"></a>03947         }
<a name="l03948"></a>03948         <span class="keywordflow">return</span> logger_;
<a name="l03949"></a>03949     }
<a name="l03950"></a>03950 
<a name="l03951"></a>03951     <span class="keywordtype">bool</span> <span class="keyword">remove</span>(<span class="keyword">const</span> std::string&amp; id)
<a name="l03952"></a>03952     {
<a name="l03953"></a>03953         <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == <span class="stringliteral">&quot;default&quot;</span>) {
<a name="l03954"></a>03954             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03955"></a>03955         }
<a name="l03956"></a>03956         Logger* logger = base::utils::Registry&lt;Logger, std::string&gt;::get(<span class="keywordtype">id</span>);
<a name="l03957"></a>03957         <span class="keywordflow">if</span> (logger != <span class="keyword">nullptr</span>) {
<a name="l03958"></a>03958             unregister(logger);
<a name="l03959"></a>03959         }
<a name="l03960"></a>03960         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03961"></a>03961     }
<a name="l03962"></a>03962 
<a name="l03963"></a>03963     <span class="keyword">inline</span> <span class="keywordtype">bool</span> has(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l03964"></a>03964     {
<a name="l03965"></a>03965         <span class="keywordflow">return</span> <span class="keyword">get</span>(id, <span class="keyword">false</span>) != <span class="keyword">nullptr</span>;
<a name="l03966"></a>03966     }
<a name="l03967"></a>03967 
<a name="l03968"></a>03968     <span class="keyword">inline</span> <span class="keywordtype">void</span> unregister(Logger*&amp; logger)
<a name="l03969"></a>03969     {
<a name="l03970"></a>03970         base::threading::ScopedLock scopedLock(lock());
<a name="l03971"></a>03971         base::utils::Registry&lt;Logger, std::string&gt;::unregister(logger-&gt;id());
<a name="l03972"></a>03972     }
<a name="l03973"></a>03973 
<a name="l03974"></a>03974     <span class="keyword">inline</span> base::LogStreamsReferenceMap* logStreamsReference(<span class="keywordtype">void</span>)
<a name="l03975"></a>03975     {
<a name="l03976"></a>03976         <span class="keywordflow">return</span> &amp;m_logStreamsReference;
<a name="l03977"></a>03977     }
<a name="l03978"></a>03978 
<a name="l03979"></a>03979     <span class="keyword">inline</span> <span class="keywordtype">void</span> flushAll(<span class="keywordtype">void</span>)
<a name="l03980"></a>03980     {
<a name="l03981"></a>03981         ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Flushing all log files&quot;</span>);
<a name="l03982"></a>03982         base::threading::ScopedLock scopedLock(lock());
<a name="l03983"></a>03983         <span class="keywordflow">for</span> (base::LogStreamsReferenceMap::iterator it = m_logStreamsReference.begin();
<a name="l03984"></a>03984                 it != m_logStreamsReference.end(); ++it) {
<a name="l03985"></a>03985             <span class="keywordflow">if</span> (it-&gt;second.get() == <span class="keyword">nullptr</span>) <span class="keywordflow">continue</span>;
<a name="l03986"></a>03986             it-&gt;second-&gt;flush();
<a name="l03987"></a>03987         }
<a name="l03988"></a>03988     }
<a name="l03989"></a>03989 
<a name="l03990"></a>03990 <span class="keyword">private</span>:
<a name="l03991"></a>03991     LogBuilderPtr m_defaultLogBuilder;
<a name="l03992"></a>03992     Configurations m_defaultConfigurations;
<a name="l03993"></a>03993     base::LogStreamsReferenceMap m_logStreamsReference;
<a name="l03994"></a>03994     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::Storage;
<a name="l03995"></a>03995 };
<a name="l03997"></a>03997 <span class="keyword">class </span>VRegistry : base::NoCopy, <span class="keyword">public</span> base::threading::ThreadSafe
<a name="l03998"></a>03998 {
<a name="l03999"></a>03999 <span class="keyword">public</span>:
<a name="l04000"></a>04000     <span class="keyword">explicit</span> VRegistry(base::type::VerboseLevel level, base::type::EnumType* pFlags) : m_level(level), m_pFlags(pFlags)
<a name="l04001"></a>04001     {
<a name="l04002"></a>04002     }
<a name="l04003"></a>04003 
<a name="l04005"></a>04005     <span class="keyword">inline</span> <span class="keywordtype">void</span> setLevel(base::type::VerboseLevel level)
<a name="l04006"></a>04006     {
<a name="l04007"></a>04007         base::threading::ScopedLock scopedLock(lock());
<a name="l04008"></a>04008         <span class="keywordflow">if</span> (level &lt; 0)
<a name="l04009"></a>04009             m_level = 0;
<a name="l04010"></a>04010         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (level &gt; 9)
<a name="l04011"></a>04011             m_level = base::consts::kMaxVerboseLevel;
<a name="l04012"></a>04012         <span class="keywordflow">else</span>
<a name="l04013"></a>04013             m_level = level;
<a name="l04014"></a>04014     }
<a name="l04015"></a>04015 
<a name="l04016"></a>04016     <span class="keyword">inline</span> base::type::VerboseLevel level(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04017"></a>04017 <span class="keyword">    </span>{
<a name="l04018"></a>04018         <span class="keywordflow">return</span> m_level;
<a name="l04019"></a>04019     }
<a name="l04020"></a>04020 
<a name="l04021"></a>04021     <span class="keyword">inline</span> <span class="keywordtype">void</span> clearModules(<span class="keywordtype">void</span>)
<a name="l04022"></a>04022     {
<a name="l04023"></a>04023         base::threading::ScopedLock scopedLock(lock());
<a name="l04024"></a>04024         m_modules.clear();
<a name="l04025"></a>04025     }
<a name="l04026"></a>04026 
<a name="l04027"></a>04027     <span class="keywordtype">void</span> setModules(<span class="keyword">const</span> <span class="keywordtype">char</span>* modules)
<a name="l04028"></a>04028     {
<a name="l04029"></a>04029         base::threading::ScopedLock scopedLock(lock());
<a name="l04030"></a>04030         <span class="keyword">auto</span> addSuffix = [](std::stringstream &amp; ss, <span class="keyword">const</span> <span class="keywordtype">char</span>* sfx, <span class="keyword">const</span> <span class="keywordtype">char</span>* prev) {
<a name="l04031"></a>04031             <span class="keywordflow">if</span> (prev != <span class="keyword">nullptr</span> &amp;&amp; base::utils::Str::endsWith(ss.str(), std::string(prev))) {
<a name="l04032"></a>04032                 std::string chr(ss.str().substr(0, ss.str().size() - strlen(prev)));
<a name="l04033"></a>04033                 ss.str(std::string(<span class="stringliteral">&quot;&quot;</span>));
<a name="l04034"></a>04034                 ss &lt;&lt; chr;
<a name="l04035"></a>04035             }
<a name="l04036"></a>04036             <span class="keywordflow">if</span> (base::utils::Str::endsWith(ss.str(), std::string(sfx))) {
<a name="l04037"></a>04037                 std::string chr(ss.str().substr(0, ss.str().size() - strlen(sfx)));
<a name="l04038"></a>04038                 ss.str(std::string(<span class="stringliteral">&quot;&quot;</span>));
<a name="l04039"></a>04039                 ss &lt;&lt; chr;
<a name="l04040"></a>04040             }
<a name="l04041"></a>04041             ss &lt;&lt; sfx;
<a name="l04042"></a>04042         };
<a name="l04043"></a>04043         <span class="keyword">auto</span> insert = [&amp;](std::stringstream &amp; ss, base::type::VerboseLevel level) {
<a name="l04044"></a>04044             <span class="keywordflow">if</span> (!base::utils::hasFlag(LoggingFlag::DisableVModulesExtensions, *m_pFlags)) {
<a name="l04045"></a>04045                 addSuffix(ss, <span class="stringliteral">&quot;.h&quot;</span>, <span class="keyword">nullptr</span>);
<a name="l04046"></a>04046                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04047"></a>04047                 addSuffix(ss, <span class="stringliteral">&quot;.c&quot;</span>, <span class="stringliteral">&quot;.h&quot;</span>);
<a name="l04048"></a>04048                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04049"></a>04049                 addSuffix(ss, <span class="stringliteral">&quot;.cpp&quot;</span>, <span class="stringliteral">&quot;.c&quot;</span>);
<a name="l04050"></a>04050                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04051"></a>04051                 addSuffix(ss, <span class="stringliteral">&quot;.cc&quot;</span>, <span class="stringliteral">&quot;.cpp&quot;</span>);
<a name="l04052"></a>04052                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04053"></a>04053                 addSuffix(ss, <span class="stringliteral">&quot;.cxx&quot;</span>, <span class="stringliteral">&quot;.cc&quot;</span>);
<a name="l04054"></a>04054                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04055"></a>04055                 addSuffix(ss, <span class="stringliteral">&quot;.-inl.h&quot;</span>, <span class="stringliteral">&quot;.cxx&quot;</span>);
<a name="l04056"></a>04056                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04057"></a>04057                 addSuffix(ss, <span class="stringliteral">&quot;.hxx&quot;</span>, <span class="stringliteral">&quot;.-inl.h&quot;</span>);
<a name="l04058"></a>04058                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04059"></a>04059                 addSuffix(ss, <span class="stringliteral">&quot;.hpp&quot;</span>, <span class="stringliteral">&quot;.hxx&quot;</span>);
<a name="l04060"></a>04060                 m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04061"></a>04061                 addSuffix(ss, <span class="stringliteral">&quot;.hh&quot;</span>, <span class="stringliteral">&quot;.hpp&quot;</span>);
<a name="l04062"></a>04062             }
<a name="l04063"></a>04063             m_modules.insert(std::make_pair(ss.str(), level));
<a name="l04064"></a>04064         };
<a name="l04065"></a>04065         <span class="keywordtype">bool</span> isMod = <span class="keyword">true</span>;
<a name="l04066"></a>04066         <span class="keywordtype">bool</span> isLevel = <span class="keyword">false</span>;
<a name="l04067"></a>04067         std::stringstream ss;
<a name="l04068"></a>04068         <span class="keywordtype">int</span> level = -1;
<a name="l04069"></a>04069         <span class="keywordflow">for</span> (; *modules; ++modules) {
<a name="l04070"></a>04070             <span class="keywordflow">switch</span> (*modules) {
<a name="l04071"></a>04071                 <span class="keywordflow">case</span> <span class="charliteral">&apos;=&apos;</span>:
<a name="l04072"></a>04072                     isLevel = <span class="keyword">true</span>;
<a name="l04073"></a>04073                     isMod = <span class="keyword">false</span>;
<a name="l04074"></a>04074                     <span class="keywordflow">break</span>;
<a name="l04075"></a>04075                 <span class="keywordflow">case</span> <span class="charliteral">&apos;,&apos;</span>:
<a name="l04076"></a>04076                     isLevel = <span class="keyword">false</span>;
<a name="l04077"></a>04077                     isMod = <span class="keyword">true</span>;
<a name="l04078"></a>04078                     <span class="keywordflow">if</span> (!ss.str().empty() &amp;&amp; level != -1) {
<a name="l04079"></a>04079                         insert(ss, level);
<a name="l04080"></a>04080                         ss.str(std::string(<span class="stringliteral">&quot;&quot;</span>));
<a name="l04081"></a>04081                         level = -1;
<a name="l04082"></a>04082                     }
<a name="l04083"></a>04083                     <span class="keywordflow">break</span>;
<a name="l04084"></a>04084                 <span class="keywordflow">default</span>:
<a name="l04085"></a>04085                     <span class="keywordflow">if</span> (isMod) {
<a name="l04086"></a>04086                         ss &lt;&lt; *modules;
<a name="l04087"></a>04087                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isLevel) {
<a name="l04088"></a>04088                         <span class="keywordflow">if</span> (isdigit(*modules)) {
<a name="l04089"></a>04089                             level = <span class="keyword">static_cast&lt;</span>base::type::VerboseLevel<span class="keyword">&gt;</span>(*modules) - 48;
<a name="l04090"></a>04090                         }
<a name="l04091"></a>04091                     }
<a name="l04092"></a>04092                     <span class="keywordflow">break</span>;
<a name="l04093"></a>04093             }
<a name="l04094"></a>04094         }
<a name="l04095"></a>04095         <span class="keywordflow">if</span> (!ss.str().empty() &amp;&amp; level != -1) {
<a name="l04096"></a>04096             insert(ss, level);
<a name="l04097"></a>04097         }
<a name="l04098"></a>04098     }
<a name="l04099"></a>04099 
<a name="l04100"></a>04100     <span class="keywordtype">bool</span> allowed(base::type::VerboseLevel vlevel, <span class="keyword">const</span> <span class="keywordtype">char</span>* file)
<a name="l04101"></a>04101     {
<a name="l04102"></a>04102         base::threading::ScopedLock scopedLock(lock());
<a name="l04103"></a>04103         <span class="keywordflow">if</span> (m_modules.empty() || file == <span class="keyword">nullptr</span>) {
<a name="l04104"></a>04104             <span class="keywordflow">return</span> vlevel &lt;= m_level;
<a name="l04105"></a>04105         } <span class="keywordflow">else</span> {
<a name="l04106"></a>04106             std::map&lt;std::string, base::type::VerboseLevel&gt;::iterator it = m_modules.begin();
<a name="l04107"></a>04107             <span class="keywordflow">for</span> (; it != m_modules.end(); ++it) {
<a name="l04108"></a>04108                 <span class="keywordflow">if</span> (base::utils::Str::wildCardMatch(file, it-&gt;first.c_str())) {
<a name="l04109"></a>04109                     <span class="keywordflow">return</span> vlevel &lt;= it-&gt;second;
<a name="l04110"></a>04110                 }
<a name="l04111"></a>04111             }
<a name="l04112"></a>04112             <span class="keywordflow">if</span> (base::utils::hasFlag(LoggingFlag::AllowVerboseIfModuleNotSpecified, *m_pFlags)) {
<a name="l04113"></a>04113                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04114"></a>04114             }
<a name="l04115"></a>04115             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04116"></a>04116         }
<a name="l04117"></a>04117     }
<a name="l04118"></a>04118 
<a name="l04119"></a>04119     <span class="keyword">inline</span> <span class="keyword">const</span> std::map&lt;std::string, base::type::VerboseLevel&gt;&amp; modules(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04120"></a>04120 <span class="keyword">    </span>{
<a name="l04121"></a>04121         <span class="keywordflow">return</span> m_modules;
<a name="l04122"></a>04122     }
<a name="l04123"></a>04123 
<a name="l04124"></a>04124     <span class="keywordtype">void</span> setFromArgs(<span class="keyword">const</span> base::utils::CommandLineArgs* commandLineArgs)
<a name="l04125"></a>04125     {
<a name="l04126"></a>04126         <span class="keywordflow">if</span> (commandLineArgs-&gt;hasParam(<span class="stringliteral">&quot;-v&quot;</span>) || commandLineArgs-&gt;hasParam(<span class="stringliteral">&quot;--verbose&quot;</span>) ||
<a name="l04127"></a>04127                 commandLineArgs-&gt;hasParam(<span class="stringliteral">&quot;-V&quot;</span>) || commandLineArgs-&gt;hasParam(<span class="stringliteral">&quot;--VERBOSE&quot;</span>)) {
<a name="l04128"></a>04128             setLevel(base::consts::kMaxVerboseLevel);
<a name="l04129"></a>04129         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandLineArgs-&gt;hasParamWithValue(<span class="stringliteral">&quot;--v&quot;</span>)) {
<a name="l04130"></a>04130             setLevel(atoi(commandLineArgs-&gt;getParamValue(<span class="stringliteral">&quot;--v&quot;</span>)));
<a name="l04131"></a>04131         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandLineArgs-&gt;hasParamWithValue(<span class="stringliteral">&quot;--V&quot;</span>)) {
<a name="l04132"></a>04132             setLevel(atoi(commandLineArgs-&gt;getParamValue(<span class="stringliteral">&quot;--V&quot;</span>)));
<a name="l04133"></a>04133         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((commandLineArgs-&gt;hasParamWithValue(<span class="stringliteral">&quot;-vmodule&quot;</span>)) &amp;&amp; vModulesEnabled()) {
<a name="l04134"></a>04134             setModules(commandLineArgs-&gt;getParamValue(<span class="stringliteral">&quot;-vmodule&quot;</span>));
<a name="l04135"></a>04135         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandLineArgs-&gt;hasParamWithValue(<span class="stringliteral">&quot;-VMODULE&quot;</span>) &amp;&amp; vModulesEnabled()) {
<a name="l04136"></a>04136             setModules(commandLineArgs-&gt;getParamValue(<span class="stringliteral">&quot;-VMODULE&quot;</span>));
<a name="l04137"></a>04137         }
<a name="l04138"></a>04138     }
<a name="l04139"></a>04139 
<a name="l04141"></a>04141     <span class="keyword">inline</span> <span class="keywordtype">bool</span> vModulesEnabled(<span class="keywordtype">void</span>)
<a name="l04142"></a>04142     {
<a name="l04143"></a>04143         <span class="keywordflow">return</span> !base::utils::hasFlag(LoggingFlag::DisableVModules, *m_pFlags);
<a name="l04144"></a>04144     }
<a name="l04145"></a>04145 
<a name="l04146"></a>04146 <span class="keyword">private</span>:
<a name="l04147"></a>04147     base::type::VerboseLevel m_level;
<a name="l04148"></a>04148     base::type::EnumType* m_pFlags;
<a name="l04149"></a>04149     std::map&lt;std::string, base::type::VerboseLevel&gt; m_modules;
<a name="l04150"></a>04150 };
<a name="l04151"></a>04151 }  <span class="comment">// namespace base</span>
<a name="l04152"></a>04152 <span class="keyword">class </span>LogMessage
<a name="l04153"></a>04153 {
<a name="l04154"></a>04154 <span class="keyword">public</span>:
<a name="l04155"></a>04155     LogMessage(Level level, <span class="keyword">const</span> std::string&amp; file, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> line, <span class="keyword">const</span> std::string&amp; func,
<a name="l04156"></a>04156                base::type::VerboseLevel verboseLevel, Logger* logger) :
<a name="l04157"></a>04157         m_level(level), m_file(file), m_line(line), m_func(func),
<a name="l04158"></a>04158         m_verboseLevel(verboseLevel), m_logger(logger), m_message(std::move(logger-&gt;stream().str()))
<a name="l04159"></a>04159     {
<a name="l04160"></a>04160     }
<a name="l04161"></a>04161     <span class="keyword">inline</span> Level level(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_level; }
<a name="l04162"></a>04162     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; file(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_file; }
<a name="l04163"></a>04163     <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> line(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_line; } <span class="comment">// NOLINT</span>
<a name="l04164"></a>04164     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; func(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_func; }
<a name="l04165"></a>04165     <span class="keyword">inline</span> base::type::VerboseLevel verboseLevel(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_verboseLevel; }
<a name="l04166"></a>04166     <span class="keyword">inline</span> Logger* logger(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_logger; }
<a name="l04167"></a>04167     <span class="keyword">inline</span> <span class="keyword">const</span> base::type::string_t&amp; message(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_message; }
<a name="l04168"></a>04168 <span class="keyword">private</span>:
<a name="l04169"></a>04169     Level m_level;
<a name="l04170"></a>04170     std::string m_file;
<a name="l04171"></a>04171     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> m_line;
<a name="l04172"></a>04172     std::string m_func;
<a name="l04173"></a>04173     base::type::VerboseLevel m_verboseLevel;
<a name="l04174"></a>04174     Logger* m_logger;
<a name="l04175"></a>04175     base::type::string_t m_message;
<a name="l04176"></a>04176 };
<a name="l04177"></a>04177 <span class="keyword">namespace </span>base {
<a name="l04178"></a>04178 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04179"></a>04179 <span class="preprocessor"></span><span class="keyword">class </span>AsyncLogItem
<a name="l04180"></a>04180 {
<a name="l04181"></a>04181 <span class="keyword">public</span>:
<a name="l04182"></a>04182     <span class="keyword">explicit</span> AsyncLogItem(<span class="keyword">const</span> LogMessage&amp; logMessage, <span class="keyword">const</span> LogDispatchData&amp; data, <span class="keyword">const</span> base::type::string_t&amp; logLine)
<a name="l04183"></a>04183         : m_logMessage(logMessage), m_dispatchData(data), m_logLine(logLine) {}
<a name="l04184"></a>04184     <span class="keyword">virtual</span> ~AsyncLogItem() {}
<a name="l04185"></a>04185     <span class="keyword">inline</span> LogMessage* logMessage(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> &amp;m_logMessage; }
<a name="l04186"></a>04186     <span class="keyword">inline</span> LogDispatchData* data(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> &amp;m_dispatchData; }
<a name="l04187"></a>04187     <span class="keyword">inline</span> base::type::string_t logLine(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> m_logLine; }
<a name="l04188"></a>04188 <span class="keyword">private</span>:
<a name="l04189"></a>04189     LogMessage m_logMessage;
<a name="l04190"></a>04190     LogDispatchData m_dispatchData;
<a name="l04191"></a>04191     base::type::string_t m_logLine;
<a name="l04192"></a>04192 };
<a name="l04193"></a>04193 <span class="keyword">class </span>AsyncLogQueue : <span class="keyword">public</span> base::threading::ThreadSafe
<a name="l04194"></a>04194 {
<a name="l04195"></a>04195 <span class="keyword">public</span>:
<a name="l04196"></a>04196     <span class="keyword">virtual</span> ~AsyncLogQueue()
<a name="l04197"></a>04197     {
<a name="l04198"></a>04198         ELPP_INTERNAL_INFO(6, <span class="stringliteral">&quot;~AsyncLogQueue&quot;</span>);
<a name="l04199"></a>04199     }
<a name="l04200"></a>04200 
<a name="l04201"></a>04201     <span class="keyword">inline</span> AsyncLogItem next(<span class="keywordtype">void</span>)
<a name="l04202"></a>04202     {
<a name="l04203"></a>04203         base::threading::ScopedLock scopedLock(lock());
<a name="l04204"></a>04204         AsyncLogItem result = m_queue.front();
<a name="l04205"></a>04205         m_queue.pop();
<a name="l04206"></a>04206         <span class="keywordflow">return</span> result;
<a name="l04207"></a>04207     }
<a name="l04208"></a>04208 
<a name="l04209"></a>04209     <span class="keyword">inline</span> <span class="keywordtype">void</span> push(<span class="keyword">const</span> AsyncLogItem&amp; item)
<a name="l04210"></a>04210     {
<a name="l04211"></a>04211         base::threading::ScopedLock scopedLock(lock());
<a name="l04212"></a>04212         m_queue.push(item);
<a name="l04213"></a>04213     }
<a name="l04214"></a>04214     <span class="keyword">inline</span> <span class="keywordtype">void</span> pop(<span class="keywordtype">void</span>)
<a name="l04215"></a>04215     {
<a name="l04216"></a>04216         base::threading::ScopedLock scopedLock(lock());
<a name="l04217"></a>04217         m_queue.pop();
<a name="l04218"></a>04218     }
<a name="l04219"></a>04219     <span class="keyword">inline</span> AsyncLogItem front(<span class="keywordtype">void</span>)
<a name="l04220"></a>04220     {
<a name="l04221"></a>04221         base::threading::ScopedLock scopedLock(lock());
<a name="l04222"></a>04222         <span class="keywordflow">return</span> m_queue.front();
<a name="l04223"></a>04223     }
<a name="l04224"></a>04224     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty(<span class="keywordtype">void</span>)
<a name="l04225"></a>04225     {
<a name="l04226"></a>04226         base::threading::ScopedLock scopedLock(lock());
<a name="l04227"></a>04227         <span class="keywordflow">return</span> m_queue.empty();
<a name="l04228"></a>04228     }
<a name="l04229"></a>04229 <span class="keyword">private</span>:
<a name="l04230"></a>04230     std::queue&lt;AsyncLogItem&gt; m_queue;
<a name="l04231"></a>04231 };
<a name="l04232"></a>04232 <span class="keyword">class </span>IWorker
<a name="l04233"></a>04233 {
<a name="l04234"></a>04234 <span class="keyword">public</span>:
<a name="l04235"></a>04235     <span class="keyword">virtual</span> ~IWorker() {}
<a name="l04236"></a>04236     <span class="keyword">virtual</span> <span class="keywordtype">void</span> start() = 0;
<a name="l04237"></a>04237 };
<a name="l04238"></a>04238 <span class="preprocessor">#endif // ELPP_ASYNC_LOGGING</span>
<a name="l04240"></a>04240 <span class="preprocessor">class Storage : base::NoCopy, public base::threading::ThreadSafe</span>
<a name="l04241"></a>04241 <span class="preprocessor"></span>{
<a name="l04242"></a>04242 <span class="keyword">public</span>:
<a name="l04243"></a>04243 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04244"></a>04244 <span class="preprocessor"></span>    Storage(<span class="keyword">const</span> LogBuilderPtr&amp; defaultLogBuilder, base::IWorker* asyncDispatchWorker) :
<a name="l04245"></a>04245 #else
<a name="l04246"></a>04246     explicit Storage(const LogBuilderPtr &amp; defaultLogBuilder) :
<a name="l04247"></a>04247 #endif  <span class="comment">// ELPP_ASYNC_LOGGING</span>
<a name="l04248"></a>04248         m_registeredHitCounters(new base::RegisteredHitCounters()),
<a name="l04249"></a>04249         m_registeredLoggers(new base::RegisteredLoggers(defaultLogBuilder)),
<a name="l04250"></a>04250         m_flags(0x0),
<a name="l04251"></a>04251         m_vRegistry(new base::VRegistry(0, &amp;m_flags)),
<a name="l04252"></a>04252 #if ELPP_ASYNC_LOGGING
<a name="l04253"></a>04253         m_asyncLogQueue(new base::AsyncLogQueue()),
<a name="l04254"></a>04254         m_asyncDispatchWorker(asyncDispatchWorker),
<a name="l04255"></a>04255 #endif  <span class="comment">// ELPP_ASYNC_LOGGING</span>
<a name="l04256"></a>04256         m_preRollOutCallback(base::defaultPreRollOutCallback)
<a name="l04257"></a>04257     {
<a name="l04258"></a>04258         <span class="comment">// Register default logger</span>
<a name="l04259"></a>04259         m_registeredLoggers-&gt;get(std::string(base::consts::kDefaultLoggerId));
<a name="l04260"></a>04260         <span class="comment">// Register performance logger and reconfigure format</span>
<a name="l04261"></a>04261         Logger* performanceLogger = m_registeredLoggers-&gt;get(std::string(base::consts::kPerformanceLoggerId));
<a name="l04262"></a>04262         performanceLogger-&gt;configurations()-&gt;setGlobally(ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%datetime %level %msg&quot;</span>));
<a name="l04263"></a>04263         performanceLogger-&gt;reconfigure();
<a name="l04264"></a>04264 <span class="preprocessor">#if defined(ELPP_SYSLOG)</span>
<a name="l04265"></a>04265 <span class="preprocessor"></span>        <span class="comment">// Register syslog logger and reconfigure format</span>
<a name="l04266"></a>04266         Logger* sysLogLogger = m_registeredLoggers-&gt;get(std::string(base::consts::kSysLogLoggerId));
<a name="l04267"></a>04267         sysLogLogger-&gt;configurations()-&gt;setGlobally(ConfigurationType::Format, std::string(<span class="stringliteral">&quot;%level: %msg&quot;</span>));
<a name="l04268"></a>04268         sysLogLogger-&gt;reconfigure();
<a name="l04269"></a>04269 <span class="preprocessor">#else</span>
<a name="l04270"></a>04270 <span class="preprocessor"></span>        ELPP_UNUSED(base::consts::kSysLogLoggerId);
<a name="l04271"></a>04271 <span class="preprocessor">#endif //  defined(ELPP_SYSLOG)</span>
<a name="l04272"></a>04272 <span class="preprocessor"></span>        addFlag(LoggingFlag::AllowVerboseIfModuleNotSpecified);
<a name="l04273"></a>04273 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04274"></a>04274 <span class="preprocessor"></span>        installLogDispatchCallback&lt;base::AsyncLogDispatchCallback&gt;(std::string(<span class="stringliteral">&quot;AsyncLogDispatchCallback&quot;</span>));
<a name="l04275"></a>04275 <span class="preprocessor">#else</span>
<a name="l04276"></a>04276 <span class="preprocessor"></span>        installLogDispatchCallback&lt;base::DefaultLogDispatchCallback&gt;(std::string(<span class="stringliteral">&quot;DefaultLogDispatchCallback&quot;</span>));
<a name="l04277"></a>04277 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l04278"></a>04278 <span class="preprocessor"></span>        installPerformanceTrackingCallback&lt;base::DefaultPerformanceTrackingCallback&gt;(std::string(<span class="stringliteral">&quot;DefaultPerformanceTrackingCallback&quot;</span>));
<a name="l04279"></a>04279         ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Easylogging++ has been initialized&quot;</span>);
<a name="l04280"></a>04280 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04281"></a>04281 <span class="preprocessor"></span>        m_asyncDispatchWorker-&gt;start();
<a name="l04282"></a>04282 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l04283"></a>04283 <span class="preprocessor"></span>    }
<a name="l04284"></a>04284 
<a name="l04285"></a>04285     <span class="keyword">virtual</span> ~Storage(<span class="keywordtype">void</span>)
<a name="l04286"></a>04286     {
<a name="l04287"></a>04287         ELPP_INTERNAL_INFO(4, <span class="stringliteral">&quot;Destroying storage&quot;</span>);
<a name="l04288"></a>04288 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04289"></a>04289 <span class="preprocessor"></span>        ELPP_INTERNAL_INFO(5, <span class="stringliteral">&quot;Replacing log dispatch callback to synchronous&quot;</span>);
<a name="l04290"></a>04290         uninstallLogDispatchCallback&lt;base::AsyncLogDispatchCallback&gt;(std::string(<span class="stringliteral">&quot;AsyncLogDispatchCallback&quot;</span>));
<a name="l04291"></a>04291         installLogDispatchCallback&lt;base::DefaultLogDispatchCallback&gt;(std::string(<span class="stringliteral">&quot;DefaultLogDispatchCallback&quot;</span>));
<a name="l04292"></a>04292         ELPP_INTERNAL_INFO(5, <span class="stringliteral">&quot;Destroying asyncDispatchWorker&quot;</span>);
<a name="l04293"></a>04293         base::utils::safeDelete(m_asyncDispatchWorker);
<a name="l04294"></a>04294         ELPP_INTERNAL_INFO(5, <span class="stringliteral">&quot;Destroying asyncLogQueue&quot;</span>);
<a name="l04295"></a>04295         base::utils::safeDelete(m_asyncLogQueue);
<a name="l04296"></a>04296 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l04297"></a>04297 <span class="preprocessor"></span>        ELPP_INTERNAL_INFO(5, <span class="stringliteral">&quot;Destroying registeredHitCounters&quot;</span>);
<a name="l04298"></a>04298         base::utils::safeDelete(m_registeredHitCounters);
<a name="l04299"></a>04299         ELPP_INTERNAL_INFO(5, <span class="stringliteral">&quot;Destroying registeredLoggers&quot;</span>);
<a name="l04300"></a>04300         base::utils::safeDelete(m_registeredLoggers);
<a name="l04301"></a>04301         ELPP_INTERNAL_INFO(5, <span class="stringliteral">&quot;Destroying vRegistry&quot;</span>);
<a name="l04302"></a>04302         base::utils::safeDelete(m_vRegistry);
<a name="l04303"></a>04303     }
<a name="l04304"></a>04304 
<a name="l04305"></a>04305     <span class="keyword">inline</span> <span class="keywordtype">bool</span> validateEveryNCounter(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber, std::size_t occasion)
<a name="l04306"></a>04306     {
<a name="l04307"></a>04307         <span class="keywordflow">return</span> hitCounters()-&gt;validateEveryN(filename, lineNumber, occasion);
<a name="l04308"></a>04308     }
<a name="l04309"></a>04309 
<a name="l04310"></a>04310     <span class="keyword">inline</span> <span class="keywordtype">bool</span> validateAfterNCounter(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber, std::size_t n)   <span class="comment">// NOLINT</span>
<a name="l04311"></a>04311     {
<a name="l04312"></a>04312         <span class="keywordflow">return</span> hitCounters()-&gt;validateAfterN(filename, lineNumber, n);
<a name="l04313"></a>04313     }
<a name="l04314"></a>04314 
<a name="l04315"></a>04315     <span class="keyword">inline</span> <span class="keywordtype">bool</span> validateNTimesCounter(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> lineNumber, std::size_t n)   <span class="comment">// NOLINT</span>
<a name="l04316"></a>04316     {
<a name="l04317"></a>04317         <span class="keywordflow">return</span> hitCounters()-&gt;validateNTimes(filename, lineNumber, n);
<a name="l04318"></a>04318     }
<a name="l04319"></a>04319 
<a name="l04320"></a>04320     <span class="keyword">inline</span> base::RegisteredHitCounters* hitCounters(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04321"></a>04321 <span class="keyword">    </span>{
<a name="l04322"></a>04322         <span class="keywordflow">return</span> m_registeredHitCounters;
<a name="l04323"></a>04323     }
<a name="l04324"></a>04324 
<a name="l04325"></a>04325     <span class="keyword">inline</span> base::RegisteredLoggers* registeredLoggers(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04326"></a>04326 <span class="keyword">    </span>{
<a name="l04327"></a>04327         <span class="keywordflow">return</span> m_registeredLoggers;
<a name="l04328"></a>04328     }
<a name="l04329"></a>04329 
<a name="l04330"></a>04330     <span class="keyword">inline</span> base::VRegistry* vRegistry(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04331"></a>04331 <span class="keyword">    </span>{
<a name="l04332"></a>04332         <span class="keywordflow">return</span> m_vRegistry;
<a name="l04333"></a>04333     }
<a name="l04334"></a>04334 
<a name="l04335"></a>04335 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04336"></a>04336 <span class="preprocessor"></span>    <span class="keyword">inline</span> base::AsyncLogQueue* asyncLogQueue(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04337"></a>04337 <span class="keyword">    </span>{
<a name="l04338"></a>04338         <span class="keywordflow">return</span> m_asyncLogQueue;
<a name="l04339"></a>04339     }
<a name="l04340"></a>04340 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l04341"></a>04341 <span class="preprocessor"></span>
<a name="l04342"></a>04342     <span class="keyword">inline</span> <span class="keyword">const</span> base::utils::CommandLineArgs* commandLineArgs(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04343"></a>04343 <span class="keyword">    </span>{
<a name="l04344"></a>04344         <span class="keywordflow">return</span> &amp;m_commandLineArgs;
<a name="l04345"></a>04345     }
<a name="l04346"></a>04346 
<a name="l04347"></a>04347     <span class="keyword">inline</span> <span class="keywordtype">void</span> addFlag(LoggingFlag flag)
<a name="l04348"></a>04348     {
<a name="l04349"></a>04349         base::utils::addFlag(flag, &amp;m_flags);
<a name="l04350"></a>04350     }
<a name="l04351"></a>04351 
<a name="l04352"></a>04352     <span class="keyword">inline</span> <span class="keywordtype">void</span> removeFlag(LoggingFlag flag)
<a name="l04353"></a>04353     {
<a name="l04354"></a>04354         base::utils::removeFlag(flag, &amp;m_flags);
<a name="l04355"></a>04355     }
<a name="l04356"></a>04356 
<a name="l04357"></a>04357     <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasFlag(LoggingFlag flag)<span class="keyword"> const</span>
<a name="l04358"></a>04358 <span class="keyword">    </span>{
<a name="l04359"></a>04359         <span class="keywordflow">return</span> base::utils::hasFlag(flag, m_flags);
<a name="l04360"></a>04360     }
<a name="l04361"></a>04361 
<a name="l04362"></a>04362     <span class="keyword">inline</span> base::type::EnumType flags(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04363"></a>04363 <span class="keyword">    </span>{
<a name="l04364"></a>04364         <span class="keywordflow">return</span> m_flags;
<a name="l04365"></a>04365     }
<a name="l04366"></a>04366 
<a name="l04367"></a>04367     <span class="keyword">inline</span> <span class="keywordtype">void</span> setFlags(base::type::EnumType flags)
<a name="l04368"></a>04368     {
<a name="l04369"></a>04369         m_flags = flags;
<a name="l04370"></a>04370     }
<a name="l04371"></a>04371 
<a name="l04372"></a>04372     <span class="keyword">inline</span> <span class="keywordtype">void</span> setPreRollOutCallback(<span class="keyword">const</span> PreRollOutCallback&amp; callback)
<a name="l04373"></a>04373     {
<a name="l04374"></a>04374         m_preRollOutCallback = callback;
<a name="l04375"></a>04375     }
<a name="l04376"></a>04376 
<a name="l04377"></a>04377     <span class="keyword">inline</span> <span class="keywordtype">void</span> unsetPreRollOutCallback(<span class="keywordtype">void</span>)
<a name="l04378"></a>04378     {
<a name="l04379"></a>04379         m_preRollOutCallback = base::defaultPreRollOutCallback;
<a name="l04380"></a>04380     }
<a name="l04381"></a>04381 
<a name="l04382"></a>04382     <span class="keyword">inline</span> PreRollOutCallback&amp; preRollOutCallback(<span class="keywordtype">void</span>)
<a name="l04383"></a>04383     {
<a name="l04384"></a>04384         <span class="keywordflow">return</span> m_preRollOutCallback;
<a name="l04385"></a>04385     }
<a name="l04386"></a>04386 
<a name="l04387"></a>04387     <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasCustomFormatSpecifier(<span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier)
<a name="l04388"></a>04388     {
<a name="l04389"></a>04389         base::threading::ScopedLock scopedLock(lock());
<a name="l04390"></a>04390         <span class="keywordflow">return</span> std::find(m_customFormatSpecifiers.begin(), m_customFormatSpecifiers.end(),
<a name="l04391"></a>04391                          formatSpecifier) != m_customFormatSpecifiers.end();
<a name="l04392"></a>04392     }
<a name="l04393"></a>04393 
<a name="l04394"></a>04394     <span class="keyword">inline</span> <span class="keywordtype">void</span> installCustomFormatSpecifier(<span class="keyword">const</span> CustomFormatSpecifier&amp; customFormatSpecifier)
<a name="l04395"></a>04395     {
<a name="l04396"></a>04396         <span class="keywordflow">if</span> (hasCustomFormatSpecifier(customFormatSpecifier.formatSpecifier())) {
<a name="l04397"></a>04397             <span class="keywordflow">return</span>;
<a name="l04398"></a>04398         }
<a name="l04399"></a>04399         base::threading::ScopedLock scopedLock(lock());
<a name="l04400"></a>04400         m_customFormatSpecifiers.push_back(customFormatSpecifier);
<a name="l04401"></a>04401     }
<a name="l04402"></a>04402 
<a name="l04403"></a>04403     <span class="keyword">inline</span> <span class="keywordtype">bool</span> uninstallCustomFormatSpecifier(<span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier)
<a name="l04404"></a>04404     {
<a name="l04405"></a>04405         base::threading::ScopedLock scopedLock(lock());
<a name="l04406"></a>04406         std::vector&lt;CustomFormatSpecifier&gt;::iterator it = std::find(m_customFormatSpecifiers.begin(),
<a name="l04407"></a>04407                 m_customFormatSpecifiers.end(), formatSpecifier);
<a name="l04408"></a>04408         <span class="keywordflow">if</span> (it != m_customFormatSpecifiers.end() &amp;&amp; strcmp(formatSpecifier, it-&gt;formatSpecifier()) == 0) {
<a name="l04409"></a>04409             m_customFormatSpecifiers.erase(it);
<a name="l04410"></a>04410             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04411"></a>04411         }
<a name="l04412"></a>04412         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04413"></a>04413     }
<a name="l04414"></a>04414 
<a name="l04415"></a>04415     <span class="keyword">const</span> std::vector&lt;CustomFormatSpecifier&gt;* customFormatSpecifiers(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l04416"></a>04416 <span class="keyword">    </span>{
<a name="l04417"></a>04417         <span class="keywordflow">return</span> &amp;m_customFormatSpecifiers;
<a name="l04418"></a>04418     }
<a name="l04419"></a>04419 
<a name="l04420"></a>04420     <span class="keyword">inline</span> <span class="keywordtype">void</span> setLoggingLevel(Level level)
<a name="l04421"></a>04421     {
<a name="l04422"></a>04422         m_loggingLevel = level;
<a name="l04423"></a>04423     }
<a name="l04424"></a>04424 
<a name="l04425"></a>04425     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l04426"></a>04426     <span class="keyword">inline</span> <span class="keywordtype">bool</span> installLogDispatchCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l04427"></a>04427     {
<a name="l04428"></a>04428         <span class="keywordflow">return</span> installCallback&lt;T, base::type::LogDispatchCallbackPtr&gt;(id, &amp;m_logDispatchCallbacks);
<a name="l04429"></a>04429     }
<a name="l04430"></a>04430 
<a name="l04431"></a>04431     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l04432"></a>04432     <span class="keyword">inline</span> <span class="keywordtype">void</span> uninstallLogDispatchCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l04433"></a>04433     {
<a name="l04434"></a>04434         uninstallCallback&lt;T, base::type::LogDispatchCallbackPtr&gt;(id, &amp;m_logDispatchCallbacks);
<a name="l04435"></a>04435     }
<a name="l04436"></a>04436     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l04437"></a>04437     <span class="keyword">inline</span> T* logDispatchCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l04438"></a>04438     {
<a name="l04439"></a>04439         <span class="keywordflow">return</span> callback&lt;T, base::type::LogDispatchCallbackPtr&gt;(id, &amp;m_logDispatchCallbacks);
<a name="l04440"></a>04440     }
<a name="l04441"></a>04441 
<a name="l04442"></a>04442     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l04443"></a>04443     <span class="keyword">inline</span> <span class="keywordtype">bool</span> installPerformanceTrackingCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l04444"></a>04444     {
<a name="l04445"></a>04445         <span class="keywordflow">return</span> installCallback&lt;T, base::type::PerformanceTrackingCallbackPtr&gt;(id, &amp;m_performanceTrackingCallbacks);
<a name="l04446"></a>04446     }
<a name="l04447"></a>04447 
<a name="l04448"></a>04448     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l04449"></a>04449     <span class="keyword">inline</span> <span class="keywordtype">void</span> uninstallPerformanceTrackingCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l04450"></a>04450     {
<a name="l04451"></a>04451         uninstallCallback&lt;T, base::type::PerformanceTrackingCallbackPtr&gt;(id, &amp;m_performanceTrackingCallbacks);
<a name="l04452"></a>04452     }
<a name="l04453"></a>04453 
<a name="l04454"></a>04454     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l04455"></a>04455     <span class="keyword">inline</span> T* performanceTrackingCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l04456"></a>04456     {
<a name="l04457"></a>04457         <span class="keywordflow">return</span> callback&lt;T, base::type::PerformanceTrackingCallbackPtr&gt;(id, &amp;m_performanceTrackingCallbacks);
<a name="l04458"></a>04458     }
<a name="l04459"></a>04459 <span class="keyword">private</span>:
<a name="l04460"></a>04460     base::RegisteredHitCounters* m_registeredHitCounters;
<a name="l04461"></a>04461     base::RegisteredLoggers* m_registeredLoggers;
<a name="l04462"></a>04462     base::type::EnumType m_flags;
<a name="l04463"></a>04463     base::VRegistry* m_vRegistry;
<a name="l04464"></a>04464 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04465"></a>04465 <span class="preprocessor"></span>    base::AsyncLogQueue* m_asyncLogQueue;
<a name="l04466"></a>04466     base::IWorker* m_asyncDispatchWorker;
<a name="l04467"></a>04467 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l04468"></a>04468 <span class="preprocessor"></span>    base::utils::CommandLineArgs m_commandLineArgs;
<a name="l04469"></a>04469     PreRollOutCallback m_preRollOutCallback;
<a name="l04470"></a>04470     std::map&lt;std::string, base::type::LogDispatchCallbackPtr&gt; m_logDispatchCallbacks;
<a name="l04471"></a>04471     std::map&lt;std::string, base::type::PerformanceTrackingCallbackPtr&gt; m_performanceTrackingCallbacks;
<a name="l04472"></a>04472     std::vector&lt;CustomFormatSpecifier&gt; m_customFormatSpecifiers;
<a name="l04473"></a>04473     Level m_loggingLevel;
<a name="l04474"></a>04474 
<a name="l04475"></a>04475     <span class="keyword">friend</span> <span class="keyword">class </span>el::Helpers;
<a name="l04476"></a>04476     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::DefaultLogDispatchCallback;
<a name="l04477"></a>04477     <span class="keyword">friend</span> <span class="keyword">class </span>el::LogBuilder;
<a name="l04478"></a>04478     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::MessageBuilder;
<a name="l04479"></a>04479     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::Writer;
<a name="l04480"></a>04480     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::PerformanceTracker;
<a name="l04481"></a>04481     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::LogDispatcher;
<a name="l04482"></a>04482 
<a name="l04483"></a>04483     <span class="keywordtype">void</span> setApplicationArguments(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
<a name="l04484"></a>04484     {
<a name="l04485"></a>04485         m_commandLineArgs.setArgs(argc, argv);
<a name="l04486"></a>04486         m_vRegistry-&gt;setFromArgs(commandLineArgs());
<a name="l04487"></a>04487         <span class="comment">// default log file</span>
<a name="l04488"></a>04488 <span class="preprocessor">#if !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)</span>
<a name="l04489"></a>04489 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_commandLineArgs.hasParamWithValue(base::consts::kDefaultLogFileParam)) {
<a name="l04490"></a>04490             Configurations c;
<a name="l04491"></a>04491             c.setGlobally(ConfigurationType::Filename, std::string(m_commandLineArgs.getParamValue(base::consts::kDefaultLogFileParam)));
<a name="l04492"></a>04492             registeredLoggers()-&gt;setDefaultConfigurations(c);
<a name="l04493"></a>04493             <span class="keywordflow">for</span> (base::RegisteredLoggers::iterator it = registeredLoggers()-&gt;begin();
<a name="l04494"></a>04494                     it != registeredLoggers()-&gt;end(); ++it) {
<a name="l04495"></a>04495                 it-&gt;second-&gt;configure(c);
<a name="l04496"></a>04496             }
<a name="l04497"></a>04497         }
<a name="l04498"></a>04498 <span class="preprocessor">#endif  // !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)</span>
<a name="l04499"></a>04499 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_LOGGING_FLAGS_FROM_ARG)</span>
<a name="l04500"></a>04500 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_commandLineArgs.hasParamWithValue(base::consts::kLoggingFlagsParam)) {
<a name="l04501"></a>04501             m_flags = atoi(m_commandLineArgs.getParamValue(base::consts::kLoggingFlagsParam));
<a name="l04502"></a>04502         }
<a name="l04503"></a>04503 <span class="preprocessor">#endif  // defined(ELPP_LOGGING_FLAGS_FROM_ARG)</span>
<a name="l04504"></a>04504 <span class="preprocessor"></span>    }
<a name="l04505"></a>04505 
<a name="l04506"></a>04506     <span class="keyword">inline</span> <span class="keywordtype">void</span> setApplicationArguments(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)
<a name="l04507"></a>04507     {
<a name="l04508"></a>04508         setApplicationArguments(argc, const_cast&lt;char**&gt;(argv));
<a name="l04509"></a>04509     }
<a name="l04510"></a>04510 
<a name="l04511"></a>04511     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TPtr&gt;
<a name="l04512"></a>04512     <span class="keyword">inline</span> <span class="keywordtype">bool</span> installCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, std::map&lt;std::string, TPtr&gt;* mapT)
<a name="l04513"></a>04513     {
<a name="l04514"></a>04514         <span class="keywordflow">if</span> (mapT-&gt;find(<span class="keywordtype">id</span>) == mapT-&gt;end()) {
<a name="l04515"></a>04515             mapT-&gt;insert(std::make_pair(<span class="keywordtype">id</span>, TPtr(<span class="keyword">new</span> T())));
<a name="l04516"></a>04516             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04517"></a>04517         }
<a name="l04518"></a>04518         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04519"></a>04519     }
<a name="l04520"></a>04520 
<a name="l04521"></a>04521     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TPtr&gt;
<a name="l04522"></a>04522     <span class="keyword">inline</span> <span class="keywordtype">void</span> uninstallCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, std::map&lt;std::string, TPtr&gt;* mapT)
<a name="l04523"></a>04523     {
<a name="l04524"></a>04524         <span class="keywordflow">if</span> (mapT-&gt;find(<span class="keywordtype">id</span>) != mapT-&gt;end()) {
<a name="l04525"></a>04525             mapT-&gt;erase(<span class="keywordtype">id</span>);
<a name="l04526"></a>04526         }
<a name="l04527"></a>04527     }
<a name="l04528"></a>04528 
<a name="l04529"></a>04529     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TPtr&gt;
<a name="l04530"></a>04530     <span class="keyword">inline</span> T* callback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>, std::map&lt;std::string, TPtr&gt;* mapT)
<a name="l04531"></a>04531     {
<a name="l04532"></a>04532         <span class="keyword">typename</span> std::map&lt;std::string, TPtr&gt;::iterator iter = mapT-&gt;find(<span class="keywordtype">id</span>);
<a name="l04533"></a>04533         <span class="keywordflow">if</span> (iter != mapT-&gt;end()) {
<a name="l04534"></a>04534             <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(iter-&gt;second.get());
<a name="l04535"></a>04535         }
<a name="l04536"></a>04536         <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l04537"></a>04537     }
<a name="l04538"></a>04538 };
<a name="l04539"></a>04539 <span class="keyword">extern</span> ELPP_EXPORT base::type::StoragePointer elStorage;
<a name="l04540"></a>04540 <span class="preprocessor">#define ELPP el::base::elStorage</span>
<a name="l04541"></a>04541 <span class="preprocessor"></span><span class="keyword">class </span>DefaultLogDispatchCallback : <span class="keyword">public</span> LogDispatchCallback
<a name="l04542"></a>04542 {
<a name="l04543"></a>04543 <span class="keyword">protected</span>:
<a name="l04544"></a>04544     <span class="keywordtype">void</span> handle(<span class="keyword">const</span> LogDispatchData* data)
<a name="l04545"></a>04545     {
<a name="l04546"></a>04546         m_data = data;
<a name="l04547"></a>04547         dispatch(std::move(m_data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;build(m_data-&gt;logMessage(),
<a name="l04548"></a>04548                            m_data-&gt;dispatchAction() == base::DispatchAction::NormalLog)));
<a name="l04549"></a>04549     }
<a name="l04550"></a>04550 <span class="keyword">private</span>:
<a name="l04551"></a>04551     <span class="keyword">const</span> LogDispatchData* m_data;
<a name="l04552"></a>04552     <span class="keywordtype">void</span> dispatch(base::type::string_t&amp;&amp; logLine)
<a name="l04553"></a>04553     {
<a name="l04554"></a>04554         <span class="keywordflow">if</span> (m_data-&gt;dispatchAction() == base::DispatchAction::NormalLog) {
<a name="l04555"></a>04555             <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;toFile(m_data-&gt;logMessage()-&gt;level())) {
<a name="l04556"></a>04556                 base::type::fstream_t* fs = m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;fileStream(m_data-&gt;logMessage()-&gt;level());
<a name="l04557"></a>04557                 <span class="keywordflow">if</span> (fs != <span class="keyword">nullptr</span>) {
<a name="l04558"></a>04558                     fs-&gt;write(logLine.c_str(), logLine.size());
<a name="l04559"></a>04559                     <span class="keywordflow">if</span> (fs-&gt;fail()) {
<a name="l04560"></a>04560                         ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Unable to write log to file [&quot;</span>
<a name="l04561"></a>04561                                             &lt;&lt; m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;filename(m_data-&gt;logMessage()-&gt;level()) &lt;&lt; <span class="stringliteral">&quot;].\n&quot;</span>
<a name="l04562"></a>04562                                             &lt;&lt; <span class="stringliteral">&quot;Few possible reasons (could be something else):\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;      * Permission denied\n&quot;</span>
<a name="l04563"></a>04563                                             &lt;&lt; <span class="stringliteral">&quot;      * Disk full\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;      * Disk is not writable&quot;</span>, <span class="keyword">true</span>);
<a name="l04564"></a>04564                     } <span class="keywordflow">else</span> {
<a name="l04565"></a>04565                         <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::ImmediateFlush) || (m_data-&gt;logMessage()-&gt;logger()-&gt;isFlushNeeded(m_data-&gt;logMessage()-&gt;level()))) {
<a name="l04566"></a>04566                             m_data-&gt;logMessage()-&gt;logger()-&gt;flush(m_data-&gt;logMessage()-&gt;level(), fs);
<a name="l04567"></a>04567                         }
<a name="l04568"></a>04568                     }
<a name="l04569"></a>04569                 } <span class="keywordflow">else</span> {
<a name="l04570"></a>04570                     ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Log file for [&quot;</span> &lt;&lt; LevelHelper::convertToString(m_data-&gt;logMessage()-&gt;level()) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>
<a name="l04571"></a>04571                                         &lt;&lt; <span class="stringliteral">&quot;has not been configured but [TO_FILE] is configured to TRUE. [Logger ID: &quot;</span>
<a name="l04572"></a>04572                                         &lt;&lt; m_data-&gt;logMessage()-&gt;logger()-&gt;id() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>, <span class="keyword">false</span>);
<a name="l04573"></a>04573                 }
<a name="l04574"></a>04574             }
<a name="l04575"></a>04575             <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;toStandardOutput(m_data-&gt;logMessage()-&gt;level())) {
<a name="l04576"></a>04576                 <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::ColoredTerminalOutput))
<a name="l04577"></a>04577                     m_data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;convertToColoredOutput(&amp;logLine, m_data-&gt;logMessage()-&gt;level());
<a name="l04578"></a>04578                 ELPP_COUT &lt;&lt; ELPP_COUT_LINE(logLine);
<a name="l04579"></a>04579             }
<a name="l04580"></a>04580         }
<a name="l04581"></a>04581 <span class="preprocessor">#if defined(ELPP_SYSLOG)</span>
<a name="l04582"></a>04582 <span class="preprocessor"></span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_data-&gt;dispatchAction() == base::DispatchAction::SysLog) {
<a name="l04583"></a>04583             <span class="comment">// Determine syslog priority</span>
<a name="l04584"></a>04584             <span class="keywordtype">int</span> sysLogPriority = 0;
<a name="l04585"></a>04585             <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;level() == Level::Fatal)
<a name="l04586"></a>04586                 sysLogPriority = LOG_EMERG;
<a name="l04587"></a>04587             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;level() == Level::Error)
<a name="l04588"></a>04588                 sysLogPriority = LOG_ERR;
<a name="l04589"></a>04589             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;level() == Level::Warning)
<a name="l04590"></a>04590                 sysLogPriority = LOG_WARNING;
<a name="l04591"></a>04591             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;level() == Level::Info)
<a name="l04592"></a>04592                 sysLogPriority = LOG_INFO;
<a name="l04593"></a>04593             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_data-&gt;logMessage()-&gt;level() == Level::Debug)
<a name="l04594"></a>04594                 sysLogPriority = LOG_DEBUG;
<a name="l04595"></a>04595             <span class="keywordflow">else</span>
<a name="l04596"></a>04596                 sysLogPriority = LOG_NOTICE;
<a name="l04597"></a>04597 <span class="preprocessor">#   if defined(ELPP_UNICODE)</span>
<a name="l04598"></a>04598 <span class="preprocessor"></span>            <span class="keywordtype">char</span>* line = base::utils::Str::wcharPtrToCharPtr(logLine.c_str());
<a name="l04599"></a>04599             syslog(sysLogPriority, <span class="stringliteral">&quot;%s&quot;</span>, line);
<a name="l04600"></a>04600             free(line);
<a name="l04601"></a>04601 <span class="preprocessor">#   else</span>
<a name="l04602"></a>04602 <span class="preprocessor"></span>            syslog(sysLogPriority, <span class="stringliteral">&quot;%s&quot;</span>, logLine.c_str());
<a name="l04603"></a>04603 <span class="preprocessor">#   endif</span>
<a name="l04604"></a>04604 <span class="preprocessor"></span>        }
<a name="l04605"></a>04605 <span class="preprocessor">#endif  // defined(ELPP_SYSLOG)</span>
<a name="l04606"></a>04606 <span class="preprocessor"></span>    }
<a name="l04607"></a>04607 };
<a name="l04608"></a>04608 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l04609"></a>04609 <span class="preprocessor"></span><span class="keyword">class </span>AsyncLogDispatchCallback : <span class="keyword">public</span> LogDispatchCallback
<a name="l04610"></a>04610 {
<a name="l04611"></a>04611 <span class="keyword">protected</span>:
<a name="l04612"></a>04612     <span class="keywordtype">void</span> handle(<span class="keyword">const</span> LogDispatchData* data)
<a name="l04613"></a>04613     {
<a name="l04614"></a>04614         base::type::string_t logLine = data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;build(data-&gt;logMessage(), data-&gt;dispatchAction() == base::DispatchAction::NormalLog);
<a name="l04615"></a>04615         <span class="keywordflow">if</span> (data-&gt;dispatchAction() == base::DispatchAction::NormalLog &amp;&amp; data-&gt;logMessage()-&gt;logger()-&gt;typedConfigurations()-&gt;toStandardOutput(data-&gt;logMessage()-&gt;level())) {
<a name="l04616"></a>04616             <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::ColoredTerminalOutput))
<a name="l04617"></a>04617                 data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;convertToColoredOutput(&amp;logLine, data-&gt;logMessage()-&gt;level());
<a name="l04618"></a>04618             ELPP_COUT &lt;&lt; ELPP_COUT_LINE(logLine);
<a name="l04619"></a>04619         }
<a name="l04620"></a>04620         <span class="comment">// Save resources and only queue if we want to write to file otherwise just ignore handler</span>
<a name="l04621"></a>04621         <span class="keywordflow">if</span> (data-&gt;logMessage()-&gt;logger()-&gt;typedConfigurations()-&gt;toFile(data-&gt;logMessage()-&gt;level())) {
<a name="l04622"></a>04622             ELPP-&gt;asyncLogQueue()-&gt;push(AsyncLogItem(*(data-&gt;logMessage()), *data, logLine));
<a name="l04623"></a>04623         }
<a name="l04624"></a>04624     }
<a name="l04625"></a>04625 };
<a name="l04626"></a>04626 <span class="keyword">class </span>AsyncDispatchWorker : <span class="keyword">public</span> base::IWorker, <span class="keyword">public</span> base::threading::ThreadSafe
<a name="l04627"></a>04627 {
<a name="l04628"></a>04628 <span class="keyword">public</span>:
<a name="l04629"></a>04629     AsyncDispatchWorker()
<a name="l04630"></a>04630     {
<a name="l04631"></a>04631         setContinueRunning(<span class="keyword">false</span>);
<a name="l04632"></a>04632     }
<a name="l04633"></a>04633 
<a name="l04634"></a>04634     <span class="keyword">virtual</span> ~AsyncDispatchWorker()
<a name="l04635"></a>04635     {
<a name="l04636"></a>04636         setContinueRunning(<span class="keyword">false</span>);
<a name="l04637"></a>04637         ELPP_INTERNAL_INFO(6, <span class="stringliteral">&quot;Stopping dispatch worker - Cleaning log queue&quot;</span>);
<a name="l04638"></a>04638         clean();
<a name="l04639"></a>04639         ELPP_INTERNAL_INFO(6, <span class="stringliteral">&quot;Log queue cleaned&quot;</span>);
<a name="l04640"></a>04640     }
<a name="l04641"></a>04641 
<a name="l04642"></a>04642     <span class="keyword">inline</span> <span class="keywordtype">bool</span> clean()
<a name="l04643"></a>04643     {
<a name="l04644"></a>04644         std::mutex m;
<a name="l04645"></a>04645         std::unique_lock&lt;std::mutex&gt; lk(m);
<a name="l04646"></a>04646         cv.wait(lk, [] { <span class="keywordflow">return</span> !ELPP-&gt;asyncLogQueue()-&gt;empty(); });
<a name="l04647"></a>04647         emptyQueue();
<a name="l04648"></a>04648         lk.unlock();
<a name="l04649"></a>04649         cv.notify_one();
<a name="l04650"></a>04650         <span class="keywordflow">return</span> ELPP-&gt;asyncLogQueue()-&gt;empty();
<a name="l04651"></a>04651     }
<a name="l04652"></a>04652 
<a name="l04653"></a>04653     <span class="keyword">inline</span> <span class="keywordtype">void</span> emptyQueue()
<a name="l04654"></a>04654     {
<a name="l04655"></a>04655         <span class="keywordflow">while</span> (!ELPP-&gt;asyncLogQueue()-&gt;empty()) {
<a name="l04656"></a>04656             AsyncLogItem data = ELPP-&gt;asyncLogQueue()-&gt;next();
<a name="l04657"></a>04657             handle(&amp;data);
<a name="l04658"></a>04658             base::threading::msleep(100);
<a name="l04659"></a>04659         }
<a name="l04660"></a>04660     }
<a name="l04661"></a>04661 
<a name="l04662"></a>04662     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> start()
<a name="l04663"></a>04663     {
<a name="l04664"></a>04664         base::threading::msleep(5000); <span class="comment">// Wait extra few seconds</span>
<a name="l04665"></a>04665         setContinueRunning(<span class="keyword">true</span>);
<a name="l04666"></a>04666         std::thread t1(&amp;AsyncDispatchWorker::runner, <span class="keyword">this</span>);
<a name="l04667"></a>04667         t1.join();
<a name="l04668"></a>04668     }
<a name="l04669"></a>04669 
<a name="l04670"></a>04670     <span class="keywordtype">void</span> handle(AsyncLogItem* logItem)
<a name="l04671"></a>04671     {
<a name="l04672"></a>04672         LogDispatchData* data = logItem-&gt;data();
<a name="l04673"></a>04673         LogMessage* logMessage = logItem-&gt;logMessage();
<a name="l04674"></a>04674         Logger* logger = logMessage-&gt;logger();
<a name="l04675"></a>04675         base::TypedConfigurations* conf = logger-&gt;typedConfigurations();
<a name="l04676"></a>04676         base::type::string_t logLine = logItem-&gt;logLine();
<a name="l04677"></a>04677         <span class="keywordflow">if</span> (data-&gt;dispatchAction() == base::DispatchAction::NormalLog) {
<a name="l04678"></a>04678             <span class="keywordflow">if</span> (conf-&gt;toFile(logMessage-&gt;level())) {
<a name="l04679"></a>04679                 base::type::fstream_t* fs = conf-&gt;fileStream(logMessage-&gt;level());
<a name="l04680"></a>04680                 <span class="keywordflow">if</span> (fs != <span class="keyword">nullptr</span>) {
<a name="l04681"></a>04681                     fs-&gt;write(logLine.c_str(), logLine.size());
<a name="l04682"></a>04682                     <span class="keywordflow">if</span> (fs-&gt;fail()) {
<a name="l04683"></a>04683                         ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Unable to write log to file [&quot;</span>
<a name="l04684"></a>04684                                             &lt;&lt; conf-&gt;filename(logMessage-&gt;level()) &lt;&lt; <span class="stringliteral">&quot;].\n&quot;</span>
<a name="l04685"></a>04685                                             &lt;&lt; <span class="stringliteral">&quot;Few possible reasons (could be something else):\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;      * Permission denied\n&quot;</span>
<a name="l04686"></a>04686                                             &lt;&lt; <span class="stringliteral">&quot;      * Disk full\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;      * Disk is not writable&quot;</span>, <span class="keyword">true</span>);
<a name="l04687"></a>04687                     } <span class="keywordflow">else</span> {
<a name="l04688"></a>04688                         <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::ImmediateFlush) || (logger-&gt;isFlushNeeded(logMessage-&gt;level()))) {
<a name="l04689"></a>04689                             logger-&gt;flush(logMessage-&gt;level(), fs);
<a name="l04690"></a>04690                         }
<a name="l04691"></a>04691                     }
<a name="l04692"></a>04692                 } <span class="keywordflow">else</span> {
<a name="l04693"></a>04693                     ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Log file for [&quot;</span> &lt;&lt; LevelHelper::convertToString(logMessage-&gt;level()) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>
<a name="l04694"></a>04694                                         &lt;&lt; <span class="stringliteral">&quot;has not been configured but [TO_FILE] is configured to TRUE. [Logger ID: &quot;</span> &lt;&lt; logger-&gt;id() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>, <span class="keyword">false</span>);
<a name="l04695"></a>04695                 }
<a name="l04696"></a>04696             }
<a name="l04697"></a>04697         }
<a name="l04698"></a>04698 <span class="preprocessor">#   if defined(ELPP_SYSLOG)</span>
<a name="l04699"></a>04699 <span class="preprocessor"></span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (data-&gt;dispatchAction() == base::DispatchAction::SysLog) {
<a name="l04700"></a>04700             <span class="comment">// Determine syslog priority</span>
<a name="l04701"></a>04701             <span class="keywordtype">int</span> sysLogPriority = 0;
<a name="l04702"></a>04702             <span class="keywordflow">if</span> (logMessage-&gt;level() == Level::Fatal)
<a name="l04703"></a>04703                 sysLogPriority = LOG_EMERG;
<a name="l04704"></a>04704             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (logMessage-&gt;level() == Level::Error)
<a name="l04705"></a>04705                 sysLogPriority = LOG_ERR;
<a name="l04706"></a>04706             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (logMessage-&gt;level() == Level::Warning)
<a name="l04707"></a>04707                 sysLogPriority = LOG_WARNING;
<a name="l04708"></a>04708             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (logMessage-&gt;level() == Level::Info)
<a name="l04709"></a>04709                 sysLogPriority = LOG_INFO;
<a name="l04710"></a>04710             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (logMessage-&gt;level() == Level::Debug)
<a name="l04711"></a>04711                 sysLogPriority = LOG_DEBUG;
<a name="l04712"></a>04712             <span class="keywordflow">else</span>
<a name="l04713"></a>04713                 sysLogPriority = LOG_NOTICE;
<a name="l04714"></a>04714 <span class="preprocessor">#      if defined(ELPP_UNICODE)</span>
<a name="l04715"></a>04715 <span class="preprocessor"></span>            <span class="keywordtype">char</span>* line = base::utils::Str::wcharPtrToCharPtr(logLine.c_str());
<a name="l04716"></a>04716             syslog(sysLogPriority, <span class="stringliteral">&quot;%s&quot;</span>, line);
<a name="l04717"></a>04717             free(line);
<a name="l04718"></a>04718 <span class="preprocessor">#      else</span>
<a name="l04719"></a>04719 <span class="preprocessor"></span>            syslog(sysLogPriority, <span class="stringliteral">&quot;%s&quot;</span>, logLine.c_str());
<a name="l04720"></a>04720 <span class="preprocessor">#      endif</span>
<a name="l04721"></a>04721 <span class="preprocessor"></span>        }
<a name="l04722"></a>04722 <span class="preprocessor">#   endif  // defined(ELPP_SYSLOG)</span>
<a name="l04723"></a>04723 <span class="preprocessor"></span>    }
<a name="l04724"></a>04724 
<a name="l04725"></a>04725     <span class="keywordtype">void</span> run()
<a name="l04726"></a>04726     {
<a name="l04727"></a>04727         <span class="keywordflow">while</span> (continueRunning()) {
<a name="l04728"></a>04728             emptyQueue();
<a name="l04729"></a>04729             base::threading::msleep(10); <span class="comment">// 10ms</span>
<a name="l04730"></a>04730         }
<a name="l04731"></a>04731     }
<a name="l04732"></a>04732 
<a name="l04733"></a>04733     <span class="keyword">static</span> <span class="keywordtype">void</span>* runner(<span class="keywordtype">void</span>* context)
<a name="l04734"></a>04734     {
<a name="l04735"></a>04735         <span class="keyword">static_cast&lt;</span>AsyncDispatchWorker*<span class="keyword">&gt;</span>(context)-&gt;run();
<a name="l04736"></a>04736         <span class="keywordflow">return</span> NULL;
<a name="l04737"></a>04737     }
<a name="l04738"></a>04738 
<a name="l04739"></a>04739     <span class="keywordtype">void</span> setContinueRunning(<span class="keywordtype">bool</span> value)
<a name="l04740"></a>04740     {
<a name="l04741"></a>04741         base::threading::ScopedLock scopedLock(m_continueRunningMutex);
<a name="l04742"></a>04742         m_continueRunning = value;
<a name="l04743"></a>04743     }
<a name="l04744"></a>04744     <span class="keywordtype">bool</span> continueRunning(<span class="keywordtype">void</span>)
<a name="l04745"></a>04745     {
<a name="l04746"></a>04746         <span class="keywordflow">return</span> m_continueRunning;
<a name="l04747"></a>04747     }
<a name="l04748"></a>04748 <span class="keyword">private</span>:
<a name="l04749"></a>04749     std::condition_variable cv;
<a name="l04750"></a>04750     <span class="keywordtype">bool</span> m_continueRunning;
<a name="l04751"></a>04751     base::threading::Mutex m_continueRunningMutex;
<a name="l04752"></a>04752 };
<a name="l04753"></a>04753 <span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l04754"></a>04754 <span class="preprocessor"></span>}  <span class="comment">// namespace base</span>
<a name="l04755"></a>04755 <span class="keyword">namespace </span>base {
<a name="l04756"></a>04756 <span class="keyword">class </span>DefaultLogBuilder : <span class="keyword">public</span> LogBuilder
<a name="l04757"></a>04757 {
<a name="l04758"></a>04758 <span class="keyword">public</span>:
<a name="l04759"></a>04759     base::type::string_t build(<span class="keyword">const</span> LogMessage* logMessage, <span class="keywordtype">bool</span> appendNewLine)<span class="keyword"> const</span>
<a name="l04760"></a>04760 <span class="keyword">    </span>{
<a name="l04761"></a>04761         base::TypedConfigurations* tc = logMessage-&gt;logger()-&gt;typedConfigurations();
<a name="l04762"></a>04762         <span class="keyword">const</span> base::LogFormat* logFormat = &amp;tc-&gt;logFormat(logMessage-&gt;level());
<a name="l04763"></a>04763         base::type::string_t logLine = logFormat-&gt;format();
<a name="l04764"></a>04764         <span class="keywordtype">char</span> buff[base::consts::kSourceFilenameMaxLength + base::consts::kSourceLineMaxLength] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l04765"></a>04765         <span class="keyword">const</span> <span class="keywordtype">char</span>* bufLim = buff + <span class="keyword">sizeof</span>(buff);
<a name="l04766"></a>04766         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::AppName)) {
<a name="l04767"></a>04767             <span class="comment">// App name</span>
<a name="l04768"></a>04768             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kAppNameFormatSpecifier,
<a name="l04769"></a>04769                     logMessage-&gt;logger()-&gt;parentApplicationName());
<a name="l04770"></a>04770         }
<a name="l04771"></a>04771         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::ThreadId)) {
<a name="l04772"></a>04772             <span class="comment">// Thread ID</span>
<a name="l04773"></a>04773             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kThreadIdFormatSpecifier,
<a name="l04774"></a>04774                     base::threading::getCurrentThreadId());
<a name="l04775"></a>04775         }
<a name="l04776"></a>04776         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::DateTime)) {
<a name="l04777"></a>04777             <span class="comment">// DateTime</span>
<a name="l04778"></a>04778             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kDateTimeFormatSpecifier,
<a name="l04779"></a>04779                     base::utils::DateTime::getDateTime(logFormat-&gt;dateTimeFormat().c_str(),
<a name="l04780"></a>04780                             &amp;tc-&gt;millisecondsWidth(logMessage-&gt;level())));
<a name="l04781"></a>04781         }
<a name="l04782"></a>04782         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::Function)) {
<a name="l04783"></a>04783             <span class="comment">// Function</span>
<a name="l04784"></a>04784             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogFunctionFormatSpecifier, logMessage-&gt;func());
<a name="l04785"></a>04785         }
<a name="l04786"></a>04786         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::File)) {
<a name="l04787"></a>04787             <span class="comment">// File</span>
<a name="l04788"></a>04788             <span class="keywordtype">char</span>* buf = base::utils::Str::clearBuff(buff, base::consts::kSourceFilenameMaxLength);
<a name="l04789"></a>04789             base::utils::File::buildStrippedFilename(logMessage-&gt;file().c_str(), buff);
<a name="l04790"></a>04790             buf = base::utils::Str::addToBuff(buff, buf, bufLim);
<a name="l04791"></a>04791             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogFileFormatSpecifier, std::string(buff));
<a name="l04792"></a>04792         }
<a name="l04793"></a>04793         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::FileBase)) {
<a name="l04794"></a>04794             <span class="comment">// FileBase</span>
<a name="l04795"></a>04795             <span class="keywordtype">char</span>* buf = base::utils::Str::clearBuff(buff, base::consts::kSourceFilenameMaxLength);
<a name="l04796"></a>04796             base::utils::File::buildBaseFilename(logMessage-&gt;file(), buff);
<a name="l04797"></a>04797             buf = base::utils::Str::addToBuff(buff, buf, bufLim);
<a name="l04798"></a>04798             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogFileBaseFormatSpecifier, std::string(buff));
<a name="l04799"></a>04799         }
<a name="l04800"></a>04800         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::Line)) {
<a name="l04801"></a>04801             <span class="comment">// Line</span>
<a name="l04802"></a>04802             <span class="keywordtype">char</span>* buf = base::utils::Str::clearBuff(buff, base::consts::kSourceLineMaxLength);
<a name="l04803"></a>04803             buf = base::utils::Str::convertAndAddToBuff(logMessage-&gt;line(),
<a name="l04804"></a>04804                     base::consts::kSourceLineMaxLength, buf, bufLim, <span class="keyword">false</span>);
<a name="l04805"></a>04805             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogLineFormatSpecifier, std::string(buff));
<a name="l04806"></a>04806         }
<a name="l04807"></a>04807         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::Location)) {
<a name="l04808"></a>04808             <span class="comment">// Location</span>
<a name="l04809"></a>04809             <span class="keywordtype">char</span>* buf = base::utils::Str::clearBuff(buff,
<a name="l04810"></a>04810                                                     base::consts::kSourceFilenameMaxLength + base::consts::kSourceLineMaxLength);
<a name="l04811"></a>04811             base::utils::File::buildStrippedFilename(logMessage-&gt;file().c_str(), buff);
<a name="l04812"></a>04812             buf = base::utils::Str::addToBuff(buff, buf, bufLim);
<a name="l04813"></a>04813             buf = base::utils::Str::addToBuff(<span class="stringliteral">&quot;:&quot;</span>, buf, bufLim);
<a name="l04814"></a>04814             buf = base::utils::Str::convertAndAddToBuff(logMessage-&gt;line(),
<a name="l04815"></a>04815                     base::consts::kSourceLineMaxLength, buf, bufLim, <span class="keyword">false</span>);
<a name="l04816"></a>04816             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogLocationFormatSpecifier, std::string(buff));
<a name="l04817"></a>04817         }
<a name="l04818"></a>04818         <span class="keywordflow">if</span> (logMessage-&gt;level() == Level::Verbose &amp;&amp; logFormat-&gt;hasFlag(base::FormatFlags::VerboseLevel)) {
<a name="l04819"></a>04819             <span class="comment">// Verbose level</span>
<a name="l04820"></a>04820             <span class="keywordtype">char</span>* buf = base::utils::Str::clearBuff(buff, 1);
<a name="l04821"></a>04821             buf = base::utils::Str::convertAndAddToBuff(logMessage-&gt;verboseLevel(), 1, buf, bufLim, <span class="keyword">false</span>);
<a name="l04822"></a>04822             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kVerboseLevelFormatSpecifier, std::string(buff));
<a name="l04823"></a>04823         }
<a name="l04824"></a>04824         <span class="keywordflow">if</span> (logFormat-&gt;hasFlag(base::FormatFlags::LogMessage)) {
<a name="l04825"></a>04825             <span class="comment">// Log message</span>
<a name="l04826"></a>04826             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kMessageFormatSpecifier, logMessage-&gt;message());
<a name="l04827"></a>04827         }
<a name="l04828"></a>04828 <span class="preprocessor">#if !defined(ELPP_DISABLE_CUSTOM_FORMAT_SPECIFIERS)</span>
<a name="l04829"></a>04829 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (std::vector&lt;CustomFormatSpecifier&gt;::const_iterator it = ELPP-&gt;customFormatSpecifiers()-&gt;begin();
<a name="l04830"></a>04830                 it != ELPP-&gt;customFormatSpecifiers()-&gt;end(); ++it) {
<a name="l04831"></a>04831             std::string fs(it-&gt;formatSpecifier());
<a name="l04832"></a>04832             base::type::string_t wcsFormatSpecifier(fs.begin(), fs.end());
<a name="l04833"></a>04833             base::utils::Str::replaceFirstWithEscape(logLine, wcsFormatSpecifier, std::string(it-&gt;resolver()()));
<a name="l04834"></a>04834         }
<a name="l04835"></a>04835 <span class="preprocessor">#endif  // !defined(ELPP_DISABLE_CUSTOM_FORMAT_SPECIFIERS)</span>
<a name="l04836"></a>04836 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (appendNewLine) logLine += ELPP_LITERAL(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l04837"></a>04837         <span class="keywordflow">return</span> logLine;
<a name="l04838"></a>04838     }
<a name="l04839"></a>04839 };
<a name="l04841"></a>04841 <span class="keyword">class </span>LogDispatcher : base::NoCopy
<a name="l04842"></a>04842 {
<a name="l04843"></a>04843 <span class="keyword">public</span>:
<a name="l04844"></a>04844     LogDispatcher(<span class="keywordtype">bool</span> proceed, LogMessage&amp;&amp; logMessage, base::DispatchAction dispatchAction) :
<a name="l04845"></a>04845         m_proceed(proceed),
<a name="l04846"></a>04846         m_logMessage(std::move(logMessage)),
<a name="l04847"></a>04847         m_dispatchAction(std::move(dispatchAction))
<a name="l04848"></a>04848     {
<a name="l04849"></a>04849     }
<a name="l04850"></a>04850 
<a name="l04851"></a>04851     <span class="keywordtype">void</span> dispatch(<span class="keywordtype">void</span>)
<a name="l04852"></a>04852     {
<a name="l04853"></a>04853         <span class="keywordflow">if</span> (m_proceed &amp;&amp; m_dispatchAction == base::DispatchAction::None) {
<a name="l04854"></a>04854             m_proceed = <span class="keyword">false</span>;
<a name="l04855"></a>04855         }
<a name="l04856"></a>04856         <span class="keywordflow">if</span> (!m_proceed) {
<a name="l04857"></a>04857             <span class="keywordflow">return</span>;
<a name="l04858"></a>04858         }
<a name="l04859"></a>04859         <span class="comment">// We minimize the time of ELPP&apos;s lock - this lock is released after log is written</span>
<a name="l04860"></a>04860         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<a name="l04861"></a>04861         base::TypedConfigurations* tc = m_logMessage.logger()-&gt;m_typedConfigurations;
<a name="l04862"></a>04862         <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::StrictLogFileSizeCheck)) {
<a name="l04863"></a>04863             tc-&gt;validateFileRolling(m_logMessage.level(), ELPP-&gt;preRollOutCallback());
<a name="l04864"></a>04864         }
<a name="l04865"></a>04865         LogDispatchCallback* callback = <span class="keyword">nullptr</span>;
<a name="l04866"></a>04866         LogDispatchData data;
<a name="l04867"></a>04867         <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;std::string, base::type::LogDispatchCallbackPtr&gt;&amp; h
<a name="l04868"></a>04868                 : ELPP-&gt;m_logDispatchCallbacks) {
<a name="l04869"></a>04869             callback = h.second.get();
<a name="l04870"></a>04870             <span class="keywordflow">if</span> (callback != <span class="keyword">nullptr</span> &amp;&amp; callback-&gt;enabled()) {
<a name="l04871"></a>04871                 data.setLogMessage(&amp;m_logMessage);
<a name="l04872"></a>04872                 data.setDispatchAction(m_dispatchAction);
<a name="l04873"></a>04873                 callback-&gt;acquireLock();
<a name="l04874"></a>04874                 callback-&gt;handle(&amp;data);
<a name="l04875"></a>04875                 callback-&gt;releaseLock();
<a name="l04876"></a>04876             }
<a name="l04877"></a>04877         }
<a name="l04878"></a>04878     }
<a name="l04879"></a>04879 
<a name="l04880"></a>04880 <span class="keyword">private</span>:
<a name="l04881"></a>04881     <span class="keywordtype">bool</span> m_proceed;
<a name="l04882"></a>04882     LogMessage m_logMessage;
<a name="l04883"></a>04883     base::DispatchAction m_dispatchAction;
<a name="l04884"></a>04884 };
<a name="l04885"></a>04885 <span class="preprocessor">#if defined(ELPP_STL_LOGGING)</span>
<a name="l04892"></a>04892 <span class="preprocessor">namespace workarounds {</span>
<a name="l04894"></a>04894 <span class="preprocessor">template &lt;typename T, typename Container&gt;</span>
<a name="l04895"></a>04895 <span class="preprocessor"></span><span class="keyword">class </span>IterableContainer
<a name="l04896"></a>04896 {
<a name="l04897"></a>04897 <span class="keyword">public</span>:
<a name="l04898"></a>04898     <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iterator;
<a name="l04899"></a>04899     <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::const_iterator const_iterator;
<a name="l04900"></a>04900     IterableContainer(<span class="keywordtype">void</span>) {}
<a name="l04901"></a>04901     <span class="keyword">virtual</span> ~IterableContainer(<span class="keywordtype">void</span>) {}
<a name="l04902"></a>04902     iterator begin(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> getContainer().begin(); }
<a name="l04903"></a>04903     iterator end(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> getContainer().end(); }
<a name="l04904"></a>04904 <span class="keyword">private</span>:
<a name="l04905"></a>04905     <span class="keyword">virtual</span> Container&amp; getContainer(<span class="keywordtype">void</span>) = 0;
<a name="l04906"></a>04906 };
<a name="l04908"></a>04908 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::vector&lt;T&gt;, <span class="keyword">typename</span> Comparator = std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;&gt;
<a name="l04909"></a>04909 <span class="keyword">class </span>IterablePriorityQueue : <span class="keyword">public</span> IterableContainer&lt;T, Container&gt;, <span class="keyword">public</span> std::priority_queue&lt;T, Container, Comparator&gt;
<a name="l04910"></a>04910 {
<a name="l04911"></a>04911 <span class="keyword">public</span>:
<a name="l04912"></a>04912     IterablePriorityQueue(std::priority_queue&lt;T, Container, Comparator&gt; queue_)
<a name="l04913"></a>04913     {
<a name="l04914"></a>04914         std::size_t count_ = 0;
<a name="l04915"></a>04915         <span class="keywordflow">while</span> (++count_ &lt; base::consts::kMaxLogPerContainer &amp;&amp; !queue_.empty()) {
<a name="l04916"></a>04916             this-&gt;push(queue_.top());
<a name="l04917"></a>04917             queue_.pop();
<a name="l04918"></a>04918         }
<a name="l04919"></a>04919     }
<a name="l04920"></a>04920 <span class="keyword">private</span>:
<a name="l04921"></a>04921     <span class="keyword">inline</span> Container&amp; getContainer(<span class="keywordtype">void</span>)
<a name="l04922"></a>04922     {
<a name="l04923"></a>04923         <span class="keywordflow">return</span> this-&gt;c;
<a name="l04924"></a>04924     }
<a name="l04925"></a>04925 };
<a name="l04927"></a>04927 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::deque&lt;T&gt;&gt;
<a name="l04928"></a>04928 <span class="keyword">class </span>IterableQueue : <span class="keyword">public</span> IterableContainer&lt;T, Container&gt;, <span class="keyword">public</span> std::queue&lt;T, Container&gt;
<a name="l04929"></a>04929 {
<a name="l04930"></a>04930 <span class="keyword">public</span>:
<a name="l04931"></a>04931     IterableQueue(std::queue&lt;T, Container&gt; queue_)
<a name="l04932"></a>04932     {
<a name="l04933"></a>04933         std::size_t count_ = 0;
<a name="l04934"></a>04934         <span class="keywordflow">while</span> (++count_ &lt; base::consts::kMaxLogPerContainer &amp;&amp; !queue_.empty()) {
<a name="l04935"></a>04935             this-&gt;push(queue_.front());
<a name="l04936"></a>04936             queue_.pop();
<a name="l04937"></a>04937         }
<a name="l04938"></a>04938     }
<a name="l04939"></a>04939 <span class="keyword">private</span>:
<a name="l04940"></a>04940     <span class="keyword">inline</span> Container&amp; getContainer(<span class="keywordtype">void</span>)
<a name="l04941"></a>04941     {
<a name="l04942"></a>04942         <span class="keywordflow">return</span> this-&gt;c;
<a name="l04943"></a>04943     }
<a name="l04944"></a>04944 };
<a name="l04946"></a>04946 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::deque&lt;T&gt;&gt;
<a name="l04947"></a>04947 <span class="keyword">class </span>IterableStack : <span class="keyword">public</span> IterableContainer&lt;T, Container&gt;, <span class="keyword">public</span> std::stack&lt;T, Container&gt;
<a name="l04948"></a>04948 {
<a name="l04949"></a>04949 <span class="keyword">public</span>:
<a name="l04950"></a>04950     IterableStack(std::stack&lt;T, Container&gt; stack_)
<a name="l04951"></a>04951     {
<a name="l04952"></a>04952         std::size_t count_ = 0;
<a name="l04953"></a>04953         <span class="keywordflow">while</span> (++count_ &lt; base::consts::kMaxLogPerContainer &amp;&amp; !stack_.empty()) {
<a name="l04954"></a>04954             this-&gt;push(stack_.top());
<a name="l04955"></a>04955             stack_.pop();
<a name="l04956"></a>04956         }
<a name="l04957"></a>04957     }
<a name="l04958"></a>04958 <span class="keyword">private</span>:
<a name="l04959"></a>04959     <span class="keyword">inline</span> Container&amp; getContainer(<span class="keywordtype">void</span>)
<a name="l04960"></a>04960     {
<a name="l04961"></a>04961         <span class="keywordflow">return</span> this-&gt;c;
<a name="l04962"></a>04962     }
<a name="l04963"></a>04963 };
<a name="l04964"></a>04964 }  <span class="comment">// namespace workarounds</span>
<a name="l04965"></a>04965 <span class="preprocessor">#endif  // defined(ELPP_STL_LOGGING)</span>
<a name="l04966"></a>04966 <span class="preprocessor"></span><span class="comment">// Log message builder</span>
<a name="l04967"></a>04967 <span class="keyword">class </span>MessageBuilder
<a name="l04968"></a>04968 {
<a name="l04969"></a>04969 <span class="keyword">public</span>:
<a name="l04970"></a>04970     MessageBuilder(<span class="keywordtype">void</span>) : m_logger(nullptr), m_containerLogSeperator(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>)) {}
<a name="l04971"></a>04971     <span class="keywordtype">void</span> initialize(Logger* logger)
<a name="l04972"></a>04972     {
<a name="l04973"></a>04973         m_logger = logger;
<a name="l04974"></a>04974         m_containerLogSeperator = ELPP-&gt;hasFlag(LoggingFlag::NewLineForContainer) ?
<a name="l04975"></a>04975                                   ELPP_LITERAL(<span class="stringliteral">&quot;\n    &quot;</span>) : ELPP_LITERAL(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l04976"></a>04976     }
<a name="l04977"></a>04977 
<a name="l04978"></a>04978 <span class="preprocessor">#   define ELPP_SIMPLE_LOG(LOG_TYPE)\</span>
<a name="l04979"></a>04979 <span class="preprocessor">    inline MessageBuilder&amp; operator&lt;&lt;(LOG_TYPE msg) {\</span>
<a name="l04980"></a>04980 <span class="preprocessor">        m_logger-&gt;stream() &lt;&lt; msg;\</span>
<a name="l04981"></a>04981 <span class="preprocessor">        if (ELPP-&gt;hasFlag(LoggingFlag::AutoSpacing)) {\</span>
<a name="l04982"></a>04982 <span class="preprocessor">            m_logger-&gt;stream() &lt;&lt; &quot; &quot;;\</span>
<a name="l04983"></a>04983 <span class="preprocessor">        }\</span>
<a name="l04984"></a>04984 <span class="preprocessor">        return *this;\</span>
<a name="l04985"></a>04985 <span class="preprocessor">    }</span>
<a name="l04986"></a>04986 <span class="preprocessor"></span>
<a name="l04987"></a>04987     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(<span class="keyword">const</span> std::string&amp; msg)
<a name="l04988"></a>04988     {
<a name="l04989"></a>04989         <span class="keywordflow">return</span> operator&lt;&lt;(msg.c_str());
<a name="l04990"></a>04990     }
<a name="l04991"></a>04991     ELPP_SIMPLE_LOG(<span class="keywordtype">char</span>)
<a name="l04992"></a>04992     ELPP_SIMPLE_LOG(<span class="keywordtype">bool</span>)
<a name="l04993"></a>04993     ELPP_SIMPLE_LOG(<span class="keywordtype">signed</span> <span class="keywordtype">short</span>)
<a name="l04994"></a>04994     ELPP_SIMPLE_LOG(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)
<a name="l04995"></a>04995     ELPP_SIMPLE_LOG(<span class="keywordtype">signed</span> <span class="keywordtype">int</span>)
<a name="l04996"></a>04996     ELPP_SIMPLE_LOG(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)
<a name="l04997"></a>04997     ELPP_SIMPLE_LOG(<span class="keywordtype">signed</span> <span class="keywordtype">long</span>)
<a name="l04998"></a>04998     ELPP_SIMPLE_LOG(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)
<a name="l04999"></a>04999     ELPP_SIMPLE_LOG(<span class="keywordtype">float</span>)
<a name="l05000"></a>05000     ELPP_SIMPLE_LOG(<span class="keywordtype">double</span>)
<a name="l05001"></a>05001     ELPP_SIMPLE_LOG(<span class="keywordtype">char</span>*)
<a name="l05002"></a>05002     ELPP_SIMPLE_LOG(const <span class="keywordtype">char</span>*)
<a name="l05003"></a>05003     ELPP_SIMPLE_LOG(const <span class="keywordtype">void</span>*)
<a name="l05004"></a>05004     ELPP_SIMPLE_LOG(<span class="keywordtype">long</span> <span class="keywordtype">double</span>)
<a name="l05005"></a>05005     inline MessageBuilder&amp; operator&lt;&lt;(const std::wstring&amp; msg)
<a name="l05006"></a>05006     {
<a name="l05007"></a>05007         <span class="keywordflow">return</span> operator&lt;&lt;(msg.c_str());
<a name="l05008"></a>05008     }
<a name="l05009"></a>05009     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* msg)
<a name="l05010"></a>05010     {
<a name="l05011"></a>05011         <span class="keywordflow">if</span> (msg == <span class="keyword">nullptr</span>) {
<a name="l05012"></a>05012             m_logger-&gt;stream() &lt;&lt; base::consts::kNullPointer;
<a name="l05013"></a>05013             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05014"></a>05014         }
<a name="l05015"></a>05015 <span class="preprocessor">#   if defined(ELPP_UNICODE)</span>
<a name="l05016"></a>05016 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; msg;
<a name="l05017"></a>05017 <span class="preprocessor">#   else</span>
<a name="l05018"></a>05018 <span class="preprocessor"></span>        <span class="keywordtype">char</span>* buff_ = base::utils::Str::wcharPtrToCharPtr(msg);
<a name="l05019"></a>05019         m_logger-&gt;stream() &lt;&lt; buff_;
<a name="l05020"></a>05020         free(buff_);
<a name="l05021"></a>05021 <span class="preprocessor">#   endif</span>
<a name="l05022"></a>05022 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::AutoSpacing)) {
<a name="l05023"></a>05023             m_logger-&gt;stream() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l05024"></a>05024         }
<a name="l05025"></a>05025         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05026"></a>05026     }
<a name="l05027"></a>05027     <span class="comment">// ostream manipulators</span>
<a name="l05028"></a>05028     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(std::ostream &amp; (*OStreamMani)(std::ostream&amp;))
<a name="l05029"></a>05029     {
<a name="l05030"></a>05030         m_logger-&gt;stream() &lt;&lt; OStreamMani;
<a name="l05031"></a>05031         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05032"></a>05032     }
<a name="l05033"></a>05033 <span class="preprocessor">#define ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(temp)                                                    \</span>
<a name="l05034"></a>05034 <span class="preprocessor">    template &lt;typename T&gt;                                                                            \</span>
<a name="l05035"></a>05035 <span class="preprocessor">    inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T&gt;&amp; template_inst) {                                \</span>
<a name="l05036"></a>05036 <span class="preprocessor">        return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \</span>
<a name="l05037"></a>05037 <span class="preprocessor">    }</span>
<a name="l05038"></a>05038 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(temp)                                                    \</span>
<a name="l05039"></a>05039 <span class="preprocessor">    template &lt;typename T1, typename T2&gt;                                                              \</span>
<a name="l05040"></a>05040 <span class="preprocessor">    inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2&gt;&amp; template_inst) {                           \</span>
<a name="l05041"></a>05041 <span class="preprocessor">        return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \</span>
<a name="l05042"></a>05042 <span class="preprocessor">    }</span>
<a name="l05043"></a>05043 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(temp)                                                  \</span>
<a name="l05044"></a>05044 <span class="preprocessor">    template &lt;typename T1, typename T2, typename T3&gt;                                                 \</span>
<a name="l05045"></a>05045 <span class="preprocessor">    inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2, T3&gt;&amp; template_inst) {                       \</span>
<a name="l05046"></a>05046 <span class="preprocessor">        return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \</span>
<a name="l05047"></a>05047 <span class="preprocessor">    }</span>
<a name="l05048"></a>05048 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(temp)                                                   \</span>
<a name="l05049"></a>05049 <span class="preprocessor">    template &lt;typename T1, typename T2, typename T3, typename T4&gt;                                    \</span>
<a name="l05050"></a>05050 <span class="preprocessor">    inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2, T3, T4&gt;&amp; template_inst) {                   \</span>
<a name="l05051"></a>05051 <span class="preprocessor">        return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \</span>
<a name="l05052"></a>05052 <span class="preprocessor">    }</span>
<a name="l05053"></a>05053 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG(temp)                                                   \</span>
<a name="l05054"></a>05054 <span class="preprocessor">    template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;                       \</span>
<a name="l05055"></a>05055 <span class="preprocessor">    inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2, T3, T4, T5&gt;&amp; template_inst) {               \</span>
<a name="l05056"></a>05056 <span class="preprocessor">        return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \</span>
<a name="l05057"></a>05057 <span class="preprocessor">    }</span>
<a name="l05058"></a>05058 <span class="preprocessor"></span>
<a name="l05059"></a>05059 <span class="preprocessor">#if defined(ELPP_STL_LOGGING)</span>
<a name="l05060"></a>05060 <span class="preprocessor"></span>    ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(std::vector)
<a name="l05061"></a>05061     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(std::list)
<a name="l05062"></a>05062     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(std::deque)
<a name="l05063"></a>05063     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(std::set)
<a name="l05064"></a>05064     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(std::multiset)
<a name="l05065"></a>05065     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::map)
<a name="l05066"></a>05066     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::multimap)
<a name="l05067"></a>05067     template &lt;class T, class Container&gt;
<a name="l05068"></a>05068     inline MessageBuilder&amp; operator&lt;&lt;(const std::queue&lt;T, Container&gt;&amp; queue_)
<a name="l05069"></a>05069     {
<a name="l05070"></a>05070         base::workarounds::IterableQueue&lt;T, Container&gt; iterableQueue_ =
<a name="l05071"></a>05071             <span class="keyword">static_cast&lt;</span>base::workarounds::IterableQueue&lt;T, Container&gt; <span class="keyword">&gt;</span>(queue_);
<a name="l05072"></a>05072         <span class="keywordflow">return</span> writeIterator(iterableQueue_.begin(), iterableQueue_.end(), iterableQueue_.size());
<a name="l05073"></a>05073     }
<a name="l05074"></a>05074     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Container&gt;
<a name="l05075"></a>05075     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const std::stack&lt;T, Container&gt;&amp; stack_)
<a name="l05076"></a>05076     {
<a name="l05077"></a>05077         base::workarounds::IterableStack&lt;T, Container&gt; iterableStack_ =
<a name="l05078"></a>05078             <span class="keyword">static_cast&lt;</span>base::workarounds::IterableStack&lt;T, Container&gt; <span class="keyword">&gt;</span>(stack_);
<a name="l05079"></a>05079         <span class="keywordflow">return</span> writeIterator(iterableStack_.begin(), iterableStack_.end(), iterableStack_.size());
<a name="l05080"></a>05080     }
<a name="l05081"></a>05081     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Container, <span class="keyword">class</span> Comparator&gt;
<a name="l05082"></a>05082     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const std::priority_queue&lt;T, Container, Comparator&gt;&amp; priorityQueue_)
<a name="l05083"></a>05083     {
<a name="l05084"></a>05084         base::workarounds::IterablePriorityQueue&lt;T, Container, Comparator&gt; iterablePriorityQueue_ =
<a name="l05085"></a>05085             <span class="keyword">static_cast&lt;</span>base::workarounds::IterablePriorityQueue&lt;T, Container, Comparator&gt; <span class="keyword">&gt;</span>(priorityQueue_);
<a name="l05086"></a>05086         <span class="keywordflow">return</span> writeIterator(iterablePriorityQueue_.begin(), iterablePriorityQueue_.end(), iterablePriorityQueue_.size());
<a name="l05087"></a>05087     }
<a name="l05088"></a>05088     <span class="keyword">template</span> &lt;<span class="keyword">class</span> First, <span class="keyword">class</span> Second&gt;
<a name="l05089"></a>05089     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const std::pair&lt;First, Second&gt;&amp; pair_)
<a name="l05090"></a>05090     {
<a name="l05091"></a>05091         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;(&quot;</span>);
<a name="l05092"></a>05092         operator &lt;&lt; (static_cast&lt;First&gt;(pair_.first));
<a name="l05093"></a>05093         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l05094"></a>05094         operator &lt;&lt; (static_cast&lt;Second&gt;(pair_.second));
<a name="l05095"></a>05095         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;)&quot;</span>);
<a name="l05096"></a>05096         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05097"></a>05097     }
<a name="l05098"></a>05098     <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Size&gt;
<a name="l05099"></a>05099     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const std::bitset&lt;Size&gt;&amp; bitset_)
<a name="l05100"></a>05100     {
<a name="l05101"></a>05101         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;[&quot;</span>);
<a name="l05102"></a>05102         operator &lt;&lt; (bitset_.to_string());
<a name="l05103"></a>05103         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05104"></a>05104         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05105"></a>05105     }
<a name="l05106"></a>05106 <span class="preprocessor">#   if defined(ELPP_LOG_STD_ARRAY)</span>
<a name="l05107"></a>05107 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Size&gt;
<a name="l05108"></a>05108     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const std::array&lt;T, Size&gt;&amp; array)
<a name="l05109"></a>05109     {
<a name="l05110"></a>05110         <span class="keywordflow">return</span> writeIterator(array.begin(), array.end(), array.size());
<a name="l05111"></a>05111     }
<a name="l05112"></a>05112 <span class="preprocessor">#   endif  // defined(ELPP_LOG_STD_ARRAY)</span>
<a name="l05113"></a>05113 <span class="preprocessor"></span><span class="preprocessor">#   if defined(ELPP_LOG_UNORDERED_MAP)</span>
<a name="l05114"></a>05114 <span class="preprocessor"></span>    ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG(std::unordered_map)
<a name="l05115"></a>05115     ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG(std::unordered_multimap)
<a name="l05116"></a>05116 <span class="preprocessor">#   endif  // defined(ELPP_LOG_UNORDERED_MAP)</span>
<a name="l05117"></a>05117 <span class="preprocessor"></span><span class="preprocessor">#   if defined(ELPP_LOG_UNORDERED_SET)</span>
<a name="l05118"></a>05118 <span class="preprocessor"></span>    ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::unordered_set)
<a name="l05119"></a>05119     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::unordered_multiset)
<a name="l05120"></a>05120 <span class="preprocessor">#   endif  // defined(ELPP_LOG_UNORDERED_SET)</span>
<a name="l05121"></a>05121 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_STL_LOGGING)</span>
<a name="l05122"></a>05122 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_QT_LOGGING)</span>
<a name="l05123"></a>05123 <span class="preprocessor"></span>    <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(<span class="keyword">const</span> QString&amp; msg)
<a name="l05124"></a>05124     {
<a name="l05125"></a>05125 <span class="preprocessor">#   if defined(ELPP_UNICODE)</span>
<a name="l05126"></a>05126 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; msg.toStdWString();
<a name="l05127"></a>05127 <span class="preprocessor">#   else</span>
<a name="l05128"></a>05128 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; msg.toStdString();
<a name="l05129"></a>05129 <span class="preprocessor">#   endif  // defined(ELPP_UNICODE)</span>
<a name="l05130"></a>05130 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05131"></a>05131     }
<a name="l05132"></a>05132     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(<span class="keyword">const</span> QByteArray&amp; msg)
<a name="l05133"></a>05133     {
<a name="l05134"></a>05134         <span class="keywordflow">return</span> operator &lt;&lt; (QString(msg));
<a name="l05135"></a>05135     }
<a name="l05136"></a>05136     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(<span class="keyword">const</span> QStringRef&amp; msg)
<a name="l05137"></a>05137     {
<a name="l05138"></a>05138         <span class="keywordflow">return</span> operator&lt;&lt;(msg.toString());
<a name="l05139"></a>05139     }
<a name="l05140"></a>05140     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(qint64 msg)
<a name="l05141"></a>05141     {
<a name="l05142"></a>05142 <span class="preprocessor">#   if defined(ELPP_UNICODE)</span>
<a name="l05143"></a>05143 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdWString();
<a name="l05144"></a>05144 <span class="preprocessor">#   else</span>
<a name="l05145"></a>05145 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdString();
<a name="l05146"></a>05146 <span class="preprocessor">#   endif  // defined(ELPP_UNICODE)</span>
<a name="l05147"></a>05147 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05148"></a>05148     }
<a name="l05149"></a>05149     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(quint64 msg)
<a name="l05150"></a>05150     {
<a name="l05151"></a>05151 <span class="preprocessor">#   if defined(ELPP_UNICODE)</span>
<a name="l05152"></a>05152 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdWString();
<a name="l05153"></a>05153 <span class="preprocessor">#   else</span>
<a name="l05154"></a>05154 <span class="preprocessor"></span>        m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdString();
<a name="l05155"></a>05155 <span class="preprocessor">#   endif  // defined(ELPP_UNICODE)</span>
<a name="l05156"></a>05156 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05157"></a>05157     }
<a name="l05158"></a>05158     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(QChar msg)
<a name="l05159"></a>05159     {
<a name="l05160"></a>05160         m_logger-&gt;stream() &lt;&lt; msg.toLatin1();
<a name="l05161"></a>05161         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05162"></a>05162     }
<a name="l05163"></a>05163     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(<span class="keyword">const</span> QLatin1String&amp; msg)
<a name="l05164"></a>05164     {
<a name="l05165"></a>05165         m_logger-&gt;stream() &lt;&lt; msg.latin1();
<a name="l05166"></a>05166         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05167"></a>05167     }
<a name="l05168"></a>05168     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QList)
<a name="l05169"></a>05169     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QVector)
<a name="l05170"></a>05170     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QQueue)
<a name="l05171"></a>05171     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QSet)
<a name="l05172"></a>05172     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QLinkedList)
<a name="l05173"></a>05173     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QStack)
<a name="l05174"></a>05174     template &lt;typename First, typename Second&gt;
<a name="l05175"></a>05175     inline MessageBuilder&amp; operator&lt;&lt;(const QPair&lt;First, Second&gt;&amp; pair_)
<a name="l05176"></a>05176     {
<a name="l05177"></a>05177         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;(&quot;</span>);
<a name="l05178"></a>05178         operator &lt;&lt; (static_cast&lt;First&gt;(pair_.first));
<a name="l05179"></a>05179         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l05180"></a>05180         operator &lt;&lt; (static_cast&lt;Second&gt;(pair_.second));
<a name="l05181"></a>05181         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;)&quot;</span>);
<a name="l05182"></a>05182         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05183"></a>05183     }
<a name="l05184"></a>05184     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;
<a name="l05185"></a>05185     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const QMap&lt;K, V&gt;&amp; map_)
<a name="l05186"></a>05186     {
<a name="l05187"></a>05187         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;[&quot;</span>);
<a name="l05188"></a>05188         QList&lt;K&gt; keys = map_.keys();
<a name="l05189"></a>05189         <span class="keyword">typename</span> QList&lt;K&gt;::const_iterator begin = keys.begin();
<a name="l05190"></a>05190         <span class="keyword">typename</span> QList&lt;K&gt;::const_iterator end = keys.end();
<a name="l05191"></a>05191         <span class="keywordtype">int</span> max_ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(base::consts::kMaxLogPerContainer);  <span class="comment">// to prevent warning</span>
<a name="l05192"></a>05192         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> index_ = 0; begin != end &amp;&amp; index_ &lt; max_; ++index_, ++begin) {
<a name="l05193"></a>05193             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;(&quot;</span>);
<a name="l05194"></a>05194             operator &lt;&lt; (static_cast&lt;K&gt;(*begin));
<a name="l05195"></a>05195             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l05196"></a>05196             operator &lt;&lt; (static_cast&lt;V&gt;(map_.value(*begin)));
<a name="l05197"></a>05197             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;)&quot;</span>);
<a name="l05198"></a>05198             m_logger-&gt;stream() &lt;&lt; ((index_ &lt; keys.size() - 1) ? m_containerLogSeperator : ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05199"></a>05199         }
<a name="l05200"></a>05200         <span class="keywordflow">if</span> (begin != end) {
<a name="l05201"></a>05201             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;...&quot;</span>);
<a name="l05202"></a>05202         }
<a name="l05203"></a>05203         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05204"></a>05204         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05205"></a>05205     }
<a name="l05206"></a>05206     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;
<a name="l05207"></a>05207     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const QMultiMap&lt;K, V&gt;&amp; map_)
<a name="l05208"></a>05208     {
<a name="l05209"></a>05209         operator &lt;&lt; (static_cast&lt;QMap&lt;K, V&gt;&gt;(map_));
<a name="l05210"></a>05210         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05211"></a>05211     }
<a name="l05212"></a>05212     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;
<a name="l05213"></a>05213     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const QHash&lt;K, V&gt;&amp; hash_)
<a name="l05214"></a>05214     {
<a name="l05215"></a>05215         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;[&quot;</span>);
<a name="l05216"></a>05216         QList&lt;K&gt; keys = hash_.keys();
<a name="l05217"></a>05217         <span class="keyword">typename</span> QList&lt;K&gt;::const_iterator begin = keys.begin();
<a name="l05218"></a>05218         <span class="keyword">typename</span> QList&lt;K&gt;::const_iterator end = keys.end();
<a name="l05219"></a>05219         <span class="keywordtype">int</span> max_ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(base::consts::kMaxLogPerContainer);  <span class="comment">// prevent type warning</span>
<a name="l05220"></a>05220         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> index_ = 0; begin != end &amp;&amp; index_ &lt; max_; ++index_, ++begin) {
<a name="l05221"></a>05221             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;(&quot;</span>);
<a name="l05222"></a>05222             operator &lt;&lt; (static_cast&lt;K&gt;(*begin));
<a name="l05223"></a>05223             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l05224"></a>05224             operator &lt;&lt; (static_cast&lt;V&gt;(hash_.value(*begin)));
<a name="l05225"></a>05225             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;)&quot;</span>);
<a name="l05226"></a>05226             m_logger-&gt;stream() &lt;&lt; ((index_ &lt; keys.size() - 1) ? m_containerLogSeperator : ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05227"></a>05227         }
<a name="l05228"></a>05228         <span class="keywordflow">if</span> (begin != end) {
<a name="l05229"></a>05229             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;...&quot;</span>);
<a name="l05230"></a>05230         }
<a name="l05231"></a>05231         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05232"></a>05232         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05233"></a>05233     }
<a name="l05234"></a>05234     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;
<a name="l05235"></a>05235     <span class="keyword">inline</span> MessageBuilder&amp; operator&lt;&lt;(const QMultiHash&lt;K, V&gt;&amp; multiHash_)
<a name="l05236"></a>05236     {
<a name="l05237"></a>05237         operator &lt;&lt; (static_cast&lt;QHash&lt;K, V&gt;&gt;(multiHash_));
<a name="l05238"></a>05238         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05239"></a>05239     }
<a name="l05240"></a>05240 <span class="preprocessor">#endif  // defined(ELPP_QT_LOGGING)</span>
<a name="l05241"></a>05241 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_BOOST_LOGGING)</span>
<a name="l05242"></a>05242 <span class="preprocessor"></span>    ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::vector)
<a name="l05243"></a>05243     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::stable_vector)
<a name="l05244"></a>05244     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::list)
<a name="l05245"></a>05245     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::deque)
<a name="l05246"></a>05246     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(boost::container::map)
<a name="l05247"></a>05247     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(boost::container::flat_map)
<a name="l05248"></a>05248     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(boost::container::set)
<a name="l05249"></a>05249     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(boost::container::flat_set)
<a name="l05250"></a>05250 <span class="preprocessor">#endif  // defined(ELPP_BOOST_LOGGING)</span>
<a name="l05251"></a>05251 <span class="preprocessor"></span>
<a name="l05260"></a>05260 <span class="preprocessor">#define MAKE_CONTAINERELPP_FRIENDLY(ContainerType, SizeMethod, ElementInstance) \</span>
<a name="l05261"></a>05261 <span class="preprocessor">    el::base::type::ostream_t&amp; operator&lt;&lt;(el::base::type::ostream_t&amp; ss, const ContainerType&amp; container) {\</span>
<a name="l05262"></a>05262 <span class="preprocessor">        const el::base::type::char_t* sep = ELPP-&gt;hasFlag(el::LoggingFlag::NewLineForContainer) ? \</span>
<a name="l05263"></a>05263 <span class="preprocessor">            ELPP_LITERAL(&quot;\n    &quot;) : ELPP_LITERAL(&quot;, &quot;);\</span>
<a name="l05264"></a>05264 <span class="preprocessor">        ContainerType::const_iterator elem = container.begin();\</span>
<a name="l05265"></a>05265 <span class="preprocessor">        ContainerType::const_iterator endElem = container.end();\</span>
<a name="l05266"></a>05266 <span class="preprocessor">        std::size_t size_ = container.SizeMethod; \</span>
<a name="l05267"></a>05267 <span class="preprocessor">        ss &lt;&lt; ELPP_LITERAL(&quot;[&quot;);\</span>
<a name="l05268"></a>05268 <span class="preprocessor">        for (std::size_t i = 0; elem != endElem &amp;&amp; i &lt; el::base::consts::kMaxLogPerContainer; ++i, ++elem) { \</span>
<a name="l05269"></a>05269 <span class="preprocessor">            ss &lt;&lt; ElementInstance;\</span>
<a name="l05270"></a>05270 <span class="preprocessor">            ss &lt;&lt; ((i &lt; size_ - 1) ? sep : ELPP_LITERAL(&quot;&quot;));\</span>
<a name="l05271"></a>05271 <span class="preprocessor">        }\</span>
<a name="l05272"></a>05272 <span class="preprocessor">        if (elem != endElem) {\</span>
<a name="l05273"></a>05273 <span class="preprocessor">            ss &lt;&lt; ELPP_LITERAL(&quot;...&quot;);\</span>
<a name="l05274"></a>05274 <span class="preprocessor">        }\</span>
<a name="l05275"></a>05275 <span class="preprocessor">        ss &lt;&lt; ELPP_LITERAL(&quot;]&quot;);\</span>
<a name="l05276"></a>05276 <span class="preprocessor">        return ss;\</span>
<a name="l05277"></a>05277 <span class="preprocessor">    }</span>
<a name="l05278"></a>05278 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_WXWIDGETS_LOGGING)</span>
<a name="l05279"></a>05279 <span class="preprocessor"></span>    ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(wxVector)
<a name="l05280"></a>05280 <span class="preprocessor">#   define ELPP_WX_PTR_ENABLED(ContainerType) MAKE_CONTAINERELPP_FRIENDLY(ContainerType, size(), *(*elem))</span>
<a name="l05281"></a>05281 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WX_ENABLED(ContainerType) MAKE_CONTAINERELPP_FRIENDLY(ContainerType, size(), (*elem))</span>
<a name="l05282"></a>05282 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WX_HASH_MAP_ENABLED(ContainerType) MAKE_CONTAINERELPP_FRIENDLY(ContainerType, size(), \</span>
<a name="l05283"></a>05283 <span class="preprocessor">        ELPP_LITERAL(&quot;(&quot;) &lt;&lt; elem-&gt;first &lt;&lt; ELPP_LITERAL(&quot;, &quot;) &lt;&lt; elem-&gt;second &lt;&lt; ELPP_LITERAL(&quot;)&quot;)</span>
<a name="l05284"></a>05284 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l05285"></a>05285 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WX_PTR_ENABLED(ContainerType)</span>
<a name="l05286"></a>05286 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WX_ENABLED(ContainerType)</span>
<a name="l05287"></a>05287 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_WX_HASH_MAP_ENABLED(ContainerType)</span>
<a name="l05288"></a>05288 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_WXWIDGETS_LOGGING)</span>
<a name="l05289"></a>05289 <span class="preprocessor"></span>    <span class="comment">// Other classes</span>
<a name="l05290"></a>05290     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Class&gt;
<a name="l05291"></a>05291     ELPP_SIMPLE_LOG(<span class="keyword">const</span> Class&amp;)
<a name="l05292"></a>05292 <span class="preprocessor">#undef ELPP_SIMPLE_LOG</span>
<a name="l05293"></a>05293 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG</span>
<a name="l05294"></a>05294 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG</span>
<a name="l05295"></a>05295 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG</span>
<a name="l05296"></a>05296 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG</span>
<a name="l05297"></a>05297 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG</span>
<a name="l05298"></a>05298 <span class="preprocessor"></span><span class="keyword">private</span>:
<a name="l05299"></a>05299     Logger* m_logger;
<a name="l05300"></a>05300     <span class="keyword">const</span> base::type::char_t* m_containerLogSeperator;
<a name="l05301"></a>05301 
<a name="l05302"></a>05302     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l05303"></a>05303     <span class="keyword">inline</span> MessageBuilder&amp; writeIterator(Iterator begin_, Iterator end_, std::size_t size_)
<a name="l05304"></a>05304     {
<a name="l05305"></a>05305         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;[&quot;</span>);
<a name="l05306"></a>05306         <span class="keywordflow">for</span> (std::size_t i = 0; begin_ != end_ &amp;&amp; i &lt; base::consts::kMaxLogPerContainer; ++i, ++begin_) {
<a name="l05307"></a>05307             operator &lt;&lt; (*begin_);
<a name="l05308"></a>05308             m_logger-&gt;stream() &lt;&lt; ((i &lt; size_ - 1) ? m_containerLogSeperator : ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05309"></a>05309         }
<a name="l05310"></a>05310         <span class="keywordflow">if</span> (begin_ != end_) {
<a name="l05311"></a>05311             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;...&quot;</span>);
<a name="l05312"></a>05312         }
<a name="l05313"></a>05313         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05314"></a>05314         <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::AutoSpacing)) {
<a name="l05315"></a>05315             m_logger-&gt;stream() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l05316"></a>05316         }
<a name="l05317"></a>05317         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05318"></a>05318     }
<a name="l05319"></a>05319 };
<a name="l05321"></a>05321 <span class="keyword">class </span>NullWriter : base::NoCopy
<a name="l05322"></a>05322 {
<a name="l05323"></a>05323 <span class="keyword">public</span>:
<a name="l05324"></a>05324     NullWriter(<span class="keywordtype">void</span>) {}
<a name="l05325"></a>05325 
<a name="l05326"></a>05326     <span class="comment">// Null manipulator</span>
<a name="l05327"></a>05327     <span class="keyword">inline</span> NullWriter&amp; operator&lt;&lt;(std::ostream &amp; (*)(std::ostream&amp;))
<a name="l05328"></a>05328     {
<a name="l05329"></a>05329         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05330"></a>05330     }
<a name="l05331"></a>05331 
<a name="l05332"></a>05332     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l05333"></a>05333     <span class="keyword">inline</span> NullWriter&amp; operator&lt;&lt;(<span class="keyword">const</span> T&amp;)
<a name="l05334"></a>05334     {
<a name="l05335"></a>05335         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05336"></a>05336     }
<a name="l05337"></a>05337 };
<a name="l05339"></a>05339 <span class="keyword">class </span>Writer : base::NoCopy
<a name="l05340"></a>05340 {
<a name="l05341"></a>05341 <span class="keyword">public</span>:
<a name="l05342"></a>05342     Writer(Level level, <span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> line,
<a name="l05343"></a>05343            <span class="keyword">const</span> <span class="keywordtype">char</span>* func, base::DispatchAction dispatchAction = base::DispatchAction::NormalLog,
<a name="l05344"></a>05344            base::type::VerboseLevel verboseLevel = 0) :
<a name="l05345"></a>05345         m_level(level), m_file(file), m_line(line), m_func(func), m_verboseLevel(verboseLevel),
<a name="l05346"></a>05346         m_proceed(false), m_dispatchAction(dispatchAction)
<a name="l05347"></a>05347     {
<a name="l05348"></a>05348     }
<a name="l05349"></a>05349 
<a name="l05350"></a>05350     <span class="keyword">virtual</span> ~Writer(<span class="keywordtype">void</span>)
<a name="l05351"></a>05351     {
<a name="l05352"></a>05352         processDispatch();
<a name="l05353"></a>05353     }
<a name="l05354"></a>05354 
<a name="l05355"></a>05355     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l05356"></a>05356     <span class="keyword">inline</span> Writer&amp; operator&lt;&lt;(<span class="keyword">const</span> T&amp; log)
<a name="l05357"></a>05357     {
<a name="l05358"></a>05358 <span class="preprocessor">#if ELPP_LOGGING_ENABLED</span>
<a name="l05359"></a>05359 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_proceed) {
<a name="l05360"></a>05360             m_messageBuilder &lt;&lt; log;
<a name="l05361"></a>05361         }
<a name="l05362"></a>05362 <span class="preprocessor">#endif  // ELPP_LOGGING_ENABLED</span>
<a name="l05363"></a>05363 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05364"></a>05364     }
<a name="l05365"></a>05365 
<a name="l05366"></a>05366     <span class="keyword">inline</span> Writer&amp; operator&lt;&lt;(std::ostream &amp; (*log)(std::ostream&amp;))
<a name="l05367"></a>05367     {
<a name="l05368"></a>05368 <span class="preprocessor">#if ELPP_LOGGING_ENABLED</span>
<a name="l05369"></a>05369 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_proceed) {
<a name="l05370"></a>05370             m_messageBuilder &lt;&lt; log;
<a name="l05371"></a>05371         }
<a name="l05372"></a>05372 <span class="preprocessor">#endif  // ELPP_LOGGING_ENABLED</span>
<a name="l05373"></a>05373 <span class="preprocessor"></span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05374"></a>05374     }
<a name="l05375"></a>05375 
<a name="l05376"></a>05376     Writer&amp; construct(Logger* logger, <span class="keywordtype">bool</span> needLock = <span class="keyword">true</span>)
<a name="l05377"></a>05377     {
<a name="l05378"></a>05378         m_logger = logger;
<a name="l05379"></a>05379         initializeLogger(logger-&gt;id(), <span class="keyword">false</span>, needLock);
<a name="l05380"></a>05380         m_messageBuilder.initialize(m_logger);
<a name="l05381"></a>05381         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05382"></a>05382     }
<a name="l05383"></a>05383 
<a name="l05384"></a>05384     Writer&amp; construct(<span class="keywordtype">int</span> count, <span class="keyword">const</span> <span class="keywordtype">char</span>* loggerIds, ...)
<a name="l05385"></a>05385     {
<a name="l05386"></a>05386         <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::MultiLoggerSupport)) {
<a name="l05387"></a>05387             va_list loggersList;
<a name="l05388"></a>05388             va_start(loggersList, loggerIds);
<a name="l05389"></a>05389             <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keywordtype">id</span> = loggerIds;
<a name="l05390"></a>05390             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
<a name="l05391"></a>05391                 m_loggerIds.push_back(std::string(<span class="keywordtype">id</span>));
<a name="l05392"></a>05392                 <span class="keywordtype">id</span> = va_arg(loggersList, <span class="keyword">const</span> <span class="keywordtype">char</span>*);
<a name="l05393"></a>05393             }
<a name="l05394"></a>05394             va_end(loggersList);
<a name="l05395"></a>05395             initializeLogger(m_loggerIds.at(0));
<a name="l05396"></a>05396         } <span class="keywordflow">else</span> {
<a name="l05397"></a>05397             initializeLogger(std::string(loggerIds));
<a name="l05398"></a>05398         }
<a name="l05399"></a>05399         m_messageBuilder.initialize(m_logger);
<a name="l05400"></a>05400         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05401"></a>05401     }
<a name="l05402"></a>05402 <span class="keyword">protected</span>:
<a name="l05403"></a>05403     Level m_level;
<a name="l05404"></a>05404     <span class="keyword">const</span> <span class="keywordtype">char</span>* m_file;
<a name="l05405"></a>05405     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> m_line;
<a name="l05406"></a>05406     <span class="keyword">const</span> <span class="keywordtype">char</span>* m_func;
<a name="l05407"></a>05407     base::type::VerboseLevel m_verboseLevel;
<a name="l05408"></a>05408     Logger* m_logger;
<a name="l05409"></a>05409     <span class="keywordtype">bool</span> m_proceed;
<a name="l05410"></a>05410     base::MessageBuilder m_messageBuilder;
<a name="l05411"></a>05411     base::DispatchAction m_dispatchAction;
<a name="l05412"></a>05412     std::vector&lt;std::string&gt; m_loggerIds;
<a name="l05413"></a>05413     <span class="keyword">friend</span> <span class="keyword">class </span>el::Helpers;
<a name="l05414"></a>05414 
<a name="l05415"></a>05415     <span class="keywordtype">void</span> initializeLogger(<span class="keyword">const</span> std::string&amp; loggerId, <span class="keywordtype">bool</span> lookup = <span class="keyword">true</span>, <span class="keywordtype">bool</span> needLock = <span class="keyword">true</span>)
<a name="l05416"></a>05416     {
<a name="l05417"></a>05417         <span class="keywordflow">if</span> (lookup) {
<a name="l05418"></a>05418             m_logger = ELPP-&gt;registeredLoggers()-&gt;get(loggerId, ELPP-&gt;hasFlag(LoggingFlag::CreateLoggerAutomatically));
<a name="l05419"></a>05419         }
<a name="l05420"></a>05420         <span class="keywordflow">if</span> (m_logger == <span class="keyword">nullptr</span>) {
<a name="l05421"></a>05421             ELPP-&gt;acquireLock();
<a name="l05422"></a>05422             <span class="keywordflow">if</span> (!ELPP-&gt;registeredLoggers()-&gt;has(std::string(base::consts::kDefaultLoggerId))) {
<a name="l05423"></a>05423                 <span class="comment">// Somehow default logger has been unregistered. Not good! Register again</span>
<a name="l05424"></a>05424                 ELPP-&gt;registeredLoggers()-&gt;get(std::string(base::consts::kDefaultLoggerId));
<a name="l05425"></a>05425             }
<a name="l05426"></a>05426             ELPP-&gt;releaseLock();  <span class="comment">// Need to unlock it for next writer</span>
<a name="l05427"></a>05427             Writer(Level::Debug, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)
<a name="l05428"></a>05428                     &lt;&lt; <span class="stringliteral">&quot;Logger [&quot;</span> &lt;&lt; loggerId &lt;&lt; <span class="stringliteral">&quot;] is not registered yet!&quot;</span>;
<a name="l05429"></a>05429             m_proceed = <span class="keyword">false</span>;
<a name="l05430"></a>05430         } <span class="keywordflow">else</span> {
<a name="l05431"></a>05431             <span class="keywordflow">if</span> (needLock) {
<a name="l05432"></a>05432                 m_logger-&gt;acquireLock();  <span class="comment">// This should not be unlocked by checking m_proceed because</span>
<a name="l05433"></a>05433                 <span class="comment">// m_proceed can be changed by lines below</span>
<a name="l05434"></a>05434             }
<a name="l05435"></a>05435             <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::HierarchicalLogging)) {
<a name="l05436"></a>05436                 m_proceed = m_level == Level::Verbose ? m_logger-&gt;enabled(m_level) :
<a name="l05437"></a>05437                             LevelHelper::castToInt(m_level) &gt;= LevelHelper::castToInt(ELPP-&gt;m_loggingLevel);
<a name="l05438"></a>05438             } <span class="keywordflow">else</span> {
<a name="l05439"></a>05439                 m_proceed = m_logger-&gt;enabled(m_level);
<a name="l05440"></a>05440             }
<a name="l05441"></a>05441         }
<a name="l05442"></a>05442     }
<a name="l05443"></a>05443 
<a name="l05444"></a>05444     <span class="keywordtype">void</span> processDispatch()
<a name="l05445"></a>05445     {
<a name="l05446"></a>05446 <span class="preprocessor">#if ELPP_LOGGING_ENABLED</span>
<a name="l05447"></a>05447 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::MultiLoggerSupport)) {
<a name="l05448"></a>05448             <span class="keywordtype">bool</span> firstDispatched = <span class="keyword">false</span>;
<a name="l05449"></a>05449             base::type::string_t logMessage;
<a name="l05450"></a>05450             std::size_t i = 0;
<a name="l05451"></a>05451             <span class="keywordflow">do</span> {
<a name="l05452"></a>05452                 <span class="keywordflow">if</span> (m_proceed) {
<a name="l05453"></a>05453                     <span class="keywordflow">if</span> (firstDispatched) {
<a name="l05454"></a>05454                         m_logger-&gt;stream() &lt;&lt; logMessage;
<a name="l05455"></a>05455                     } <span class="keywordflow">else</span> {
<a name="l05456"></a>05456                         firstDispatched = <span class="keyword">true</span>;
<a name="l05457"></a>05457                         <span class="keywordflow">if</span> (m_loggerIds.size() &gt; 1) {
<a name="l05458"></a>05458                             logMessage = m_logger-&gt;stream().str();
<a name="l05459"></a>05459                         }
<a name="l05460"></a>05460                     }
<a name="l05461"></a>05461                     triggerDispatch();
<a name="l05462"></a>05462                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_logger != <span class="keyword">nullptr</span>) {
<a name="l05463"></a>05463                     m_logger-&gt;stream().str(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05464"></a>05464                     m_logger-&gt;releaseLock();
<a name="l05465"></a>05465                 }
<a name="l05466"></a>05466                 <span class="keywordflow">if</span> (i + 1 &lt; m_loggerIds.size()) {
<a name="l05467"></a>05467                     initializeLogger(m_loggerIds.at(i + 1));
<a name="l05468"></a>05468                 }
<a name="l05469"></a>05469             } <span class="keywordflow">while</span> (++i &lt; m_loggerIds.size());
<a name="l05470"></a>05470         } <span class="keywordflow">else</span> {
<a name="l05471"></a>05471             <span class="keywordflow">if</span> (m_proceed) {
<a name="l05472"></a>05472                 triggerDispatch();
<a name="l05473"></a>05473             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_logger != <span class="keyword">nullptr</span>) {
<a name="l05474"></a>05474                 m_logger-&gt;stream().str(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05475"></a>05475                 m_logger-&gt;releaseLock();
<a name="l05476"></a>05476             }
<a name="l05477"></a>05477         }
<a name="l05478"></a>05478 <span class="preprocessor">#else</span>
<a name="l05479"></a>05479 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_logger != <span class="keyword">nullptr</span>) {
<a name="l05480"></a>05480             m_logger-&gt;stream().str(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05481"></a>05481             m_logger-&gt;releaseLock();
<a name="l05482"></a>05482         }
<a name="l05483"></a>05483 <span class="preprocessor">#endif // ELPP_LOGGING_ENABLED</span>
<a name="l05484"></a>05484 <span class="preprocessor"></span>    }
<a name="l05485"></a>05485 
<a name="l05486"></a>05486     <span class="keywordtype">void</span> triggerDispatch(<span class="keywordtype">void</span>)
<a name="l05487"></a>05487     {
<a name="l05488"></a>05488         <span class="keywordflow">if</span> (m_proceed) {
<a name="l05489"></a>05489             base::LogDispatcher(m_proceed, LogMessage(m_level, m_file, m_line, m_func, m_verboseLevel,
<a name="l05490"></a>05490                                 m_logger), m_dispatchAction).dispatch();
<a name="l05491"></a>05491         }
<a name="l05492"></a>05492         <span class="keywordflow">if</span> (m_logger != <span class="keyword">nullptr</span>) {
<a name="l05493"></a>05493             m_logger-&gt;stream().str(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05494"></a>05494             m_logger-&gt;releaseLock();
<a name="l05495"></a>05495         }
<a name="l05496"></a>05496         <span class="keywordflow">if</span> (m_proceed &amp;&amp; m_level == Level::Fatal
<a name="l05497"></a>05497                 &amp;&amp; !ELPP-&gt;hasFlag(LoggingFlag::DisableApplicationAbortOnFatalLog)) {
<a name="l05498"></a>05498             base::Writer(Level::Warning, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)
<a name="l05499"></a>05499                     &lt;&lt; <span class="stringliteral">&quot;Aborting application. Reason: Fatal log at [&quot;</span> &lt;&lt; m_file &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; m_line &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l05500"></a>05500             std::stringstream reasonStream;
<a name="l05501"></a>05501             reasonStream &lt;&lt; <span class="stringliteral">&quot;Fatal log at [&quot;</span> &lt;&lt; m_file &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; m_line &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>
<a name="l05502"></a>05502                          &lt;&lt; <span class="stringliteral">&quot; If you wish to disable &apos;abort on fatal log&apos; please use &quot;</span>
<a name="l05503"></a>05503                          &lt;&lt; <span class="stringliteral">&quot;el::Helpers::addFlag(el::LoggingFlag::DisableApplicationAbortOnFatalLog)&quot;</span>;
<a name="l05504"></a>05504             base::utils::abort(1, reasonStream.str());
<a name="l05505"></a>05505         }
<a name="l05506"></a>05506         m_proceed = <span class="keyword">false</span>;
<a name="l05507"></a>05507     }
<a name="l05508"></a>05508 };
<a name="l05509"></a>05509 <span class="keyword">class </span>PErrorWriter : <span class="keyword">public</span> base::Writer
<a name="l05510"></a>05510 {
<a name="l05511"></a>05511 <span class="keyword">public</span>:
<a name="l05512"></a>05512     PErrorWriter(Level level, <span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> line,
<a name="l05513"></a>05513                  <span class="keyword">const</span> <span class="keywordtype">char</span>* func, base::DispatchAction dispatchAction = base::DispatchAction::NormalLog,
<a name="l05514"></a>05514                  base::type::VerboseLevel verboseLevel = 0) :
<a name="l05515"></a>05515         base::Writer(level, file, line, func, dispatchAction, verboseLevel)
<a name="l05516"></a>05516     {
<a name="l05517"></a>05517     }
<a name="l05518"></a>05518 
<a name="l05519"></a>05519     <span class="keyword">virtual</span> ~PErrorWriter(<span class="keywordtype">void</span>)
<a name="l05520"></a>05520     {
<a name="l05521"></a>05521         <span class="keywordflow">if</span> (m_proceed) {
<a name="l05522"></a>05522 <span class="preprocessor">#if ELPP_COMPILER_MSVC</span>
<a name="l05523"></a>05523 <span class="preprocessor"></span>            <span class="keywordtype">char</span> buff[256];
<a name="l05524"></a>05524             strerror_s(buff, 256, errno);
<a name="l05525"></a>05525             m_logger-&gt;stream() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; buff &lt;&lt; <span class="stringliteral">&quot; [&quot;</span> &lt;&lt; errno &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l05526"></a>05526 <span class="preprocessor">#else</span>
<a name="l05527"></a>05527 <span class="preprocessor"></span>            m_logger-&gt;stream() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="stringliteral">&quot; [&quot;</span> &lt;&lt; errno &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l05528"></a>05528 <span class="preprocessor">#endif</span>
<a name="l05529"></a>05529 <span class="preprocessor"></span>        }
<a name="l05530"></a>05530     }
<a name="l05531"></a>05531 };
<a name="l05532"></a>05532 }  <span class="comment">// namespace base</span>
<a name="l05533"></a>05533 <span class="comment">// Logging from Logger class. Why this is here? Because we have Storage and Writer class available</span>
<a name="l05534"></a>05534 <span class="preprocessor">#if ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l05535"></a>05535 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l05536"></a>05536 <span class="keywordtype">void</span> Logger::log_(Level level, <span class="keywordtype">int</span> vlevel, <span class="keyword">const</span> <span class="keywordtype">char</span>* s, <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> Args&amp; ... args)
<a name="l05537"></a>05537 {
<a name="l05538"></a>05538     base::MessageBuilder b;
<a name="l05539"></a>05539     b.initialize(<span class="keyword">this</span>);
<a name="l05540"></a>05540     <span class="keywordflow">while</span> (*s) {
<a name="l05541"></a>05541         <span class="keywordflow">if</span> (*s == base::consts::kFormatSpecifierChar) {
<a name="l05542"></a>05542             <span class="keywordflow">if</span> (*(s + 1) == base::consts::kFormatSpecifierChar) {
<a name="l05543"></a>05543                 ++s;
<a name="l05544"></a>05544             } <span class="keywordflow">else</span> {
<a name="l05545"></a>05545                 <span class="keywordflow">if</span> (*(s + 1) == base::consts::kFormatSpecifierCharValue) {
<a name="l05546"></a>05546                     ++s;
<a name="l05547"></a>05547                     b &lt;&lt; value;
<a name="l05548"></a>05548                     log_(level, vlevel, ++s, args...);
<a name="l05549"></a>05549                     <span class="keywordflow">return</span>;
<a name="l05550"></a>05550                 }
<a name="l05551"></a>05551             }
<a name="l05552"></a>05552         }
<a name="l05553"></a>05553         b &lt;&lt; *s++;
<a name="l05554"></a>05554     }
<a name="l05555"></a>05555     ELPP_INTERNAL_ERROR(<span class="stringliteral">&quot;Too many arguments provided. Unable to handle. Please provide more format specifiers&quot;</span>, <span class="keyword">false</span>);
<a name="l05556"></a>05556 }
<a name="l05557"></a>05557 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l05558"></a>05558 <span class="keyword">inline</span> <span class="keywordtype">void</span> Logger::log_(Level level, <span class="keywordtype">int</span> vlevel, <span class="keyword">const</span> T&amp; log)
<a name="l05559"></a>05559 {
<a name="l05560"></a>05560     <span class="keywordflow">if</span> (level == Level::Verbose) {
<a name="l05561"></a>05561         <span class="keywordflow">if</span> (ELPP-&gt;vRegistry()-&gt;allowed(vlevel, __FILE__)) {
<a name="l05562"></a>05562             base::Writer(Level::Verbose, <span class="stringliteral">&quot;FILE&quot;</span>, 0, <span class="stringliteral">&quot;FUNCTION&quot;</span>,
<a name="l05563"></a>05563                          base::DispatchAction::NormalLog, vlevel).construct(<span class="keyword">this</span>, <span class="keyword">false</span>) &lt;&lt; log;
<a name="l05564"></a>05564         } <span class="keywordflow">else</span> {
<a name="l05565"></a>05565             stream().str(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l05566"></a>05566         }
<a name="l05567"></a>05567     } <span class="keywordflow">else</span> {
<a name="l05568"></a>05568         base::Writer(level, <span class="stringliteral">&quot;FILE&quot;</span>, 0, <span class="stringliteral">&quot;FUNCTION&quot;</span>).construct(<span class="keyword">this</span>, <span class="keyword">false</span>) &lt;&lt; log;
<a name="l05569"></a>05569     }
<a name="l05570"></a>05570 }
<a name="l05571"></a>05571 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l05572"></a>05572 <span class="keywordtype">void</span> Logger::log(Level level, <span class="keyword">const</span> <span class="keywordtype">char</span>* s, <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> Args&amp; ... args)
<a name="l05573"></a>05573 {
<a name="l05574"></a>05574     base::threading::ScopedLock scopedLock(lock());
<a name="l05575"></a>05575     log_(level, 0, s, value, args...);
<a name="l05576"></a>05576 }
<a name="l05577"></a>05577 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l05578"></a>05578 <span class="keyword">inline</span> <span class="keywordtype">void</span> Logger::log(Level level, <span class="keyword">const</span> T&amp; log)
<a name="l05579"></a>05579 {
<a name="l05580"></a>05580     base::threading::ScopedLock scopedLock(lock());
<a name="l05581"></a>05581     log_(level, 0, log);
<a name="l05582"></a>05582 }
<a name="l05583"></a>05583 <span class="preprocessor">#   if ELPP_VERBOSE_LOG</span>
<a name="l05584"></a>05584 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l05585"></a>05585 <span class="keyword">inline</span> <span class="keywordtype">void</span> Logger::verbose(<span class="keywordtype">int</span> vlevel, <span class="keyword">const</span> <span class="keywordtype">char</span>* s, <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> Args&amp; ... args)
<a name="l05586"></a>05586 {
<a name="l05587"></a>05587     base::threading::ScopedLock scopedLock(lock());
<a name="l05588"></a>05588     log_(el::Level::Verbose, vlevel, s, value, args...);
<a name="l05589"></a>05589 }
<a name="l05590"></a>05590 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l05591"></a>05591 <span class="keyword">inline</span> <span class="keywordtype">void</span> Logger::verbose(<span class="keywordtype">int</span> vlevel, <span class="keyword">const</span> T&amp; log)
<a name="l05592"></a>05592 {
<a name="l05593"></a>05593     base::threading::ScopedLock scopedLock(lock());
<a name="l05594"></a>05594     log_(el::Level::Verbose, vlevel, log);
<a name="l05595"></a>05595 }
<a name="l05596"></a>05596 <span class="preprocessor">#   else</span>
<a name="l05597"></a>05597 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;
<a name="l05598"></a>05598 <span class="keyword">inline</span> <span class="keywordtype">void</span> Logger::verbose(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> Args&amp; ...)
<a name="l05599"></a>05599 {
<a name="l05600"></a>05600     <span class="keywordflow">return</span>;
<a name="l05601"></a>05601 }
<a name="l05602"></a>05602 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l05603"></a>05603 <span class="keyword">inline</span> <span class="keywordtype">void</span> Logger::verbose(<span class="keywordtype">int</span>, <span class="keyword">const</span> T&amp;)
<a name="l05604"></a>05604 {
<a name="l05605"></a>05605     <span class="keywordflow">return</span>;
<a name="l05606"></a>05606 }
<a name="l05607"></a>05607 <span class="preprocessor">#   endif  // ELPP_VERBOSE_LOG</span>
<a name="l05608"></a>05608 <span class="preprocessor"></span><span class="preprocessor">#   define LOGGER_LEVEL_WRITERS(FUNCTION_NAME, LOG_LEVEL)\</span>
<a name="l05609"></a>05609 <span class="preprocessor">    template &lt;typename T, typename... Args&gt;\</span>
<a name="l05610"></a>05610 <span class="preprocessor">    inline void Logger::FUNCTION_NAME(const char* s, const T&amp; value, const Args&amp;... args) {\</span>
<a name="l05611"></a>05611 <span class="preprocessor">        log(LOG_LEVEL, s, value, args...);\</span>
<a name="l05612"></a>05612 <span class="preprocessor">    }\</span>
<a name="l05613"></a>05613 <span class="preprocessor">    template &lt;typename T&gt;\</span>
<a name="l05614"></a>05614 <span class="preprocessor">    inline void Logger::FUNCTION_NAME(const T&amp; value) {\</span>
<a name="l05615"></a>05615 <span class="preprocessor">        log(LOG_LEVEL, value);\</span>
<a name="l05616"></a>05616 <span class="preprocessor">    }</span>
<a name="l05617"></a>05617 <span class="preprocessor"></span><span class="preprocessor">#   define LOGGER_LEVEL_WRITERS_DISABLED(FUNCTION_NAME, LOG_LEVEL)\</span>
<a name="l05618"></a>05618 <span class="preprocessor">    template &lt;typename T, typename... Args&gt;\</span>
<a name="l05619"></a>05619 <span class="preprocessor">    inline void Logger::FUNCTION_NAME(const char*, const T&amp;, const Args&amp;...) {\</span>
<a name="l05620"></a>05620 <span class="preprocessor">        return;\</span>
<a name="l05621"></a>05621 <span class="preprocessor">    }\</span>
<a name="l05622"></a>05622 <span class="preprocessor">    template &lt;typename T&gt;\</span>
<a name="l05623"></a>05623 <span class="preprocessor">    inline void Logger::FUNCTION_NAME(const T&amp;) {\</span>
<a name="l05624"></a>05624 <span class="preprocessor">        return;\</span>
<a name="l05625"></a>05625 <span class="preprocessor">    }</span>
<a name="l05626"></a>05626 <span class="preprocessor"></span>
<a name="l05627"></a>05627 <span class="preprocessor">#   if ELPP_INFO_LOG</span>
<a name="l05628"></a>05628 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS(info, Level::Info)
<a name="l05629"></a>05629 <span class="preprocessor">#   else</span>
<a name="l05630"></a>05630 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS_DISABLED(info, Level::Info)
<a name="l05631"></a>05631 <span class="preprocessor">#   endif // ELPP_INFO_LOG</span>
<a name="l05632"></a>05632 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_DEBUG_LOG</span>
<a name="l05633"></a>05633 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS(debug, Level::Debug)
<a name="l05634"></a>05634 <span class="preprocessor">#   else</span>
<a name="l05635"></a>05635 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS_DISABLED(debug, Level::Debug)
<a name="l05636"></a>05636 <span class="preprocessor">#   endif // ELPP_DEBUG_LOG</span>
<a name="l05637"></a>05637 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_WARNING_LOG</span>
<a name="l05638"></a>05638 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS(warn, Level::Warning)
<a name="l05639"></a>05639 <span class="preprocessor">#   else</span>
<a name="l05640"></a>05640 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS_DISABLED(warn, Level::Warning)
<a name="l05641"></a>05641 <span class="preprocessor">#   endif // ELPP_WARNING_LOG</span>
<a name="l05642"></a>05642 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_ERROR_LOG</span>
<a name="l05643"></a>05643 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS(error, Level::Error)
<a name="l05644"></a>05644 <span class="preprocessor">#   else</span>
<a name="l05645"></a>05645 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS_DISABLED(error, Level::Error)
<a name="l05646"></a>05646 <span class="preprocessor">#   endif // ELPP_ERROR_LOG</span>
<a name="l05647"></a>05647 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_FATAL_LOG</span>
<a name="l05648"></a>05648 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS(fatal, Level::Fatal)
<a name="l05649"></a>05649 <span class="preprocessor">#   else</span>
<a name="l05650"></a>05650 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS_DISABLED(fatal, Level::Fatal)
<a name="l05651"></a>05651 <span class="preprocessor">#   endif // ELPP_FATAL_LOG</span>
<a name="l05652"></a>05652 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_TRACE_LOG</span>
<a name="l05653"></a>05653 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS(trace, Level::Trace)
<a name="l05654"></a>05654 <span class="preprocessor">#   else</span>
<a name="l05655"></a>05655 <span class="preprocessor"></span>LOGGER_LEVEL_WRITERS_DISABLED(trace, Level::Trace)
<a name="l05656"></a>05656 <span class="preprocessor">#   endif // ELPP_TRACE_LOG</span>
<a name="l05657"></a>05657 <span class="preprocessor"></span><span class="preprocessor">#   undef LOGGER_LEVEL_WRITERS</span>
<a name="l05658"></a>05658 <span class="preprocessor"></span><span class="preprocessor">#   undef LOGGER_LEVEL_WRITERS_DISABLED</span>
<a name="l05659"></a>05659 <span class="preprocessor"></span><span class="preprocessor">#endif // ELPP_VARIADIC_TEMPLATES_SUPPORTED</span>
<a name="l05660"></a>05660 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_COMPILER_MSVC</span>
<a name="l05661"></a>05661 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_VARIADIC_FUNC_MSVC(variadicFunction, variadicArgs) variadicFunction variadicArgs</span>
<a name="l05662"></a>05662 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_VARIADIC_FUNC_MSVC_RUN(variadicFunction, ...) ELPP_VARIADIC_FUNC_MSVC(variadicFunction, (__VA_ARGS__))</span>
<a name="l05663"></a>05663 <span class="preprocessor"></span><span class="preprocessor">#   define el_getVALength(...) ELPP_VARIADIC_FUNC_MSVC_RUN(el_resolveVALength, 0, ## __VA_ARGS__,\</span>
<a name="l05664"></a>05664 <span class="preprocessor">       10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</span>
<a name="l05665"></a>05665 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l05666"></a>05666 <span class="preprocessor"></span><span class="preprocessor">#   if ELPP_COMPILER_CLANG</span>
<a name="l05667"></a>05667 <span class="preprocessor"></span><span class="preprocessor">#      define el_getVALength(...) el_resolveVALength(0, __VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</span>
<a name="l05668"></a>05668 <span class="preprocessor"></span><span class="preprocessor">#   else</span>
<a name="l05669"></a>05669 <span class="preprocessor"></span><span class="preprocessor">#      define el_getVALength(...) el_resolveVALength(0, ## __VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</span>
<a name="l05670"></a>05670 <span class="preprocessor"></span><span class="preprocessor">#   endif // ELPP_COMPILER_CLANG</span>
<a name="l05671"></a>05671 <span class="preprocessor"></span><span class="preprocessor">#endif // ELPP_COMPILER_MSVC</span>
<a name="l05672"></a>05672 <span class="preprocessor"></span><span class="preprocessor">#define el_resolveVALength(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N</span>
<a name="l05673"></a>05673 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_WRITE_LOG(writer, level, dispatchAction, ...) \</span>
<a name="l05674"></a>05674 <span class="preprocessor">    writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l05675"></a>05675 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_WRITE_LOG_IF(writer, condition, level, dispatchAction, ...) if (condition) \</span>
<a name="l05676"></a>05676 <span class="preprocessor">    writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l05677"></a>05677 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_WRITE_LOG_EVERY_N(writer, occasion, level, dispatchAction, ...) \</span>
<a name="l05678"></a>05678 <span class="preprocessor">    if (ELPP-&gt;validateEveryNCounter(__FILE__, __LINE__, occasion)) \</span>
<a name="l05679"></a>05679 <span class="preprocessor">        writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l05680"></a>05680 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_WRITE_LOG_AFTER_N(writer, n, level, dispatchAction, ...) \</span>
<a name="l05681"></a>05681 <span class="preprocessor">    if (ELPP-&gt;validateAfterNCounter(__FILE__, __LINE__, n)) \</span>
<a name="l05682"></a>05682 <span class="preprocessor">        writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l05683"></a>05683 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_WRITE_LOG_N_TIMES(writer, n, level, dispatchAction, ...) \</span>
<a name="l05684"></a>05684 <span class="preprocessor">    if (ELPP-&gt;validateNTimesCounter(__FILE__, __LINE__, n)) \</span>
<a name="l05685"></a>05685 <span class="preprocessor">        writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l05686"></a>05686 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_CURR_FILE_PERFORMANCE_LOGGER</span>
<a name="l05687"></a>05687 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_PERFORMANCE_LOGGER)</span>
<a name="l05688"></a>05688 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CURR_FILE_PERFORMANCE_LOGGER ELPP_PERFORMANCE_LOGGER</span>
<a name="l05689"></a>05689 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l05690"></a>05690 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CURR_FILE_PERFORMANCE_LOGGER el::base::consts::kPerformanceLoggerId</span>
<a name="l05691"></a>05691 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l05692"></a>05692 <span class="preprocessor"></span><span class="keyword">class </span>PerformanceTrackingData
<a name="l05693"></a>05693 {
<a name="l05694"></a>05694 <span class="keyword">public</span>:
<a name="l05695"></a>05695     <span class="keyword">enum class</span> DataType : base::type::EnumType {
<a name="l05696"></a>05696         Checkpoint = 1, Complete = 2
<a name="l05697"></a>05697     };
<a name="l05698"></a>05698     <span class="comment">// Do not use constructor, will run into multiple definition error, use init(PerformanceTracker*)</span>
<a name="l05699"></a>05699     <span class="keyword">explicit</span> PerformanceTrackingData(DataType dataType) : m_performanceTracker(nullptr),
<a name="l05700"></a>05700         m_dataType(dataType), m_file(<span class="stringliteral">&quot;&quot;</span>), m_line(0), m_func(<span class="stringliteral">&quot;&quot;</span>) {}
<a name="l05701"></a>05701     <span class="keyword">inline</span> <span class="keyword">const</span> std::string* blockName(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l05702"></a>05702     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">struct </span>timeval* startTime(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l05703"></a>05703     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">struct </span>timeval* endTime(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l05704"></a>05704     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">struct </span>timeval* lastCheckpointTime(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l05705"></a>05705     <span class="keyword">inline</span> <span class="keyword">const</span> base::PerformanceTracker* performanceTracker(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_performanceTracker; }
<a name="l05706"></a>05706     <span class="keyword">inline</span> PerformanceTrackingData::DataType dataType(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_dataType; }
<a name="l05707"></a>05707     <span class="keyword">inline</span> <span class="keywordtype">bool</span> firstCheckpoint(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_firstCheckpoint; }
<a name="l05708"></a>05708     <span class="keyword">inline</span> std::string checkpointId(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_checkpointId; }
<a name="l05709"></a>05709     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* file(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_file; }
<a name="l05710"></a>05710     <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> line(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_line; }
<a name="l05711"></a>05711     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* func(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_func; }
<a name="l05712"></a>05712     <span class="keyword">inline</span> <span class="keyword">const</span> base::type::string_t* formattedTimeTaken()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;m_formattedTimeTaken; }
<a name="l05713"></a>05713     <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; loggerId(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l05714"></a>05714 <span class="keyword">private</span>:
<a name="l05715"></a>05715     base::PerformanceTracker* m_performanceTracker;
<a name="l05716"></a>05716     base::type::string_t m_formattedTimeTaken;
<a name="l05717"></a>05717     PerformanceTrackingData::DataType m_dataType;
<a name="l05718"></a>05718     <span class="keywordtype">bool</span> m_firstCheckpoint;
<a name="l05719"></a>05719     std::string m_checkpointId;
<a name="l05720"></a>05720     <span class="keyword">const</span> <span class="keywordtype">char</span>* m_file;
<a name="l05721"></a>05721     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> m_line;
<a name="l05722"></a>05722     <span class="keyword">const</span> <span class="keywordtype">char</span>* m_func;
<a name="l05723"></a>05723     <span class="keyword">inline</span> <span class="keywordtype">void</span> init(base::PerformanceTracker* performanceTracker, <span class="keywordtype">bool</span> firstCheckpoint = <span class="keyword">false</span>)
<a name="l05724"></a>05724     {
<a name="l05725"></a>05725         m_performanceTracker = performanceTracker;
<a name="l05726"></a>05726         m_firstCheckpoint = firstCheckpoint;
<a name="l05727"></a>05727     }
<a name="l05728"></a>05728 
<a name="l05729"></a>05729     <span class="keyword">friend</span> <span class="keyword">class </span>el::base::PerformanceTracker;
<a name="l05730"></a>05730 };
<a name="l05731"></a>05731 <span class="keyword">namespace </span>base {
<a name="l05734"></a>05734 <span class="keyword">class </span>PerformanceTracker : <span class="keyword">public</span> base::threading::ThreadSafe, <span class="keyword">public</span> Loggable
<a name="l05735"></a>05735 {
<a name="l05736"></a>05736 <span class="keyword">public</span>:
<a name="l05737"></a>05737     PerformanceTracker(<span class="keyword">const</span> std::string&amp; blockName,
<a name="l05738"></a>05738                        base::TimestampUnit timestampUnit = base::TimestampUnit::Millisecond,
<a name="l05739"></a>05739                        <span class="keyword">const</span> std::string&amp; loggerId = std::string(ELPP_CURR_FILE_PERFORMANCE_LOGGER),
<a name="l05740"></a>05740                        <span class="keywordtype">bool</span> scopedLog = <span class="keyword">true</span>, Level level = base::consts::kPerformanceTrackerDefaultLevel) :
<a name="l05741"></a>05741         m_blockName(blockName), m_timestampUnit(timestampUnit), m_loggerId(loggerId), m_scopedLog(scopedLog),
<a name="l05742"></a>05742         m_level(level), m_hasChecked(false), m_lastCheckpointId(std::string()), m_enabled(false)
<a name="l05743"></a>05743     {
<a name="l05744"></a>05744 <span class="preprocessor">#if !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED</span>
<a name="l05745"></a>05745 <span class="preprocessor"></span>        <span class="comment">// We store it locally so that if user happen to change configuration by the end of scope</span>
<a name="l05746"></a>05746         <span class="comment">// or before calling checkpoint, we still depend on state of configuraton at time of construction</span>
<a name="l05747"></a>05747         el::Logger* loggerPtr = ELPP-&gt;registeredLoggers()-&gt;get(loggerId, <span class="keyword">false</span>);
<a name="l05748"></a>05748         m_enabled = loggerPtr != <span class="keyword">nullptr</span> &amp;&amp; loggerPtr-&gt;m_typedConfigurations-&gt;performanceTracking(m_level);
<a name="l05749"></a>05749         <span class="keywordflow">if</span> (m_enabled) {
<a name="l05750"></a>05750             base::utils::DateTime::gettimeofday(&amp;m_startTime);
<a name="l05751"></a>05751         }
<a name="l05752"></a>05752 <span class="preprocessor">#endif  // !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED</span>
<a name="l05753"></a>05753 <span class="preprocessor"></span>    }
<a name="l05755"></a>05755     PerformanceTracker(<span class="keyword">const</span> PerformanceTracker&amp; t) :
<a name="l05756"></a>05756         m_blockName(t.m_blockName), m_timestampUnit(t.m_timestampUnit), m_loggerId(t.m_loggerId), m_scopedLog(t.m_scopedLog),
<a name="l05757"></a>05757         m_level(t.m_level), m_hasChecked(t.m_hasChecked), m_lastCheckpointId(t.m_lastCheckpointId), m_enabled(t.m_enabled),
<a name="l05758"></a>05758         m_startTime(t.m_startTime), m_endTime(t.m_endTime), m_lastCheckpointTime(t.m_lastCheckpointTime)
<a name="l05759"></a>05759     {
<a name="l05760"></a>05760     }
<a name="l05761"></a>05761     <span class="keyword">virtual</span> ~PerformanceTracker(<span class="keywordtype">void</span>)
<a name="l05762"></a>05762     {
<a name="l05763"></a>05763 <span class="preprocessor">#if !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED</span>
<a name="l05764"></a>05764 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_enabled) {
<a name="l05765"></a>05765             base::threading::ScopedLock scopedLock(lock());
<a name="l05766"></a>05766             <span class="keywordflow">if</span> (m_scopedLog) {
<a name="l05767"></a>05767                 base::utils::DateTime::gettimeofday(&amp;m_endTime);
<a name="l05768"></a>05768                 base::type::string_t formattedTime = getFormattedTimeTaken();
<a name="l05769"></a>05769                 PerformanceTrackingData data(PerformanceTrackingData::DataType::Complete);
<a name="l05770"></a>05770                 data.init(<span class="keyword">this</span>);
<a name="l05771"></a>05771                 data.m_formattedTimeTaken = formattedTime;
<a name="l05772"></a>05772                 PerformanceTrackingCallback* callback = <span class="keyword">nullptr</span>;
<a name="l05773"></a>05773                 <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;std::string, base::type::PerformanceTrackingCallbackPtr&gt;&amp; h
<a name="l05774"></a>05774                         : ELPP-&gt;m_performanceTrackingCallbacks) {
<a name="l05775"></a>05775                     callback = h.second.get();
<a name="l05776"></a>05776                     <span class="keywordflow">if</span> (callback != <span class="keyword">nullptr</span> &amp;&amp; callback-&gt;enabled()) {
<a name="l05777"></a>05777                         callback-&gt;acquireLock();
<a name="l05778"></a>05778                         callback-&gt;handle(&amp;data);
<a name="l05779"></a>05779                         callback-&gt;releaseLock();
<a name="l05780"></a>05780                     }
<a name="l05781"></a>05781                 }
<a name="l05782"></a>05782             }
<a name="l05783"></a>05783         }
<a name="l05784"></a>05784 <span class="preprocessor">#endif  // !defined(ELPP_DISABLE_PERFORMANCE_TRACKING)</span>
<a name="l05785"></a>05785 <span class="preprocessor"></span>    }
<a name="l05787"></a>05787     <span class="keywordtype">void</span> checkpoint(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span> = std::string(), <span class="keyword">const</span> <span class="keywordtype">char</span>* file = __FILE__, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> line = __LINE__, <span class="keyword">const</span> <span class="keywordtype">char</span>* func = <span class="stringliteral">&quot;&quot;</span>)
<a name="l05788"></a>05788     {
<a name="l05789"></a>05789 <span class="preprocessor">#if !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED</span>
<a name="l05790"></a>05790 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_enabled) {
<a name="l05791"></a>05791             base::threading::ScopedLock scopedLock(lock());
<a name="l05792"></a>05792             base::utils::DateTime::gettimeofday(&amp;m_endTime);
<a name="l05793"></a>05793             base::type::string_t formattedTime = m_hasChecked ? getFormattedTimeTaken(m_lastCheckpointTime) : ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>);
<a name="l05794"></a>05794             PerformanceTrackingData data(PerformanceTrackingData::DataType::Checkpoint);
<a name="l05795"></a>05795             data.init(<span class="keyword">this</span>);
<a name="l05796"></a>05796             data.m_checkpointId = id;
<a name="l05797"></a>05797             data.m_file = file;
<a name="l05798"></a>05798             data.m_line = line;
<a name="l05799"></a>05799             data.m_func = func;
<a name="l05800"></a>05800             data.m_formattedTimeTaken = formattedTime;
<a name="l05801"></a>05801             PerformanceTrackingCallback* callback = <span class="keyword">nullptr</span>;
<a name="l05802"></a>05802             <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;std::string, base::type::PerformanceTrackingCallbackPtr&gt;&amp; h
<a name="l05803"></a>05803                     : ELPP-&gt;m_performanceTrackingCallbacks) {
<a name="l05804"></a>05804                 callback = h.second.get();
<a name="l05805"></a>05805                 <span class="keywordflow">if</span> (callback != <span class="keyword">nullptr</span> &amp;&amp; callback-&gt;enabled()) {
<a name="l05806"></a>05806                     callback-&gt;acquireLock();
<a name="l05807"></a>05807                     callback-&gt;handle(&amp;data);
<a name="l05808"></a>05808                     callback-&gt;releaseLock();
<a name="l05809"></a>05809                 }
<a name="l05810"></a>05810             }
<a name="l05811"></a>05811             base::utils::DateTime::gettimeofday(&amp;m_lastCheckpointTime);
<a name="l05812"></a>05812             m_hasChecked = <span class="keyword">true</span>;
<a name="l05813"></a>05813             m_lastCheckpointId = id;
<a name="l05814"></a>05814         }
<a name="l05815"></a>05815 <span class="preprocessor">#endif  // !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED</span>
<a name="l05816"></a>05816 <span class="preprocessor"></span>        ELPP_UNUSED(<span class="keywordtype">id</span>);
<a name="l05817"></a>05817         ELPP_UNUSED(file);
<a name="l05818"></a>05818         ELPP_UNUSED(line);
<a name="l05819"></a>05819         ELPP_UNUSED(func);
<a name="l05820"></a>05820     }
<a name="l05821"></a>05821     <span class="keyword">inline</span> Level level(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_level; }
<a name="l05822"></a>05822 <span class="keyword">private</span>:
<a name="l05823"></a>05823     std::string m_blockName;
<a name="l05824"></a>05824     base::TimestampUnit m_timestampUnit;
<a name="l05825"></a>05825     std::string m_loggerId;
<a name="l05826"></a>05826     <span class="keywordtype">bool</span> m_scopedLog;
<a name="l05827"></a>05827     Level m_level;
<a name="l05828"></a>05828     <span class="keywordtype">bool</span> m_hasChecked;
<a name="l05829"></a>05829     std::string m_lastCheckpointId;
<a name="l05830"></a>05830     <span class="keywordtype">bool</span> m_enabled;
<a name="l05831"></a>05831     <span class="keyword">struct </span>timeval m_startTime, m_endTime, m_lastCheckpointTime;
<a name="l05832"></a>05832 
<a name="l05833"></a>05833     PerformanceTracker(<span class="keywordtype">void</span>);
<a name="l05834"></a>05834 
<a name="l05835"></a>05835     <span class="keyword">friend</span> <span class="keyword">class </span>el::PerformanceTrackingData;
<a name="l05836"></a>05836     <span class="keyword">friend</span> <span class="keyword">class </span>base::DefaultPerformanceTrackingCallback;
<a name="l05837"></a>05837 
<a name="l05838"></a>05838     <span class="keyword">const</span> <span class="keyword">inline</span> base::type::string_t getFormattedTimeTaken()<span class="keyword"> const</span>
<a name="l05839"></a>05839 <span class="keyword">    </span>{
<a name="l05840"></a>05840         <span class="keywordflow">return</span> getFormattedTimeTaken(m_startTime);
<a name="l05841"></a>05841     }
<a name="l05842"></a>05842 
<a name="l05843"></a>05843     <span class="keyword">const</span> base::type::string_t getFormattedTimeTaken(<span class="keyword">struct</span> timeval startTime)<span class="keyword"> const</span>
<a name="l05844"></a>05844 <span class="keyword">    </span>{
<a name="l05845"></a>05845         <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(LoggingFlag::FixedTimeFormat)) {
<a name="l05846"></a>05846             base::type::stringstream_t ss;
<a name="l05847"></a>05847             ss &lt;&lt; base::utils::DateTime::getTimeDifference(m_endTime,
<a name="l05848"></a>05848                     startTime, m_timestampUnit) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; base::consts::kTimeFormats[<span class="keyword">static_cast&lt;</span>base::type::EnumType<span class="keyword">&gt;</span>(m_timestampUnit)].unit;
<a name="l05849"></a>05849             <span class="keywordflow">return</span> ss.str();
<a name="l05850"></a>05850         }
<a name="l05851"></a>05851         <span class="keywordflow">return</span> base::utils::DateTime::formatTime(base::utils::DateTime::getTimeDifference(m_endTime,
<a name="l05852"></a>05852                 startTime, m_timestampUnit), m_timestampUnit);
<a name="l05853"></a>05853     }
<a name="l05854"></a>05854 
<a name="l05855"></a>05855     <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> log(el::base::type::ostream_t&amp; os)<span class="keyword"> const</span>
<a name="l05856"></a>05856 <span class="keyword">    </span>{
<a name="l05857"></a>05857         os &lt;&lt; getFormattedTimeTaken();
<a name="l05858"></a>05858     }
<a name="l05859"></a>05859 };
<a name="l05860"></a>05860 <span class="keyword">class </span>DefaultPerformanceTrackingCallback : <span class="keyword">public</span> PerformanceTrackingCallback
<a name="l05861"></a>05861 {
<a name="l05862"></a>05862 <span class="keyword">protected</span>:
<a name="l05863"></a>05863     <span class="keywordtype">void</span> handle(<span class="keyword">const</span> PerformanceTrackingData* data)
<a name="l05864"></a>05864     {
<a name="l05865"></a>05865         m_data = data;
<a name="l05866"></a>05866         base::type::stringstream_t ss;
<a name="l05867"></a>05867         <span class="keywordflow">if</span> (m_data-&gt;dataType() == PerformanceTrackingData::DataType::Complete) {
<a name="l05868"></a>05868             ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;Executed [&quot;</span>) &lt;&lt; m_data-&gt;blockName()-&gt;c_str() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;] in [&quot;</span>) &lt;&lt; *m_data-&gt;formattedTimeTaken() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05869"></a>05869         } <span class="keywordflow">else</span> {
<a name="l05870"></a>05870             ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;Performance checkpoint&quot;</span>);
<a name="l05871"></a>05871             <span class="keywordflow">if</span> (!m_data-&gt;checkpointId().empty()) {
<a name="l05872"></a>05872                 ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot; [&quot;</span>) &lt;&lt; m_data-&gt;checkpointId().c_str() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05873"></a>05873             }
<a name="l05874"></a>05874             ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot; for block [&quot;</span>) &lt;&lt; m_data-&gt;blockName()-&gt;c_str() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;] : [&quot;</span>) &lt;&lt; *m_data-&gt;performanceTracker();
<a name="l05875"></a>05875             <span class="keywordflow">if</span> (!ELPP-&gt;hasFlag(LoggingFlag::DisablePerformanceTrackingCheckpointComparison) &amp;&amp; m_data-&gt;performanceTracker()-&gt;m_hasChecked) {
<a name="l05876"></a>05876                 ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot; ([&quot;</span>) &lt;&lt; *m_data-&gt;formattedTimeTaken() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;] from &quot;</span>);
<a name="l05877"></a>05877                 <span class="keywordflow">if</span> (m_data-&gt;performanceTracker()-&gt;m_lastCheckpointId.empty()) {
<a name="l05878"></a>05878                     ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;last checkpoint&quot;</span>);
<a name="l05879"></a>05879                 } <span class="keywordflow">else</span> {
<a name="l05880"></a>05880                     ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;checkpoint &apos;&quot;</span>) &lt;&lt; m_data-&gt;performanceTracker()-&gt;m_lastCheckpointId.c_str() &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;&apos;&quot;</span>);
<a name="l05881"></a>05881                 }
<a name="l05882"></a>05882                 ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;)]&quot;</span>);
<a name="l05883"></a>05883             } <span class="keywordflow">else</span> {
<a name="l05884"></a>05884                 ss &lt;&lt; ELPP_LITERAL(<span class="stringliteral">&quot;]&quot;</span>);
<a name="l05885"></a>05885             }
<a name="l05886"></a>05886         }
<a name="l05887"></a>05887         el::base::Writer(m_data-&gt;performanceTracker()-&gt;level(), m_data-&gt;file(), m_data-&gt;line(), m_data-&gt;func()).construct(1, m_data-&gt;loggerId().c_str()) &lt;&lt; ss.str();
<a name="l05888"></a>05888     }
<a name="l05889"></a>05889 <span class="keyword">private</span>:
<a name="l05890"></a>05890     <span class="keyword">const</span> PerformanceTrackingData* m_data;
<a name="l05891"></a>05891 };
<a name="l05892"></a>05892 }  <span class="comment">// namespace base</span>
<a name="l05893"></a>05893 <span class="keyword">inline</span> <span class="keyword">const</span> std::string* PerformanceTrackingData::blockName()<span class="keyword"> const</span>
<a name="l05894"></a>05894 <span class="keyword"></span>{
<a name="l05895"></a>05895     <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keyword">const </span>std::string*<span class="keyword">&gt;</span>(&amp;m_performanceTracker-&gt;m_blockName);
<a name="l05896"></a>05896 }
<a name="l05897"></a>05897 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">struct </span>timeval* PerformanceTrackingData::startTime()<span class="keyword"> const </span>{
<a name="l05898"></a>05898     <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keyword">const </span>struct timeval*<span class="keyword">&gt;</span>(&amp;m_performanceTracker-&gt;m_startTime);
<a name="l05899"></a>05899 }
<a name="l05900"></a>05900 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">struct </span>timeval* PerformanceTrackingData::endTime()<span class="keyword"> const </span>{
<a name="l05901"></a>05901     <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keyword">const </span>struct timeval*<span class="keyword">&gt;</span>(&amp;m_performanceTracker-&gt;m_endTime);
<a name="l05902"></a>05902 }
<a name="l05903"></a>05903 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">struct </span>timeval* PerformanceTrackingData::lastCheckpointTime()<span class="keyword"> const </span>{
<a name="l05904"></a>05904     <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keyword">const </span>struct timeval*<span class="keyword">&gt;</span>(&amp;m_performanceTracker-&gt;m_lastCheckpointTime);
<a name="l05905"></a>05905 }
<a name="l05906"></a>05906 <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; PerformanceTrackingData::loggerId(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_performanceTracker-&gt;m_loggerId; }
<a name="l05907"></a>05907 <span class="keyword">namespace </span>base {
<a name="l05909"></a>05909 <span class="keyword">namespace </span>debug {
<a name="l05910"></a>05910 <span class="keyword">class </span>StackTrace : base::NoCopy
<a name="l05911"></a>05911 {
<a name="l05912"></a>05912 <span class="keyword">public</span>:
<a name="l05913"></a>05913     <span class="keyword">static</span> <span class="keyword">const</span> std::size_t kMaxStack = 64;
<a name="l05914"></a>05914     <span class="keyword">static</span> <span class="keyword">const</span> std::size_t kStackStart = 2;  <span class="comment">// We want to skip c&apos;tor and StackTrace::generateNew()</span>
<a name="l05915"></a>05915     <span class="keyword">class </span>StackTraceEntry
<a name="l05916"></a>05916     {
<a name="l05917"></a>05917     <span class="keyword">public</span>:
<a name="l05918"></a>05918         StackTraceEntry(std::size_t index, <span class="keyword">const</span> <span class="keywordtype">char</span>* loc, <span class="keyword">const</span> <span class="keywordtype">char</span>* demang, <span class="keyword">const</span> <span class="keywordtype">char</span>* hex, <span class="keyword">const</span> <span class="keywordtype">char</span>* addr)
<a name="l05919"></a>05919         {
<a name="l05920"></a>05920             m_index = index;
<a name="l05921"></a>05921             m_location = std::string(loc);
<a name="l05922"></a>05922             m_demangled = std::string(demang);
<a name="l05923"></a>05923             m_hex = std::string(hex);
<a name="l05924"></a>05924             m_addr = std::string(addr);
<a name="l05925"></a>05925         }
<a name="l05926"></a>05926         StackTraceEntry(std::size_t index, <span class="keywordtype">char</span>* loc)
<a name="l05927"></a>05927         {
<a name="l05928"></a>05928             m_index = index;
<a name="l05929"></a>05929             m_location = std::string(loc);
<a name="l05930"></a>05930         }
<a name="l05931"></a>05931         std::size_t m_index;
<a name="l05932"></a>05932         std::string m_location;
<a name="l05933"></a>05933         std::string m_demangled;
<a name="l05934"></a>05934         std::string m_hex;
<a name="l05935"></a>05935         std::string m_addr;
<a name="l05936"></a>05936         <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ss, <span class="keyword">const</span> StackTraceEntry&amp; si)
<a name="l05937"></a>05937         {
<a name="l05938"></a>05938             ss &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; si.m_index &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; si.m_location &lt;&lt; (si.m_demangled.empty() ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;:&quot;</span>) &lt;&lt; si.m_demangled
<a name="l05939"></a>05939                &lt;&lt; (si.m_hex.empty() ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;+&quot;</span>) &lt;&lt; si.m_hex &lt;&lt; si.m_addr;
<a name="l05940"></a>05940             <span class="keywordflow">return</span> ss;
<a name="l05941"></a>05941         }
<a name="l05942"></a>05942 
<a name="l05943"></a>05943     <span class="keyword">private</span>:
<a name="l05944"></a>05944         StackTraceEntry(<span class="keywordtype">void</span>);
<a name="l05945"></a>05945     };
<a name="l05946"></a>05946 
<a name="l05947"></a>05947     StackTrace(<span class="keywordtype">void</span>)
<a name="l05948"></a>05948     {
<a name="l05949"></a>05949         generateNew();
<a name="l05950"></a>05950     }
<a name="l05951"></a>05951 
<a name="l05952"></a>05952     <span class="keyword">virtual</span> ~StackTrace(<span class="keywordtype">void</span>)
<a name="l05953"></a>05953     {
<a name="l05954"></a>05954     }
<a name="l05955"></a>05955 
<a name="l05956"></a>05956     <span class="keyword">inline</span> std::vector&lt;StackTraceEntry&gt;&amp; getLatestStack(<span class="keywordtype">void</span>)
<a name="l05957"></a>05957     {
<a name="l05958"></a>05958         <span class="keywordflow">return</span> m_stack;
<a name="l05959"></a>05959     }
<a name="l05960"></a>05960 
<a name="l05961"></a>05961     <span class="keyword">friend</span> <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> StackTrace&amp; st)
<a name="l05962"></a>05962     {
<a name="l05963"></a>05963         std::vector&lt;StackTraceEntry&gt;::const_iterator it = st.m_stack.begin();
<a name="l05964"></a>05964         <span class="keywordflow">while</span> (it != st.m_stack.end()) {
<a name="l05965"></a>05965             os &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; *it++ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l05966"></a>05966         }
<a name="l05967"></a>05967         <span class="keywordflow">return</span> os;
<a name="l05968"></a>05968     }
<a name="l05969"></a>05969 
<a name="l05970"></a>05970 <span class="keyword">private</span>:
<a name="l05971"></a>05971     std::vector&lt;StackTraceEntry&gt; m_stack;
<a name="l05972"></a>05972 
<a name="l05973"></a>05973     <span class="keywordtype">void</span> generateNew(<span class="keywordtype">void</span>)
<a name="l05974"></a>05974     {
<a name="l05975"></a>05975 <span class="preprocessor">#if ELPP_STACKTRACE</span>
<a name="l05976"></a>05976 <span class="preprocessor"></span>        m_stack.clear();
<a name="l05977"></a>05977         <span class="keywordtype">void</span>* stack[kMaxStack];
<a name="l05978"></a>05978         std::size_t size = backtrace(stack, kMaxStack);
<a name="l05979"></a>05979         <span class="keywordtype">char</span>** strings = backtrace_symbols(stack, size);
<a name="l05980"></a>05980         <span class="keywordflow">if</span> (size &gt; kStackStart) {  <span class="comment">// Skip StackTrace c&apos;tor and generateNew</span>
<a name="l05981"></a>05981             <span class="keywordflow">for</span> (std::size_t i = kStackStart; i &lt; size; ++i) {
<a name="l05982"></a>05982                 <span class="keywordtype">char</span>* mangName = <span class="keyword">nullptr</span>;
<a name="l05983"></a>05983                 <span class="keywordtype">char</span>* hex = <span class="keyword">nullptr</span>;
<a name="l05984"></a>05984                 <span class="keywordtype">char</span>* addr = <span class="keyword">nullptr</span>;
<a name="l05985"></a>05985                 <span class="keywordflow">for</span> (<span class="keywordtype">char</span>* c = strings[i]; *c; ++c) {
<a name="l05986"></a>05986                     <span class="keywordflow">switch</span> (*c) {
<a name="l05987"></a>05987                         <span class="keywordflow">case</span> <span class="charliteral">&apos;(&apos;</span>:
<a name="l05988"></a>05988                             mangName = c;
<a name="l05989"></a>05989                             <span class="keywordflow">break</span>;
<a name="l05990"></a>05990                         <span class="keywordflow">case</span> <span class="charliteral">&apos;+&apos;</span>:
<a name="l05991"></a>05991                             hex = c;
<a name="l05992"></a>05992                             <span class="keywordflow">break</span>;
<a name="l05993"></a>05993                         <span class="keywordflow">case</span> <span class="charliteral">&apos;)&apos;</span>:
<a name="l05994"></a>05994                             addr = c;
<a name="l05995"></a>05995                             <span class="keywordflow">break</span>;
<a name="l05996"></a>05996                     }
<a name="l05997"></a>05997                 }
<a name="l05998"></a>05998                 <span class="comment">// Perform demangling if parsed properly</span>
<a name="l05999"></a>05999                 <span class="keywordflow">if</span> (mangName != <span class="keyword">nullptr</span> &amp;&amp; hex != <span class="keyword">nullptr</span> &amp;&amp; addr != <span class="keyword">nullptr</span> &amp;&amp; mangName &lt; hex) {
<a name="l06000"></a>06000                     *mangName++ = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l06001"></a>06001                     *hex++ = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l06002"></a>06002                     *addr++ = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l06003"></a>06003                     <span class="keywordtype">int</span> status = 0;
<a name="l06004"></a>06004                     <span class="keywordtype">char</span>* demangName = abi::__cxa_demangle(mangName, 0, 0, &amp;status);
<a name="l06005"></a>06005                     <span class="comment">// if demangling is successful, output the demangled function name</span>
<a name="l06006"></a>06006                     <span class="keywordflow">if</span> (status == 0) {
<a name="l06007"></a>06007                         <span class="comment">// Success (see http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01696.html)</span>
<a name="l06008"></a>06008                         StackTraceEntry entry(i - 1, strings[i], demangName, hex, addr);
<a name="l06009"></a>06009                         m_stack.push_back(entry);
<a name="l06010"></a>06010                     } <span class="keywordflow">else</span> {
<a name="l06011"></a>06011                         <span class="comment">// Not successful - we will use mangled name</span>
<a name="l06012"></a>06012                         StackTraceEntry entry(i - 1, strings[i], mangName, hex, addr);
<a name="l06013"></a>06013                         m_stack.push_back(entry);
<a name="l06014"></a>06014                     }
<a name="l06015"></a>06015                     free(demangName);
<a name="l06016"></a>06016                 } <span class="keywordflow">else</span> {
<a name="l06017"></a>06017                     StackTraceEntry entry(i - 1, strings[i]);
<a name="l06018"></a>06018                     m_stack.push_back(entry);
<a name="l06019"></a>06019                 }
<a name="l06020"></a>06020             }
<a name="l06021"></a>06021         }
<a name="l06022"></a>06022         free(strings);
<a name="l06023"></a>06023 <span class="preprocessor">#else</span>
<a name="l06024"></a>06024 <span class="preprocessor"></span>        ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Stacktrace generation not supported for selected compiler&quot;</span>);
<a name="l06025"></a>06025 <span class="preprocessor">#endif  // ELPP_STACKTRACE</span>
<a name="l06026"></a>06026 <span class="preprocessor"></span>    }
<a name="l06027"></a>06027 };
<a name="l06028"></a>06028 <span class="keyword">static</span> std::string crashReason(<span class="keywordtype">int</span> sig)
<a name="l06029"></a>06029 {
<a name="l06030"></a>06030     std::stringstream ss;
<a name="l06031"></a>06031     <span class="keywordtype">bool</span> foundReason = <span class="keyword">false</span>;
<a name="l06032"></a>06032     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; base::consts::kCrashSignalsCount; ++i) {
<a name="l06033"></a>06033         <span class="keywordflow">if</span> (base::consts::kCrashSignals[i].numb == sig) {
<a name="l06034"></a>06034             ss &lt;&lt; <span class="stringliteral">&quot;Application has crashed due to [&quot;</span> &lt;&lt; base::consts::kCrashSignals[i].name &lt;&lt; <span class="stringliteral">&quot;] signal&quot;</span>;
<a name="l06035"></a>06035             <span class="keywordflow">if</span> (ELPP-&gt;hasFlag(el::LoggingFlag::LogDetailedCrashReason)) {
<a name="l06036"></a>06036                 ss &lt;&lt; std::endl &lt;&lt;
<a name="l06037"></a>06037                    <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; base::consts::kCrashSignals[i].brief &lt;&lt; std::endl &lt;&lt;
<a name="l06038"></a>06038                    <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; base::consts::kCrashSignals[i].detail;
<a name="l06039"></a>06039             }
<a name="l06040"></a>06040             foundReason = <span class="keyword">true</span>;
<a name="l06041"></a>06041         }
<a name="l06042"></a>06042     }
<a name="l06043"></a>06043     <span class="keywordflow">if</span> (!foundReason) {
<a name="l06044"></a>06044         ss &lt;&lt; <span class="stringliteral">&quot;Application has crashed due to unknown signal [&quot;</span> &lt;&lt; sig &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l06045"></a>06045     }
<a name="l06046"></a>06046     <span class="keywordflow">return</span> ss.str();
<a name="l06047"></a>06047 }
<a name="l06049"></a>06049 <span class="keyword">static</span> <span class="keywordtype">void</span> logCrashReason(<span class="keywordtype">int</span> sig, <span class="keywordtype">bool</span> stackTraceIfAvailable, Level level, <span class="keyword">const</span> <span class="keywordtype">char</span>* logger)
<a name="l06050"></a>06050 {
<a name="l06051"></a>06051     std::stringstream ss;
<a name="l06052"></a>06052     ss &lt;&lt; <span class="stringliteral">&quot;CRASH HANDLED; &quot;</span>;
<a name="l06053"></a>06053     ss &lt;&lt; crashReason(sig);
<a name="l06054"></a>06054 <span class="preprocessor">#if ELPP_STACKTRACE</span>
<a name="l06055"></a>06055 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (stackTraceIfAvailable) {
<a name="l06056"></a>06056         ss &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;    ======= Backtrace: =========&quot;</span> &lt;&lt; std::endl &lt;&lt; base::debug::StackTrace();
<a name="l06057"></a>06057     }
<a name="l06058"></a>06058 <span class="preprocessor">#else</span>
<a name="l06059"></a>06059 <span class="preprocessor"></span>    ELPP_UNUSED(stackTraceIfAvailable);
<a name="l06060"></a>06060 <span class="preprocessor">#endif  // ELPP_STACKTRACE</span>
<a name="l06061"></a>06061 <span class="preprocessor"></span>    ELPP_WRITE_LOG(el::base::Writer, level, base::DispatchAction::NormalLog, logger) &lt;&lt; ss.str();
<a name="l06062"></a>06062 }
<a name="l06063"></a>06063 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> crashAbort(<span class="keywordtype">int</span> sig)
<a name="l06064"></a>06064 {
<a name="l06065"></a>06065     base::utils::abort(sig);
<a name="l06066"></a>06066 }
<a name="l06070"></a>06070 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> defaultCrashHandler(<span class="keywordtype">int</span> sig)
<a name="l06071"></a>06071 {
<a name="l06072"></a>06072     base::debug::logCrashReason(sig, <span class="keyword">true</span>, Level::Fatal, base::consts::kDefaultLoggerId);
<a name="l06073"></a>06073     base::debug::crashAbort(sig);
<a name="l06074"></a>06074 }
<a name="l06076"></a>06076 <span class="keyword">class </span>CrashHandler : base::NoCopy
<a name="l06077"></a>06077 {
<a name="l06078"></a>06078 <span class="keyword">public</span>:
<a name="l06079"></a>06079     <span class="keyword">typedef</span> void (*Handler)(int);
<a name="l06080"></a>06080 
<a name="l06081"></a>06081     <span class="keyword">explicit</span> CrashHandler(<span class="keywordtype">bool</span> useDefault)
<a name="l06082"></a>06082     {
<a name="l06083"></a>06083         <span class="keywordflow">if</span> (useDefault) {
<a name="l06084"></a>06084             setHandler(defaultCrashHandler);
<a name="l06085"></a>06085         }
<a name="l06086"></a>06086     }
<a name="l06087"></a>06087     <span class="keyword">explicit</span> CrashHandler(<span class="keyword">const</span> Handler&amp; cHandler)
<a name="l06088"></a>06088     {
<a name="l06089"></a>06089         setHandler(cHandler);
<a name="l06090"></a>06090     }
<a name="l06091"></a>06091     <span class="keywordtype">void</span> setHandler(<span class="keyword">const</span> Handler&amp; cHandler)
<a name="l06092"></a>06092     {
<a name="l06093"></a>06093         m_handler = cHandler;
<a name="l06094"></a>06094 <span class="preprocessor">#if defined(ELPP_HANDLE_SIGABRT)</span>
<a name="l06095"></a>06095 <span class="preprocessor"></span>        <span class="keywordtype">int</span> i = 0;  <span class="comment">// SIGABRT is at base::consts::kCrashSignals[0]</span>
<a name="l06096"></a>06096 <span class="preprocessor">#else</span>
<a name="l06097"></a>06097 <span class="preprocessor"></span>        <span class="keywordtype">int</span> i = 1;
<a name="l06098"></a>06098 <span class="preprocessor">#endif  // defined(ELPP_HANDLE_SIGABRT)</span>
<a name="l06099"></a>06099 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (; i &lt; base::consts::kCrashSignalsCount; ++i) {
<a name="l06100"></a>06100             m_handler = signal(base::consts::kCrashSignals[i].numb, cHandler);
<a name="l06101"></a>06101         }
<a name="l06102"></a>06102     }
<a name="l06103"></a>06103 
<a name="l06104"></a>06104 <span class="keyword">private</span>:
<a name="l06105"></a>06105     Handler m_handler;
<a name="l06106"></a>06106 };
<a name="l06107"></a>06107 }  <span class="comment">// namespace debug</span>
<a name="l06108"></a>06108 }  <span class="comment">// namespace base</span>
<a name="l06109"></a>06109 <span class="keyword">extern</span> base::debug::CrashHandler elCrashHandler;
<a name="l06110"></a>06110 <span class="preprocessor">#define MAKE_LOGGABLE(ClassType, ClassInstance, OutputStreamInstance) \</span>
<a name="l06111"></a>06111 <span class="preprocessor">    el::base::type::ostream_t&amp; operator&lt;&lt;(el::base::type::ostream_t&amp; OutputStreamInstance, const ClassType&amp; ClassInstance)</span>
<a name="l06113"></a>06113 <span class="preprocessor">class SysLogInitializer</span>
<a name="l06114"></a>06114 <span class="preprocessor"></span>{
<a name="l06115"></a>06115 <span class="keyword">public</span>:
<a name="l06116"></a>06116     SysLogInitializer(<span class="keyword">const</span> <span class="keywordtype">char</span>* processIdent, <span class="keywordtype">int</span> options = 0, <span class="keywordtype">int</span> facility = 0)
<a name="l06117"></a>06117     {
<a name="l06118"></a>06118 <span class="preprocessor">#if defined(ELPP_SYSLOG)</span>
<a name="l06119"></a>06119 <span class="preprocessor"></span>        openlog(processIdent, options, facility);
<a name="l06120"></a>06120 <span class="preprocessor">#else</span>
<a name="l06121"></a>06121 <span class="preprocessor"></span>        ELPP_UNUSED(processIdent);
<a name="l06122"></a>06122         ELPP_UNUSED(options);
<a name="l06123"></a>06123         ELPP_UNUSED(facility);
<a name="l06124"></a>06124 <span class="preprocessor">#endif  // defined(ELPP_SYSLOG)</span>
<a name="l06125"></a>06125 <span class="preprocessor"></span>    }
<a name="l06126"></a>06126     <span class="keyword">virtual</span> ~SysLogInitializer(<span class="keywordtype">void</span>)
<a name="l06127"></a>06127     {
<a name="l06128"></a>06128 <span class="preprocessor">#if defined(ELPP_SYSLOG)</span>
<a name="l06129"></a>06129 <span class="preprocessor"></span>        closelog();
<a name="l06130"></a>06130 <span class="preprocessor">#endif  // defined(ELPP_SYSLOG)</span>
<a name="l06131"></a>06131 <span class="preprocessor"></span>    }
<a name="l06132"></a>06132 };
<a name="l06133"></a>06133 <span class="preprocessor">#define ELPP_INITIALIZE_SYSLOG(id, opt, fac) el::SysLogInitializer elSyslogInit(id, opt, fac)</span>
<a name="l06135"></a>06135 <span class="preprocessor">class Helpers : base::StaticClass</span>
<a name="l06136"></a>06136 <span class="preprocessor"></span>{
<a name="l06137"></a>06137 <span class="keyword">public</span>:
<a name="l06139"></a>06139     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setStorage(base::type::StoragePointer storage)
<a name="l06140"></a>06140     {
<a name="l06141"></a>06141         ELPP = storage;
<a name="l06142"></a>06142     }
<a name="l06144"></a>06144     <span class="keyword">static</span> <span class="keyword">inline</span> base::type::StoragePointer storage()
<a name="l06145"></a>06145     {
<a name="l06146"></a>06146         <span class="keywordflow">return</span> ELPP;
<a name="l06147"></a>06147     }
<a name="l06149"></a>06149     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setArgs(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
<a name="l06150"></a>06150     {
<a name="l06151"></a>06151         ELPP-&gt;setApplicationArguments(argc, argv);
<a name="l06152"></a>06152     }
<a name="l06154"></a>06154     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setArgs(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)
<a name="l06155"></a>06155     {
<a name="l06156"></a>06156         ELPP-&gt;setApplicationArguments(argc, const_cast&lt;char**&gt;(argv));
<a name="l06157"></a>06157     }
<a name="l06161"></a>06161     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setCrashHandler(<span class="keyword">const</span> el::base::debug::CrashHandler::Handler&amp; crashHandler)
<a name="l06162"></a>06162     {
<a name="l06163"></a>06163         el::elCrashHandler.setHandler(crashHandler);
<a name="l06164"></a>06164     }
<a name="l06167"></a>06167     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> crashAbort(<span class="keywordtype">int</span> sig, <span class="keyword">const</span> <span class="keywordtype">char</span>* sourceFile = <span class="stringliteral">&quot;&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">long</span> line = 0)
<a name="l06168"></a>06168     {
<a name="l06169"></a>06169         std::stringstream ss;
<a name="l06170"></a>06170         ss &lt;&lt; base::debug::crashReason(sig).c_str();
<a name="l06171"></a>06171         ss &lt;&lt; <span class="stringliteral">&quot; - [Called el::Helpers::crashAbort(&quot;</span> &lt;&lt; sig &lt;&lt; <span class="stringliteral">&quot;)]&quot;</span>;
<a name="l06172"></a>06172         <span class="keywordflow">if</span> (sourceFile != <span class="keyword">nullptr</span> &amp;&amp; strlen(sourceFile) &gt; 0) {
<a name="l06173"></a>06173             ss &lt;&lt; <span class="stringliteral">&quot; - Source: &quot;</span> &lt;&lt; sourceFile;
<a name="l06174"></a>06174             <span class="keywordflow">if</span> (line &gt; 0)
<a name="l06175"></a>06175                 ss &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; line;
<a name="l06176"></a>06176             <span class="keywordflow">else</span>
<a name="l06177"></a>06177                 ss &lt;&lt; <span class="stringliteral">&quot; (line number not specified)&quot;</span>;
<a name="l06178"></a>06178         }
<a name="l06179"></a>06179         base::utils::abort(sig, ss.str());
<a name="l06180"></a>06180     }
<a name="l06186"></a>06186     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> logCrashReason(<span class="keywordtype">int</span> sig, <span class="keywordtype">bool</span> stackTraceIfAvailable = <span class="keyword">false</span>,
<a name="l06187"></a>06187                                       Level level = Level::Fatal, <span class="keyword">const</span> <span class="keywordtype">char</span>* logger = base::consts::kDefaultLoggerId)
<a name="l06188"></a>06188     {
<a name="l06189"></a>06189         el::base::debug::logCrashReason(sig, stackTraceIfAvailable, level, logger);
<a name="l06190"></a>06190     }
<a name="l06193"></a>06193     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> installPreRollOutCallback(<span class="keyword">const</span> PreRollOutCallback&amp; callback)
<a name="l06194"></a>06194     {
<a name="l06195"></a>06195         ELPP-&gt;setPreRollOutCallback(callback);
<a name="l06196"></a>06196     }
<a name="l06198"></a>06198     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> uninstallPreRollOutCallback(<span class="keywordtype">void</span>)
<a name="l06199"></a>06199     {
<a name="l06200"></a>06200         ELPP-&gt;unsetPreRollOutCallback();
<a name="l06201"></a>06201     }
<a name="l06203"></a>06203     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06204"></a>06204     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> installLogDispatchCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l06205"></a>06205     {
<a name="l06206"></a>06206         <span class="keywordflow">return</span> ELPP-&gt;installLogDispatchCallback&lt;T&gt;(id);
<a name="l06207"></a>06207     }
<a name="l06209"></a>06209     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06210"></a>06210     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> uninstallLogDispatchCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l06211"></a>06211     {
<a name="l06212"></a>06212         ELPP-&gt;uninstallLogDispatchCallback&lt;T&gt;(id);
<a name="l06213"></a>06213     }
<a name="l06214"></a>06214     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06215"></a>06215     <span class="keyword">static</span> <span class="keyword">inline</span> T* logDispatchCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l06216"></a>06216     {
<a name="l06217"></a>06217         <span class="keywordflow">return</span> ELPP-&gt;logDispatchCallback&lt;T&gt;(id);
<a name="l06218"></a>06218     }
<a name="l06220"></a>06220     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06221"></a>06221     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> installPerformanceTrackingCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l06222"></a>06222     {
<a name="l06223"></a>06223         <span class="keywordflow">return</span> ELPP-&gt;installPerformanceTrackingCallback&lt;T&gt;(id);
<a name="l06224"></a>06224     }
<a name="l06226"></a>06226     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06227"></a>06227     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> uninstallPerformanceTrackingCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l06228"></a>06228     {
<a name="l06229"></a>06229         ELPP-&gt;uninstallPerformanceTrackingCallback&lt;T&gt;(id);
<a name="l06230"></a>06230     }
<a name="l06231"></a>06231     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06232"></a>06232     <span class="keyword">static</span> <span class="keyword">inline</span> T* performanceTrackingCallback(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>)
<a name="l06233"></a>06233     {
<a name="l06234"></a>06234         <span class="keywordflow">return</span> ELPP-&gt;performanceTrackingCallback&lt;T&gt;(id);
<a name="l06235"></a>06235     }
<a name="l06237"></a>06237     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l06238"></a>06238     <span class="keyword">static</span> std::string convertTemplateToStdString(<span class="keyword">const</span> T&amp; templ)
<a name="l06239"></a>06239     {
<a name="l06240"></a>06240         el::Logger* logger =
<a name="l06241"></a>06241             ELPP-&gt;registeredLoggers()-&gt;get(el::base::consts::kDefaultLoggerId);
<a name="l06242"></a>06242         <span class="keywordflow">if</span> (logger == <span class="keyword">nullptr</span>) {
<a name="l06243"></a>06243             <span class="keywordflow">return</span> std::string();
<a name="l06244"></a>06244         }
<a name="l06245"></a>06245         base::MessageBuilder b;
<a name="l06246"></a>06246         b.initialize(logger);
<a name="l06247"></a>06247         logger-&gt;acquireLock();
<a name="l06248"></a>06248         b &lt;&lt; templ;
<a name="l06249"></a>06249 <span class="preprocessor">#if defined(ELPP_UNICODE)</span>
<a name="l06250"></a>06250 <span class="preprocessor"></span>        std::string s = std::string(logger-&gt;stream().str().begin(), logger-&gt;stream().str().end());
<a name="l06251"></a>06251 <span class="preprocessor">#else</span>
<a name="l06252"></a>06252 <span class="preprocessor"></span>        std::string s = logger-&gt;stream().str();
<a name="l06253"></a>06253 <span class="preprocessor">#endif  // defined(ELPP_UNICODE)</span>
<a name="l06254"></a>06254 <span class="preprocessor"></span>        logger-&gt;stream().str(ELPP_LITERAL(<span class="stringliteral">&quot;&quot;</span>));
<a name="l06255"></a>06255         logger-&gt;releaseLock();
<a name="l06256"></a>06256         <span class="keywordflow">return</span> s;
<a name="l06257"></a>06257     }
<a name="l06259"></a>06259     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> el::base::utils::CommandLineArgs* commandLineArgs(<span class="keywordtype">void</span>)
<a name="l06260"></a>06260     {
<a name="l06261"></a>06261         <span class="keywordflow">return</span> ELPP-&gt;commandLineArgs();
<a name="l06262"></a>06262     }
<a name="l06264"></a>06264     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> installCustomFormatSpecifier(<span class="keyword">const</span> CustomFormatSpecifier&amp; customFormatSpecifier)
<a name="l06265"></a>06265     {
<a name="l06266"></a>06266         ELPP-&gt;installCustomFormatSpecifier(customFormatSpecifier);
<a name="l06267"></a>06267     }
<a name="l06269"></a>06269     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> uninstallCustomFormatSpecifier(<span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier)
<a name="l06270"></a>06270     {
<a name="l06271"></a>06271         <span class="keywordflow">return</span> ELPP-&gt;uninstallCustomFormatSpecifier(formatSpecifier);
<a name="l06272"></a>06272     }
<a name="l06274"></a>06274     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasCustomFormatSpecifier(<span class="keyword">const</span> <span class="keywordtype">char</span>* formatSpecifier)
<a name="l06275"></a>06275     {
<a name="l06276"></a>06276         <span class="keywordflow">return</span> ELPP-&gt;hasCustomFormatSpecifier(formatSpecifier);
<a name="l06277"></a>06277     }
<a name="l06278"></a>06278     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> validateFileRolling(Logger* logger, Level level)
<a name="l06279"></a>06279     {
<a name="l06280"></a>06280         <span class="keywordflow">if</span> (logger == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span>;
<a name="l06281"></a>06281         logger-&gt;m_typedConfigurations-&gt;validateFileRolling(level, ELPP-&gt;preRollOutCallback());
<a name="l06282"></a>06282     }
<a name="l06283"></a>06283 };
<a name="l06285"></a>06285 <span class="keyword">class </span>Loggers : base::StaticClass
<a name="l06286"></a>06286 {
<a name="l06287"></a>06287 <span class="keyword">public</span>:
<a name="l06289"></a>06289     <span class="keyword">static</span> <span class="keyword">inline</span> Logger* getLogger(<span class="keyword">const</span> std::string&amp; identity, <span class="keywordtype">bool</span> registerIfNotAvailable = <span class="keyword">true</span>)
<a name="l06290"></a>06290     {
<a name="l06291"></a>06291         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<a name="l06292"></a>06292         <span class="keywordflow">return</span> ELPP-&gt;registeredLoggers()-&gt;get(identity, registerIfNotAvailable);
<a name="l06293"></a>06293     }
<a name="l06296"></a>06296     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> unregisterLogger(<span class="keyword">const</span> std::string&amp; identity)
<a name="l06297"></a>06297     {
<a name="l06298"></a>06298         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<a name="l06299"></a>06299         <span class="keywordflow">return</span> ELPP-&gt;registeredLoggers()-&gt;remove(identity);
<a name="l06300"></a>06300     }
<a name="l06302"></a>06302     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasLogger(<span class="keyword">const</span> std::string&amp; identity)
<a name="l06303"></a>06303     {
<a name="l06304"></a>06304         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<a name="l06305"></a>06305         <span class="keywordflow">return</span> ELPP-&gt;registeredLoggers()-&gt;has(identity);
<a name="l06306"></a>06306     }
<a name="l06308"></a>06308     <span class="keyword">static</span> <span class="keyword">inline</span> Logger* reconfigureLogger(Logger* logger, <span class="keyword">const</span> Configurations&amp; configurations)
<a name="l06309"></a>06309     {
<a name="l06310"></a>06310         <span class="keywordflow">if</span> (!logger) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l06311"></a>06311         logger-&gt;configure(configurations);
<a name="l06312"></a>06312         <span class="keywordflow">return</span> logger;
<a name="l06313"></a>06313     }
<a name="l06315"></a>06315     <span class="keyword">static</span> <span class="keyword">inline</span> Logger* reconfigureLogger(<span class="keyword">const</span> std::string&amp; identity, <span class="keyword">const</span> Configurations&amp; configurations)
<a name="l06316"></a>06316     {
<a name="l06317"></a>06317         <span class="keywordflow">return</span> Loggers::reconfigureLogger(Loggers::getLogger(identity), configurations);
<a name="l06318"></a>06318     }
<a name="l06320"></a>06320     <span class="keyword">static</span> <span class="keyword">inline</span> Logger* reconfigureLogger(<span class="keyword">const</span> std::string&amp; identity, ConfigurationType configurationType,
<a name="l06321"></a>06321                                             <span class="keyword">const</span> std::string&amp; value)
<a name="l06322"></a>06322     {
<a name="l06323"></a>06323         Logger* logger = Loggers::getLogger(identity);
<a name="l06324"></a>06324         <span class="keywordflow">if</span> (logger == <span class="keyword">nullptr</span>) {
<a name="l06325"></a>06325             <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l06326"></a>06326         }
<a name="l06327"></a>06327         logger-&gt;configurations()-&gt;set(Level::Global, configurationType, value);
<a name="l06328"></a>06328         logger-&gt;reconfigure();
<a name="l06329"></a>06329         <span class="keywordflow">return</span> logger;
<a name="l06330"></a>06330     }
<a name="l06332"></a>06332     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> reconfigureAllLoggers(<span class="keyword">const</span> Configurations&amp; configurations)
<a name="l06333"></a>06333     {
<a name="l06334"></a>06334         <span class="keywordflow">for</span> (base::RegisteredLoggers::iterator it = ELPP-&gt;registeredLoggers()-&gt;begin();
<a name="l06335"></a>06335                 it != ELPP-&gt;registeredLoggers()-&gt;end(); ++it) {
<a name="l06336"></a>06336             Loggers::reconfigureLogger(it-&gt;second, configurations);
<a name="l06337"></a>06337         }
<a name="l06338"></a>06338     }
<a name="l06340"></a>06340     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> reconfigureAllLoggers(ConfigurationType configurationType, <span class="keyword">const</span> std::string&amp; value)
<a name="l06341"></a>06341     {
<a name="l06342"></a>06342         reconfigureAllLoggers(Level::Global, configurationType, value);
<a name="l06343"></a>06343     }
<a name="l06345"></a>06345     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> reconfigureAllLoggers(Level level, ConfigurationType configurationType,
<a name="l06346"></a>06346             <span class="keyword">const</span> std::string&amp; value)
<a name="l06347"></a>06347     {
<a name="l06348"></a>06348         <span class="keywordflow">for</span> (base::RegisteredLoggers::iterator it = ELPP-&gt;registeredLoggers()-&gt;begin();
<a name="l06349"></a>06349                 it != ELPP-&gt;registeredLoggers()-&gt;end(); ++it) {
<a name="l06350"></a>06350             Logger* logger = it-&gt;second;
<a name="l06351"></a>06351             logger-&gt;configurations()-&gt;set(level, configurationType, value);
<a name="l06352"></a>06352             logger-&gt;reconfigure();
<a name="l06353"></a>06353         }
<a name="l06354"></a>06354     }
<a name="l06356"></a>06356     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setDefaultConfigurations(<span class="keyword">const</span> Configurations&amp; configurations, <span class="keywordtype">bool</span> reconfigureExistingLoggers = <span class="keyword">false</span>)
<a name="l06357"></a>06357     {
<a name="l06358"></a>06358         ELPP-&gt;registeredLoggers()-&gt;setDefaultConfigurations(configurations);
<a name="l06359"></a>06359         <span class="keywordflow">if</span> (reconfigureExistingLoggers) {
<a name="l06360"></a>06360             Loggers::reconfigureAllLoggers(configurations);
<a name="l06361"></a>06361         }
<a name="l06362"></a>06362     }
<a name="l06364"></a>06364     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> Configurations* defaultConfigurations(<span class="keywordtype">void</span>)
<a name="l06365"></a>06365     {
<a name="l06366"></a>06366         <span class="keywordflow">return</span> ELPP-&gt;registeredLoggers()-&gt;defaultConfigurations();
<a name="l06367"></a>06367     }
<a name="l06369"></a>06369     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> base::LogStreamsReferenceMap* logStreamsReference(<span class="keywordtype">void</span>)
<a name="l06370"></a>06370     {
<a name="l06371"></a>06371         <span class="keywordflow">return</span> ELPP-&gt;registeredLoggers()-&gt;logStreamsReference();
<a name="l06372"></a>06372     }
<a name="l06374"></a>06374     <span class="keyword">static</span> base::TypedConfigurations defaultTypedConfigurations(<span class="keywordtype">void</span>)
<a name="l06375"></a>06375     {
<a name="l06376"></a>06376         <span class="keywordflow">return</span> base::TypedConfigurations(
<a name="l06377"></a>06377                    ELPP-&gt;registeredLoggers()-&gt;defaultConfigurations(),
<a name="l06378"></a>06378                    ELPP-&gt;registeredLoggers()-&gt;logStreamsReference());
<a name="l06379"></a>06379     }
<a name="l06382"></a>06382     <span class="keyword">static</span> <span class="keyword">inline</span> std::vector&lt;std::string&gt;* populateAllLoggerIds(std::vector&lt;std::string&gt;* targetList)
<a name="l06383"></a>06383     {
<a name="l06384"></a>06384         targetList-&gt;clear();
<a name="l06385"></a>06385         <span class="keywordflow">for</span> (base::RegisteredLoggers::iterator it = ELPP-&gt;registeredLoggers()-&gt;list().begin();
<a name="l06386"></a>06386                 it != ELPP-&gt;registeredLoggers()-&gt;list().end(); ++it) {
<a name="l06387"></a>06387             targetList-&gt;push_back(it-&gt;first);
<a name="l06388"></a>06388         }
<a name="l06389"></a>06389         <span class="keywordflow">return</span> targetList;
<a name="l06390"></a>06390     }
<a name="l06392"></a>06392     <span class="keyword">static</span> <span class="keywordtype">void</span> configureFromGlobal(<span class="keyword">const</span> <span class="keywordtype">char</span>* globalConfigurationFilePath)
<a name="l06393"></a>06393     {
<a name="l06394"></a>06394         std::ifstream gcfStream(globalConfigurationFilePath, std::ifstream::in);
<a name="l06395"></a>06395         ELPP_ASSERT(gcfStream.is_open(), <span class="stringliteral">&quot;Unable to open global configuration file [&quot;</span> &lt;&lt; globalConfigurationFilePath
<a name="l06396"></a>06396                     &lt;&lt; <span class="stringliteral">&quot;] for parsing.&quot;</span>);
<a name="l06397"></a>06397         std::string line = std::string();
<a name="l06398"></a>06398         std::stringstream ss;
<a name="l06399"></a>06399         Logger* logger = <span class="keyword">nullptr</span>;
<a name="l06400"></a>06400         <span class="keyword">auto</span> configure = [&amp;](void) {
<a name="l06401"></a>06401             ELPP_INTERNAL_INFO(8, <span class="stringliteral">&quot;Configuring logger: &apos;&quot;</span> &lt;&lt; logger-&gt;id() &lt;&lt; <span class="stringliteral">&quot;&apos; with configurations \n&quot;</span> &lt;&lt; ss.str()
<a name="l06402"></a>06402                                &lt;&lt; <span class="stringliteral">&quot;\n--------------&quot;</span>);
<a name="l06403"></a>06403             Configurations c;
<a name="l06404"></a>06404             c.parseFromText(ss.str());
<a name="l06405"></a>06405             logger-&gt;configure(c);
<a name="l06406"></a>06406         };
<a name="l06407"></a>06407         <span class="keywordflow">while</span> (gcfStream.good()) {
<a name="l06408"></a>06408             std::getline(gcfStream, line);
<a name="l06409"></a>06409             ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Parsing line: &quot;</span> &lt;&lt; line);
<a name="l06410"></a>06410             base::utils::Str::trim(line);
<a name="l06411"></a>06411             <span class="keywordflow">if</span> (Configurations::Parser::isComment(line)) <span class="keywordflow">continue</span>;
<a name="l06412"></a>06412             Configurations::Parser::ignoreComments(&amp;line);
<a name="l06413"></a>06413             base::utils::Str::trim(line);
<a name="l06414"></a>06414             <span class="keywordflow">if</span> (line.size() &gt; 2 &amp;&amp; base::utils::Str::startsWith(line, std::string(base::consts::kConfigurationLoggerId))) {
<a name="l06415"></a>06415                 <span class="keywordflow">if</span> (!ss.str().empty() &amp;&amp; logger != <span class="keyword">nullptr</span>) {
<a name="l06416"></a>06416                     configure();
<a name="l06417"></a>06417                 }
<a name="l06418"></a>06418                 ss.str(std::string(<span class="stringliteral">&quot;&quot;</span>));
<a name="l06419"></a>06419                 line = line.substr(2);
<a name="l06420"></a>06420                 base::utils::Str::trim(line);
<a name="l06421"></a>06421                 <span class="keywordflow">if</span> (line.size() &gt; 1) {
<a name="l06422"></a>06422                     ELPP_INTERNAL_INFO(1, <span class="stringliteral">&quot;Getting logger: &apos;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&apos;&quot;</span>);
<a name="l06423"></a>06423                     logger = getLogger(line);
<a name="l06424"></a>06424                 }
<a name="l06425"></a>06425             } <span class="keywordflow">else</span> {
<a name="l06426"></a>06426                 ss &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l06427"></a>06427             }
<a name="l06428"></a>06428         }
<a name="l06429"></a>06429         <span class="keywordflow">if</span> (!ss.str().empty() &amp;&amp; logger != <span class="keyword">nullptr</span>) {
<a name="l06430"></a>06430             configure();
<a name="l06431"></a>06431         }
<a name="l06432"></a>06432     }
<a name="l06437"></a>06437     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> configureFromArg(<span class="keyword">const</span> <span class="keywordtype">char</span>* argKey)
<a name="l06438"></a>06438     {
<a name="l06439"></a>06439 <span class="preprocessor">#if defined(ELPP_DISABLE_CONFIGURATION_FROM_PROGRAM_ARGS)</span>
<a name="l06440"></a>06440 <span class="preprocessor"></span>        ELPP_UNUSED(argKey);
<a name="l06441"></a>06441 <span class="preprocessor">#else</span>
<a name="l06442"></a>06442 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!Helpers::commandLineArgs()-&gt;hasParamWithValue(argKey)) {
<a name="l06443"></a>06443             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06444"></a>06444         }
<a name="l06445"></a>06445         configureFromGlobal(Helpers::commandLineArgs()-&gt;getParamValue(argKey));
<a name="l06446"></a>06446 <span class="preprocessor">#endif  // defined(ELPP_DISABLE_CONFIGURATION_FROM_PROGRAM_ARGS)</span>
<a name="l06447"></a>06447 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l06448"></a>06448     }
<a name="l06450"></a>06450     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> flushAll(<span class="keywordtype">void</span>)
<a name="l06451"></a>06451     {
<a name="l06452"></a>06452         ELPP-&gt;registeredLoggers()-&gt;flushAll();
<a name="l06453"></a>06453     }
<a name="l06455"></a>06455     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> addFlag(LoggingFlag flag)
<a name="l06456"></a>06456     {
<a name="l06457"></a>06457         ELPP-&gt;addFlag(flag);
<a name="l06458"></a>06458     }
<a name="l06460"></a>06460     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> removeFlag(LoggingFlag flag)
<a name="l06461"></a>06461     {
<a name="l06462"></a>06462         ELPP-&gt;removeFlag(flag);
<a name="l06463"></a>06463     }
<a name="l06465"></a>06465     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> hasFlag(LoggingFlag flag)
<a name="l06466"></a>06466     {
<a name="l06467"></a>06467         <span class="keywordflow">return</span> ELPP-&gt;hasFlag(flag);
<a name="l06468"></a>06468     }
<a name="l06470"></a>06470     <span class="keyword">class </span>ScopedAddFlag
<a name="l06471"></a>06471     {
<a name="l06472"></a>06472     <span class="keyword">public</span>:
<a name="l06473"></a>06473         ScopedAddFlag(LoggingFlag flag) : m_flag(flag) { Loggers::addFlag(m_flag); }
<a name="l06474"></a>06474         ~ScopedAddFlag(<span class="keywordtype">void</span>) { Loggers::removeFlag(m_flag); }
<a name="l06475"></a>06475     <span class="keyword">private</span>:
<a name="l06476"></a>06476         LoggingFlag m_flag;
<a name="l06477"></a>06477     };
<a name="l06479"></a>06479     <span class="keyword">class </span>ScopedRemoveFlag
<a name="l06480"></a>06480     {
<a name="l06481"></a>06481     <span class="keyword">public</span>:
<a name="l06482"></a>06482         ScopedRemoveFlag(LoggingFlag flag) : m_flag(flag) { Loggers::removeFlag(m_flag); }
<a name="l06483"></a>06483         ~ScopedRemoveFlag(<span class="keywordtype">void</span>) { Loggers::addFlag(m_flag); }
<a name="l06484"></a>06484     <span class="keyword">private</span>:
<a name="l06485"></a>06485         LoggingFlag m_flag;
<a name="l06486"></a>06486     };
<a name="l06488"></a>06488     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setLoggingLevel(Level level)
<a name="l06489"></a>06489     {
<a name="l06490"></a>06490         ELPP-&gt;setLoggingLevel(level);
<a name="l06491"></a>06491     }
<a name="l06493"></a>06493     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setVerboseLevel(base::type::VerboseLevel level)
<a name="l06494"></a>06494     {
<a name="l06495"></a>06495         ELPP-&gt;vRegistry()-&gt;setLevel(level);
<a name="l06496"></a>06496     }
<a name="l06498"></a>06498     <span class="keyword">static</span> <span class="keyword">inline</span> base::type::VerboseLevel verboseLevel(<span class="keywordtype">void</span>)
<a name="l06499"></a>06499     {
<a name="l06500"></a>06500         <span class="keywordflow">return</span> ELPP-&gt;vRegistry()-&gt;level();
<a name="l06501"></a>06501     }
<a name="l06503"></a>06503     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> setVModules(<span class="keyword">const</span> <span class="keywordtype">char</span>* modules)
<a name="l06504"></a>06504     {
<a name="l06505"></a>06505         <span class="keywordflow">if</span> (ELPP-&gt;vRegistry()-&gt;vModulesEnabled()) {
<a name="l06506"></a>06506             ELPP-&gt;vRegistry()-&gt;setModules(modules);
<a name="l06507"></a>06507         }
<a name="l06508"></a>06508     }
<a name="l06510"></a>06510     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> clearVModules(<span class="keywordtype">void</span>)
<a name="l06511"></a>06511     {
<a name="l06512"></a>06512         ELPP-&gt;vRegistry()-&gt;clearModules();
<a name="l06513"></a>06513     }
<a name="l06514"></a>06514 };
<a name="l06515"></a>06515 <span class="keyword">class </span>VersionInfo : base::StaticClass
<a name="l06516"></a>06516 {
<a name="l06517"></a>06517 <span class="keyword">public</span>:
<a name="l06519"></a>06519     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> std::string version(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;9.80&quot;</span>); }
<a name="l06521"></a>06521     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> std::string releaseDate(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;08-01-2015 0850hrs&quot;</span>); }
<a name="l06522"></a>06522 };
<a name="l06523"></a>06523 }  <span class="comment">// namespace el</span>
<a name="l06524"></a>06524 <span class="preprocessor">#undef VLOG_IS_ON</span>
<a name="l06526"></a>06526 <span class="preprocessor">#define VLOG_IS_ON(verboseLevel) (ELPP-&gt;vRegistry()-&gt;allowed(verboseLevel, __FILE__))</span>
<a name="l06527"></a>06527 <span class="preprocessor"></span><span class="preprocessor">#undef TIMED_BLOCK</span>
<a name="l06528"></a>06528 <span class="preprocessor"></span><span class="preprocessor">#undef TIMED_SCOPE</span>
<a name="l06529"></a>06529 <span class="preprocessor"></span><span class="preprocessor">#undef TIMED_FUNC</span>
<a name="l06530"></a>06530 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_MIN_UNIT</span>
<a name="l06531"></a>06531 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_PERFORMANCE_MICROSECONDS)</span>
<a name="l06532"></a>06532 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_MIN_UNIT el::base::TimestampUnit::Microsecond</span>
<a name="l06533"></a>06533 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06534"></a>06534 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_MIN_UNIT el::base::TimestampUnit::Millisecond</span>
<a name="l06535"></a>06535 <span class="preprocessor"></span><span class="preprocessor">#endif  // (defined(ELPP_PERFORMANCE_MICROSECONDS))</span>
<a name="l06542"></a>06542 <span class="preprocessor">// Note: Do not surround this definition with null macro because of obj instance</span>
<a name="l06543"></a>06543 <span class="preprocessor"></span><span class="preprocessor">#define TIMED_SCOPE(obj, blockname) el::base::PerformanceTracker obj(blockname, ELPP_MIN_UNIT)</span>
<a name="l06544"></a>06544 <span class="preprocessor"></span><span class="preprocessor">#define TIMED_BLOCK(obj, blockName) for (struct { int i; el::base::PerformanceTracker timer; } obj = { 0, \</span>
<a name="l06545"></a>06545 <span class="preprocessor">    el::base::PerformanceTracker(blockName, ELPP_MIN_UNIT) }; obj.i &lt; 1; ++obj.i)</span>
<a name="l06552"></a>06552 <span class="preprocessor">#define TIMED_FUNC(obj) TIMED_SCOPE(obj, ELPP_FUNC)</span>
<a name="l06553"></a>06553 <span class="preprocessor"></span><span class="preprocessor">#undef PERFORMANCE_CHECKPOINT</span>
<a name="l06554"></a>06554 <span class="preprocessor"></span><span class="preprocessor">#undef PERFORMANCE_CHECKPOINT_WITH_ID</span>
<a name="l06555"></a>06555 <span class="preprocessor"></span><span class="preprocessor">#define PERFORMANCE_CHECKPOINT(obj) obj.checkpoint(std::string(), __FILE__, __LINE__, ELPP_FUNC)</span>
<a name="l06556"></a>06556 <span class="preprocessor"></span><span class="preprocessor">#define PERFORMANCE_CHECKPOINT_WITH_ID(obj, id) obj.checkpoint(id, __FILE__, __LINE__, ELPP_FUNC)</span>
<a name="l06557"></a>06557 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_COUNTER</span>
<a name="l06558"></a>06558 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_COUNTER_POS</span>
<a name="l06560"></a>06560 <span class="preprocessor">#define ELPP_COUNTER (ELPP-&gt;hitCounters()-&gt;getCounter(__FILE__, __LINE__))</span>
<a name="l06562"></a>06562 <span class="preprocessor">#define ELPP_COUNTER_POS (ELPP_COUNTER == nullptr ? -1 : ELPP_COUNTER-&gt;hitCounts())</span>
<a name="l06563"></a>06563 <span class="preprocessor"></span><span class="comment">// Undef levels to support LOG(LEVEL)</span>
<a name="l06564"></a>06564 <span class="preprocessor">#undef INFO</span>
<a name="l06565"></a>06565 <span class="preprocessor"></span><span class="preprocessor">#undef WARNING</span>
<a name="l06566"></a>06566 <span class="preprocessor"></span><span class="preprocessor">#undef DEBUG</span>
<a name="l06567"></a>06567 <span class="preprocessor"></span><span class="preprocessor">#undef ERROR</span>
<a name="l06568"></a>06568 <span class="preprocessor"></span><span class="preprocessor">#undef FATAL</span>
<a name="l06569"></a>06569 <span class="preprocessor"></span><span class="preprocessor">#undef TRACE</span>
<a name="l06570"></a>06570 <span class="preprocessor"></span><span class="preprocessor">#undef VERBOSE</span>
<a name="l06571"></a>06571 <span class="preprocessor"></span><span class="comment">// Undef existing</span>
<a name="l06572"></a>06572 <span class="preprocessor">#undef CINFO</span>
<a name="l06573"></a>06573 <span class="preprocessor"></span><span class="preprocessor">#undef CWARNING</span>
<a name="l06574"></a>06574 <span class="preprocessor"></span><span class="preprocessor">#undef CDEBUG</span>
<a name="l06575"></a>06575 <span class="preprocessor"></span><span class="preprocessor">#undef CFATAL</span>
<a name="l06576"></a>06576 <span class="preprocessor"></span><span class="preprocessor">#undef CERROR</span>
<a name="l06577"></a>06577 <span class="preprocessor"></span><span class="preprocessor">#undef CTRACE</span>
<a name="l06578"></a>06578 <span class="preprocessor"></span><span class="preprocessor">#undef CVERBOSE</span>
<a name="l06579"></a>06579 <span class="preprocessor"></span><span class="preprocessor">#undef CINFO_IF</span>
<a name="l06580"></a>06580 <span class="preprocessor"></span><span class="preprocessor">#undef CWARNING_IF</span>
<a name="l06581"></a>06581 <span class="preprocessor"></span><span class="preprocessor">#undef CDEBUG_IF</span>
<a name="l06582"></a>06582 <span class="preprocessor"></span><span class="preprocessor">#undef CERROR_IF</span>
<a name="l06583"></a>06583 <span class="preprocessor"></span><span class="preprocessor">#undef CFATAL_IF</span>
<a name="l06584"></a>06584 <span class="preprocessor"></span><span class="preprocessor">#undef CTRACE_IF</span>
<a name="l06585"></a>06585 <span class="preprocessor"></span><span class="preprocessor">#undef CVERBOSE_IF</span>
<a name="l06586"></a>06586 <span class="preprocessor"></span><span class="preprocessor">#undef CINFO_EVERY_N</span>
<a name="l06587"></a>06587 <span class="preprocessor"></span><span class="preprocessor">#undef CWARNING_EVERY_N</span>
<a name="l06588"></a>06588 <span class="preprocessor"></span><span class="preprocessor">#undef CDEBUG_EVERY_N</span>
<a name="l06589"></a>06589 <span class="preprocessor"></span><span class="preprocessor">#undef CERROR_EVERY_N</span>
<a name="l06590"></a>06590 <span class="preprocessor"></span><span class="preprocessor">#undef CFATAL_EVERY_N</span>
<a name="l06591"></a>06591 <span class="preprocessor"></span><span class="preprocessor">#undef CTRACE_EVERY_N</span>
<a name="l06592"></a>06592 <span class="preprocessor"></span><span class="preprocessor">#undef CVERBOSE_EVERY_N</span>
<a name="l06593"></a>06593 <span class="preprocessor"></span><span class="preprocessor">#undef CINFO_AFTER_N</span>
<a name="l06594"></a>06594 <span class="preprocessor"></span><span class="preprocessor">#undef CWARNING_AFTER_N</span>
<a name="l06595"></a>06595 <span class="preprocessor"></span><span class="preprocessor">#undef CDEBUG_AFTER_N</span>
<a name="l06596"></a>06596 <span class="preprocessor"></span><span class="preprocessor">#undef CERROR_AFTER_N</span>
<a name="l06597"></a>06597 <span class="preprocessor"></span><span class="preprocessor">#undef CFATAL_AFTER_N</span>
<a name="l06598"></a>06598 <span class="preprocessor"></span><span class="preprocessor">#undef CTRACE_AFTER_N</span>
<a name="l06599"></a>06599 <span class="preprocessor"></span><span class="preprocessor">#undef CVERBOSE_AFTER_N</span>
<a name="l06600"></a>06600 <span class="preprocessor"></span><span class="preprocessor">#undef CINFO_N_TIMES</span>
<a name="l06601"></a>06601 <span class="preprocessor"></span><span class="preprocessor">#undef CWARNING_N_TIMES</span>
<a name="l06602"></a>06602 <span class="preprocessor"></span><span class="preprocessor">#undef CDEBUG_N_TIMES</span>
<a name="l06603"></a>06603 <span class="preprocessor"></span><span class="preprocessor">#undef CERROR_N_TIMES</span>
<a name="l06604"></a>06604 <span class="preprocessor"></span><span class="preprocessor">#undef CFATAL_N_TIMES</span>
<a name="l06605"></a>06605 <span class="preprocessor"></span><span class="preprocessor">#undef CTRACE_N_TIMES</span>
<a name="l06606"></a>06606 <span class="preprocessor"></span><span class="preprocessor">#undef CVERBOSE_N_TIMES</span>
<a name="l06607"></a>06607 <span class="preprocessor"></span><span class="comment">// Normal logs</span>
<a name="l06608"></a>06608 <span class="preprocessor">#if ELPP_INFO_LOG</span>
<a name="l06609"></a>06609 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Info, dispatchAction, __VA_ARGS__)</span>
<a name="l06610"></a>06610 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06611"></a>06611 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO(writer, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06612"></a>06612 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_INFO_LOG</span>
<a name="l06613"></a>06613 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_WARNING_LOG</span>
<a name="l06614"></a>06614 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Warning, dispatchAction, __VA_ARGS__)</span>
<a name="l06615"></a>06615 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06616"></a>06616 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING(writer, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06617"></a>06617 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_WARNING_LOG</span>
<a name="l06618"></a>06618 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_DEBUG_LOG</span>
<a name="l06619"></a>06619 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Debug, dispatchAction, __VA_ARGS__)</span>
<a name="l06620"></a>06620 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06621"></a>06621 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG(writer, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06622"></a>06622 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_DEBUG_LOG</span>
<a name="l06623"></a>06623 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_ERROR_LOG</span>
<a name="l06624"></a>06624 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Error, dispatchAction, __VA_ARGS__)</span>
<a name="l06625"></a>06625 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06626"></a>06626 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR(writer, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06627"></a>06627 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_ERROR_LOG</span>
<a name="l06628"></a>06628 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_FATAL_LOG</span>
<a name="l06629"></a>06629 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Fatal, dispatchAction, __VA_ARGS__)</span>
<a name="l06630"></a>06630 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06631"></a>06631 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL(writer, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06632"></a>06632 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_FATAL_LOG</span>
<a name="l06633"></a>06633 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_TRACE_LOG</span>
<a name="l06634"></a>06634 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Trace, dispatchAction, __VA_ARGS__)</span>
<a name="l06635"></a>06635 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06636"></a>06636 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE(writer, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06637"></a>06637 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_TRACE_LOG</span>
<a name="l06638"></a>06638 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_VERBOSE_LOG</span>
<a name="l06639"></a>06639 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE(writer, vlevel, dispatchAction, ...) if (VLOG_IS_ON(vlevel)) writer(\</span>
<a name="l06640"></a>06640 <span class="preprocessor">       el::Level::Verbose, __FILE__, __LINE__, ELPP_FUNC, dispatchAction, vlevel).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l06641"></a>06641 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06642"></a>06642 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE(writer, vlevel, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06643"></a>06643 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_VERBOSE_LOG</span>
<a name="l06644"></a>06644 <span class="preprocessor"></span><span class="comment">// Conditional logs</span>
<a name="l06645"></a>06645 <span class="preprocessor">#if ELPP_INFO_LOG</span>
<a name="l06646"></a>06646 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_IF(writer, condition_, dispatchAction, ...) \</span>
<a name="l06647"></a>06647 <span class="preprocessor">        ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Info, dispatchAction, __VA_ARGS__)</span>
<a name="l06648"></a>06648 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06649"></a>06649 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06650"></a>06650 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_INFO_LOG</span>
<a name="l06651"></a>06651 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_WARNING_LOG</span>
<a name="l06652"></a>06652 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_IF(writer, condition_, dispatchAction, ...)\</span>
<a name="l06653"></a>06653 <span class="preprocessor">        ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Warning, dispatchAction, __VA_ARGS__)</span>
<a name="l06654"></a>06654 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06655"></a>06655 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06656"></a>06656 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_WARNING_LOG</span>
<a name="l06657"></a>06657 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_DEBUG_LOG</span>
<a name="l06658"></a>06658 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_IF(writer, condition_, dispatchAction, ...)\</span>
<a name="l06659"></a>06659 <span class="preprocessor">        ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Debug, dispatchAction, __VA_ARGS__)</span>
<a name="l06660"></a>06660 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06661"></a>06661 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06662"></a>06662 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_DEBUG_LOG</span>
<a name="l06663"></a>06663 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_ERROR_LOG</span>
<a name="l06664"></a>06664 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_IF(writer, condition_, dispatchAction, ...)\</span>
<a name="l06665"></a>06665 <span class="preprocessor">        ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Error, dispatchAction, __VA_ARGS__)</span>
<a name="l06666"></a>06666 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06667"></a>06667 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06668"></a>06668 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_ERROR_LOG</span>
<a name="l06669"></a>06669 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_FATAL_LOG</span>
<a name="l06670"></a>06670 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_IF(writer, condition_, dispatchAction, ...)\</span>
<a name="l06671"></a>06671 <span class="preprocessor">        ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Fatal, dispatchAction, __VA_ARGS__)</span>
<a name="l06672"></a>06672 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06673"></a>06673 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06674"></a>06674 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_FATAL_LOG</span>
<a name="l06675"></a>06675 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_TRACE_LOG</span>
<a name="l06676"></a>06676 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_IF(writer, condition_, dispatchAction, ...)\</span>
<a name="l06677"></a>06677 <span class="preprocessor">        ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Trace, dispatchAction, __VA_ARGS__)</span>
<a name="l06678"></a>06678 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06679"></a>06679 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06680"></a>06680 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_TRACE_LOG</span>
<a name="l06681"></a>06681 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_VERBOSE_LOG</span>
<a name="l06682"></a>06682 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_IF(writer, condition_, vlevel, dispatchAction, ...) if (VLOG_IS_ON(vlevel) &amp;&amp; (condition_)) writer( \</span>
<a name="l06683"></a>06683 <span class="preprocessor">       el::Level::Verbose, __FILE__, __LINE__, ELPP_FUNC, dispatchAction, vlevel).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)</span>
<a name="l06684"></a>06684 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06685"></a>06685 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_IF(writer, condition_, vlevel, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06686"></a>06686 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_VERBOSE_LOG</span>
<a name="l06687"></a>06687 <span class="preprocessor"></span><span class="comment">// Occasional logs</span>
<a name="l06688"></a>06688 <span class="preprocessor">#if ELPP_INFO_LOG</span>
<a name="l06689"></a>06689 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_EVERY_N(writer, occasion, dispatchAction, ...)\</span>
<a name="l06690"></a>06690 <span class="preprocessor">        ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Info, dispatchAction, __VA_ARGS__)</span>
<a name="l06691"></a>06691 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06692"></a>06692 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06693"></a>06693 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_INFO_LOG</span>
<a name="l06694"></a>06694 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_WARNING_LOG</span>
<a name="l06695"></a>06695 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_EVERY_N(writer, occasion, dispatchAction, ...)\</span>
<a name="l06696"></a>06696 <span class="preprocessor">        ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Warning, dispatchAction, __VA_ARGS__)</span>
<a name="l06697"></a>06697 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06698"></a>06698 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06699"></a>06699 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_WARNING_LOG</span>
<a name="l06700"></a>06700 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_DEBUG_LOG</span>
<a name="l06701"></a>06701 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_EVERY_N(writer, occasion, dispatchAction, ...)\</span>
<a name="l06702"></a>06702 <span class="preprocessor">        ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Debug, dispatchAction, __VA_ARGS__)</span>
<a name="l06703"></a>06703 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06704"></a>06704 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06705"></a>06705 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_DEBUG_LOG</span>
<a name="l06706"></a>06706 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_ERROR_LOG</span>
<a name="l06707"></a>06707 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_EVERY_N(writer, occasion, dispatchAction, ...)\</span>
<a name="l06708"></a>06708 <span class="preprocessor">        ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Error, dispatchAction, __VA_ARGS__)</span>
<a name="l06709"></a>06709 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06710"></a>06710 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06711"></a>06711 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_ERROR_LOG</span>
<a name="l06712"></a>06712 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_FATAL_LOG</span>
<a name="l06713"></a>06713 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_EVERY_N(writer, occasion, dispatchAction, ...)\</span>
<a name="l06714"></a>06714 <span class="preprocessor">        ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Fatal, dispatchAction, __VA_ARGS__)</span>
<a name="l06715"></a>06715 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06716"></a>06716 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06717"></a>06717 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_FATAL_LOG</span>
<a name="l06718"></a>06718 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_TRACE_LOG</span>
<a name="l06719"></a>06719 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_EVERY_N(writer, occasion, dispatchAction, ...)\</span>
<a name="l06720"></a>06720 <span class="preprocessor">        ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Trace, dispatchAction, __VA_ARGS__)</span>
<a name="l06721"></a>06721 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06722"></a>06722 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06723"></a>06723 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_TRACE_LOG</span>
<a name="l06724"></a>06724 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_VERBOSE_LOG</span>
<a name="l06725"></a>06725 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_EVERY_N(writer, occasion, vlevel, dispatchAction, ...)\</span>
<a name="l06726"></a>06726 <span class="preprocessor">        CVERBOSE_IF(writer, ELPP-&gt;validateEveryNCounter(__FILE__, __LINE__, occasion), vlevel, dispatchAction, __VA_ARGS__)</span>
<a name="l06727"></a>06727 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06728"></a>06728 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_EVERY_N(writer, occasion, vlevel, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06729"></a>06729 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_VERBOSE_LOG</span>
<a name="l06730"></a>06730 <span class="preprocessor"></span><span class="comment">// After N logs</span>
<a name="l06731"></a>06731 <span class="preprocessor">#if ELPP_INFO_LOG</span>
<a name="l06732"></a>06732 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_AFTER_N(writer, n, dispatchAction, ...)\</span>
<a name="l06733"></a>06733 <span class="preprocessor">        ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Info, dispatchAction, __VA_ARGS__)</span>
<a name="l06734"></a>06734 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06735"></a>06735 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06736"></a>06736 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_INFO_LOG</span>
<a name="l06737"></a>06737 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_WARNING_LOG</span>
<a name="l06738"></a>06738 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_AFTER_N(writer, n, dispatchAction, ...)\</span>
<a name="l06739"></a>06739 <span class="preprocessor">        ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Warning, dispatchAction, __VA_ARGS__)</span>
<a name="l06740"></a>06740 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06741"></a>06741 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06742"></a>06742 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_WARNING_LOG</span>
<a name="l06743"></a>06743 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_DEBUG_LOG</span>
<a name="l06744"></a>06744 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_AFTER_N(writer, n, dispatchAction, ...)\</span>
<a name="l06745"></a>06745 <span class="preprocessor">        ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Debug, dispatchAction, __VA_ARGS__)</span>
<a name="l06746"></a>06746 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06747"></a>06747 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06748"></a>06748 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_DEBUG_LOG</span>
<a name="l06749"></a>06749 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_ERROR_LOG</span>
<a name="l06750"></a>06750 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_AFTER_N(writer, n, dispatchAction, ...)\</span>
<a name="l06751"></a>06751 <span class="preprocessor">        ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Error, dispatchAction, __VA_ARGS__)</span>
<a name="l06752"></a>06752 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06753"></a>06753 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06754"></a>06754 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_ERROR_LOG</span>
<a name="l06755"></a>06755 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_FATAL_LOG</span>
<a name="l06756"></a>06756 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_AFTER_N(writer, n, dispatchAction, ...)\</span>
<a name="l06757"></a>06757 <span class="preprocessor">        ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Fatal, dispatchAction, __VA_ARGS__)</span>
<a name="l06758"></a>06758 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06759"></a>06759 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06760"></a>06760 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_FATAL_LOG</span>
<a name="l06761"></a>06761 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_TRACE_LOG</span>
<a name="l06762"></a>06762 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_AFTER_N(writer, n, dispatchAction, ...)\</span>
<a name="l06763"></a>06763 <span class="preprocessor">        ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Trace, dispatchAction, __VA_ARGS__)</span>
<a name="l06764"></a>06764 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06765"></a>06765 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06766"></a>06766 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_TRACE_LOG</span>
<a name="l06767"></a>06767 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_VERBOSE_LOG</span>
<a name="l06768"></a>06768 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_AFTER_N(writer, n, vlevel, dispatchAction, ...)\</span>
<a name="l06769"></a>06769 <span class="preprocessor">        CVERBOSE_IF(writer, ELPP-&gt;validateAfterNCounter(__FILE__, __LINE__, n), vlevel, dispatchAction, __VA_ARGS__)</span>
<a name="l06770"></a>06770 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06771"></a>06771 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_AFTER_N(writer, n, vlevel, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06772"></a>06772 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_VERBOSE_LOG</span>
<a name="l06773"></a>06773 <span class="preprocessor"></span><span class="comment">// N Times logs</span>
<a name="l06774"></a>06774 <span class="preprocessor">#if ELPP_INFO_LOG</span>
<a name="l06775"></a>06775 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_N_TIMES(writer, n, dispatchAction, ...)\</span>
<a name="l06776"></a>06776 <span class="preprocessor">        ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Info, dispatchAction, __VA_ARGS__)</span>
<a name="l06777"></a>06777 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06778"></a>06778 <span class="preprocessor"></span><span class="preprocessor">#   define CINFO_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06779"></a>06779 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_INFO_LOG</span>
<a name="l06780"></a>06780 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_WARNING_LOG</span>
<a name="l06781"></a>06781 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_N_TIMES(writer, n, dispatchAction, ...)\</span>
<a name="l06782"></a>06782 <span class="preprocessor">        ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Warning, dispatchAction, __VA_ARGS__)</span>
<a name="l06783"></a>06783 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06784"></a>06784 <span class="preprocessor"></span><span class="preprocessor">#   define CWARNING_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06785"></a>06785 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_WARNING_LOG</span>
<a name="l06786"></a>06786 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_DEBUG_LOG</span>
<a name="l06787"></a>06787 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_N_TIMES(writer, n, dispatchAction, ...)\</span>
<a name="l06788"></a>06788 <span class="preprocessor">        ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Debug, dispatchAction, __VA_ARGS__)</span>
<a name="l06789"></a>06789 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06790"></a>06790 <span class="preprocessor"></span><span class="preprocessor">#   define CDEBUG_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06791"></a>06791 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_DEBUG_LOG</span>
<a name="l06792"></a>06792 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_ERROR_LOG</span>
<a name="l06793"></a>06793 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_N_TIMES(writer, n, dispatchAction, ...)\</span>
<a name="l06794"></a>06794 <span class="preprocessor">        ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Error, dispatchAction, __VA_ARGS__)</span>
<a name="l06795"></a>06795 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06796"></a>06796 <span class="preprocessor"></span><span class="preprocessor">#   define CERROR_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06797"></a>06797 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_ERROR_LOG</span>
<a name="l06798"></a>06798 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_FATAL_LOG</span>
<a name="l06799"></a>06799 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_N_TIMES(writer, n, dispatchAction, ...)\</span>
<a name="l06800"></a>06800 <span class="preprocessor">        ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Fatal, dispatchAction, __VA_ARGS__)</span>
<a name="l06801"></a>06801 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06802"></a>06802 <span class="preprocessor"></span><span class="preprocessor">#   define CFATAL_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06803"></a>06803 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_FATAL_LOG</span>
<a name="l06804"></a>06804 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_TRACE_LOG</span>
<a name="l06805"></a>06805 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_N_TIMES(writer, n, dispatchAction, ...)\</span>
<a name="l06806"></a>06806 <span class="preprocessor">        ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Trace, dispatchAction, __VA_ARGS__)</span>
<a name="l06807"></a>06807 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06808"></a>06808 <span class="preprocessor"></span><span class="preprocessor">#   define CTRACE_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06809"></a>06809 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_TRACE_LOG</span>
<a name="l06810"></a>06810 <span class="preprocessor"></span><span class="preprocessor">#if ELPP_VERBOSE_LOG</span>
<a name="l06811"></a>06811 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_N_TIMES(writer, n, vlevel, dispatchAction, ...)\</span>
<a name="l06812"></a>06812 <span class="preprocessor">        CVERBOSE_IF(writer, ELPP-&gt;validateNTimesCounter(__FILE__, __LINE__, n), vlevel, dispatchAction, __VA_ARGS__)</span>
<a name="l06813"></a>06813 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06814"></a>06814 <span class="preprocessor"></span><span class="preprocessor">#   define CVERBOSE_N_TIMES(writer, n, vlevel, dispatchAction, ...) el::base::NullWriter()</span>
<a name="l06815"></a>06815 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_VERBOSE_LOG</span>
<a name="l06816"></a>06816 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l06817"></a>06817 <span class="comment">// Custom Loggers - Requires (level, dispatchAction, loggerId/s)</span>
<a name="l06818"></a>06818 <span class="comment">//</span>
<a name="l06819"></a>06819 <span class="comment">// undef existing</span>
<a name="l06820"></a>06820 <span class="preprocessor">#undef CLOG</span>
<a name="l06821"></a>06821 <span class="preprocessor"></span><span class="preprocessor">#undef CLOG_VERBOSE</span>
<a name="l06822"></a>06822 <span class="preprocessor"></span><span class="preprocessor">#undef CVLOG</span>
<a name="l06823"></a>06823 <span class="preprocessor"></span><span class="preprocessor">#undef CLOG_IF</span>
<a name="l06824"></a>06824 <span class="preprocessor"></span><span class="preprocessor">#undef CLOG_VERBOSE_IF</span>
<a name="l06825"></a>06825 <span class="preprocessor"></span><span class="preprocessor">#undef CVLOG_IF</span>
<a name="l06826"></a>06826 <span class="preprocessor"></span><span class="preprocessor">#undef CLOG_EVERY_N</span>
<a name="l06827"></a>06827 <span class="preprocessor"></span><span class="preprocessor">#undef CVLOG_EVERY_N</span>
<a name="l06828"></a>06828 <span class="preprocessor"></span><span class="preprocessor">#undef CLOG_AFTER_N</span>
<a name="l06829"></a>06829 <span class="preprocessor"></span><span class="preprocessor">#undef CVLOG_AFTER_N</span>
<a name="l06830"></a>06830 <span class="preprocessor"></span><span class="preprocessor">#undef CLOG_N_TIMES</span>
<a name="l06831"></a>06831 <span class="preprocessor"></span><span class="preprocessor">#undef CVLOG_N_TIMES</span>
<a name="l06832"></a>06832 <span class="preprocessor"></span><span class="comment">// Normal logs</span>
<a name="l06833"></a>06833 <span class="preprocessor">#define CLOG(LEVEL, ...)\</span>
<a name="l06834"></a>06834 <span class="preprocessor">    C##LEVEL(el::base::Writer, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06835"></a>06835 <span class="preprocessor"></span><span class="preprocessor">#define CVLOG(vlevel, ...) CVERBOSE(el::base::Writer, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06836"></a>06836 <span class="preprocessor"></span><span class="comment">// Conditional logs</span>
<a name="l06837"></a>06837 <span class="preprocessor">#define CLOG_IF(condition, LEVEL, ...)\</span>
<a name="l06838"></a>06838 <span class="preprocessor">    C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06839"></a>06839 <span class="preprocessor"></span><span class="preprocessor">#define CVLOG_IF(condition, vlevel, ...)\</span>
<a name="l06840"></a>06840 <span class="preprocessor">    CVERBOSE_IF(el::base::Writer, condition, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06841"></a>06841 <span class="preprocessor"></span><span class="comment">// Hit counts based logs</span>
<a name="l06842"></a>06842 <span class="preprocessor">#define CLOG_EVERY_N(n, LEVEL, ...)\</span>
<a name="l06843"></a>06843 <span class="preprocessor">    C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06844"></a>06844 <span class="preprocessor"></span><span class="preprocessor">#define CVLOG_EVERY_N(n, vlevel, ...)\</span>
<a name="l06845"></a>06845 <span class="preprocessor">    CVERBOSE_EVERY_N(el::base::Writer, n, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06846"></a>06846 <span class="preprocessor"></span><span class="preprocessor">#define CLOG_AFTER_N(n, LEVEL, ...)\</span>
<a name="l06847"></a>06847 <span class="preprocessor">    C##LEVEL##_AFTER_N(el::base::Writer, n, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06848"></a>06848 <span class="preprocessor"></span><span class="preprocessor">#define CVLOG_AFTER_N(n, vlevel, ...)\</span>
<a name="l06849"></a>06849 <span class="preprocessor">    CVERBOSE_AFTER_N(el::base::Writer, n, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06850"></a>06850 <span class="preprocessor"></span><span class="preprocessor">#define CLOG_N_TIMES(n, LEVEL, ...)\</span>
<a name="l06851"></a>06851 <span class="preprocessor">    C##LEVEL##_N_TIMES(el::base::Writer, n, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06852"></a>06852 <span class="preprocessor"></span><span class="preprocessor">#define CVLOG_N_TIMES(n, vlevel, ...)\</span>
<a name="l06853"></a>06853 <span class="preprocessor">    CVERBOSE_N_TIMES(el::base::Writer, n, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06854"></a>06854 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l06855"></a>06855 <span class="comment">// Default Loggers macro using CLOG(), CLOG_VERBOSE() and CVLOG() macros</span>
<a name="l06856"></a>06856 <span class="comment">//</span>
<a name="l06857"></a>06857 <span class="comment">// undef existing</span>
<a name="l06858"></a>06858 <span class="preprocessor">#undef LOG</span>
<a name="l06859"></a>06859 <span class="preprocessor"></span><span class="preprocessor">#undef VLOG</span>
<a name="l06860"></a>06860 <span class="preprocessor"></span><span class="preprocessor">#undef LOG_IF</span>
<a name="l06861"></a>06861 <span class="preprocessor"></span><span class="preprocessor">#undef VLOG_IF</span>
<a name="l06862"></a>06862 <span class="preprocessor"></span><span class="preprocessor">#undef LOG_EVERY_N</span>
<a name="l06863"></a>06863 <span class="preprocessor"></span><span class="preprocessor">#undef VLOG_EVERY_N</span>
<a name="l06864"></a>06864 <span class="preprocessor"></span><span class="preprocessor">#undef LOG_AFTER_N</span>
<a name="l06865"></a>06865 <span class="preprocessor"></span><span class="preprocessor">#undef VLOG_AFTER_N</span>
<a name="l06866"></a>06866 <span class="preprocessor"></span><span class="preprocessor">#undef LOG_N_TIMES</span>
<a name="l06867"></a>06867 <span class="preprocessor"></span><span class="preprocessor">#undef VLOG_N_TIMES</span>
<a name="l06868"></a>06868 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_CURR_FILE_LOGGER_ID</span>
<a name="l06869"></a>06869 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_DEFAULT_LOGGER)</span>
<a name="l06870"></a>06870 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CURR_FILE_LOGGER_ID ELPP_DEFAULT_LOGGER</span>
<a name="l06871"></a>06871 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06872"></a>06872 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_CURR_FILE_LOGGER_ID el::base::consts::kDefaultLoggerId</span>
<a name="l06873"></a>06873 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l06874"></a>06874 <span class="preprocessor"></span><span class="preprocessor">#undef ELPP_TRACE</span>
<a name="l06875"></a>06875 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_TRACE CLOG(TRACE, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06876"></a>06876 <span class="preprocessor"></span><span class="comment">// Normal logs</span>
<a name="l06877"></a>06877 <span class="preprocessor">#define LOG(LEVEL) CLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06878"></a>06878 <span class="preprocessor"></span><span class="preprocessor">#define VLOG(vlevel) CVLOG(vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06879"></a>06879 <span class="preprocessor"></span><span class="comment">// Conditional logs</span>
<a name="l06880"></a>06880 <span class="preprocessor">#define LOG_IF(condition, LEVEL) CLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06881"></a>06881 <span class="preprocessor"></span><span class="preprocessor">#define VLOG_IF(condition, vlevel) CVLOG_IF(condition, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06882"></a>06882 <span class="preprocessor"></span><span class="comment">// Hit counts based logs</span>
<a name="l06883"></a>06883 <span class="preprocessor">#define LOG_EVERY_N(n, LEVEL) CLOG_EVERY_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06884"></a>06884 <span class="preprocessor"></span><span class="preprocessor">#define VLOG_EVERY_N(n, vlevel) CVLOG_EVERY_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06885"></a>06885 <span class="preprocessor"></span><span class="preprocessor">#define LOG_AFTER_N(n, LEVEL) CLOG_AFTER_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06886"></a>06886 <span class="preprocessor"></span><span class="preprocessor">#define VLOG_AFTER_N(n, vlevel) CVLOG_AFTER_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06887"></a>06887 <span class="preprocessor"></span><span class="preprocessor">#define LOG_N_TIMES(n, LEVEL) CLOG_N_TIMES(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06888"></a>06888 <span class="preprocessor"></span><span class="preprocessor">#define VLOG_N_TIMES(n, vlevel) CVLOG_N_TIMES(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06889"></a>06889 <span class="preprocessor"></span><span class="comment">// Generic PLOG()</span>
<a name="l06890"></a>06890 <span class="preprocessor">#undef CPLOG</span>
<a name="l06891"></a>06891 <span class="preprocessor"></span><span class="preprocessor">#undef CPLOG_IF</span>
<a name="l06892"></a>06892 <span class="preprocessor"></span><span class="preprocessor">#undef PLOG</span>
<a name="l06893"></a>06893 <span class="preprocessor"></span><span class="preprocessor">#undef PLOG_IF</span>
<a name="l06894"></a>06894 <span class="preprocessor"></span><span class="preprocessor">#undef DCPLOG</span>
<a name="l06895"></a>06895 <span class="preprocessor"></span><span class="preprocessor">#undef DCPLOG_IF</span>
<a name="l06896"></a>06896 <span class="preprocessor"></span><span class="preprocessor">#undef DPLOG</span>
<a name="l06897"></a>06897 <span class="preprocessor"></span><span class="preprocessor">#undef DPLOG_IF</span>
<a name="l06898"></a>06898 <span class="preprocessor"></span><span class="preprocessor">#define CPLOG(LEVEL, ...)\</span>
<a name="l06899"></a>06899 <span class="preprocessor">    C##LEVEL(el::base::PErrorWriter, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06900"></a>06900 <span class="preprocessor"></span><span class="preprocessor">#define CPLOG_IF(condition, LEVEL, ...)\</span>
<a name="l06901"></a>06901 <span class="preprocessor">    C##LEVEL##_IF(el::base::PErrorWriter, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06902"></a>06902 <span class="preprocessor"></span><span class="preprocessor">#define DCPLOG(LEVEL, ...)\</span>
<a name="l06903"></a>06903 <span class="preprocessor">    if (ELPP_DEBUG_LOG) C##LEVEL(el::base::PErrorWriter, el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06904"></a>06904 <span class="preprocessor"></span><span class="preprocessor">#define DCPLOG_IF(condition, LEVEL, ...)\</span>
<a name="l06905"></a>06905 <span class="preprocessor">    C##LEVEL##_IF(el::base::PErrorWriter, (ELPP_DEBUG_LOG) &amp;&amp; (condition), el::base::DispatchAction::NormalLog, __VA_ARGS__)</span>
<a name="l06906"></a>06906 <span class="preprocessor"></span><span class="preprocessor">#define PLOG(LEVEL) CPLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06907"></a>06907 <span class="preprocessor"></span><span class="preprocessor">#define PLOG_IF(condition, LEVEL) CPLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06908"></a>06908 <span class="preprocessor"></span><span class="preprocessor">#define DPLOG(LEVEL) DCPLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06909"></a>06909 <span class="preprocessor"></span><span class="preprocessor">#define DPLOG_IF(condition, LEVEL) DCPLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l06910"></a>06910 <span class="preprocessor"></span><span class="comment">// Generic SYSLOG()</span>
<a name="l06911"></a>06911 <span class="preprocessor">#undef CSYSLOG</span>
<a name="l06912"></a>06912 <span class="preprocessor"></span><span class="preprocessor">#undef CSYSLOG_IF</span>
<a name="l06913"></a>06913 <span class="preprocessor"></span><span class="preprocessor">#undef CSYSLOG_EVERY_N</span>
<a name="l06914"></a>06914 <span class="preprocessor"></span><span class="preprocessor">#undef CSYSLOG_AFTER_N</span>
<a name="l06915"></a>06915 <span class="preprocessor"></span><span class="preprocessor">#undef CSYSLOG_N_TIMES</span>
<a name="l06916"></a>06916 <span class="preprocessor"></span><span class="preprocessor">#undef SYSLOG</span>
<a name="l06917"></a>06917 <span class="preprocessor"></span><span class="preprocessor">#undef SYSLOG_IF</span>
<a name="l06918"></a>06918 <span class="preprocessor"></span><span class="preprocessor">#undef SYSLOG_EVERY_N</span>
<a name="l06919"></a>06919 <span class="preprocessor"></span><span class="preprocessor">#undef SYSLOG_AFTER_N</span>
<a name="l06920"></a>06920 <span class="preprocessor"></span><span class="preprocessor">#undef SYSLOG_N_TIMES</span>
<a name="l06921"></a>06921 <span class="preprocessor"></span><span class="preprocessor">#undef DCSYSLOG</span>
<a name="l06922"></a>06922 <span class="preprocessor"></span><span class="preprocessor">#undef DCSYSLOG_IF</span>
<a name="l06923"></a>06923 <span class="preprocessor"></span><span class="preprocessor">#undef DCSYSLOG_EVERY_N</span>
<a name="l06924"></a>06924 <span class="preprocessor"></span><span class="preprocessor">#undef DCSYSLOG_AFTER_N</span>
<a name="l06925"></a>06925 <span class="preprocessor"></span><span class="preprocessor">#undef DCSYSLOG_N_TIMES</span>
<a name="l06926"></a>06926 <span class="preprocessor"></span><span class="preprocessor">#undef DSYSLOG</span>
<a name="l06927"></a>06927 <span class="preprocessor"></span><span class="preprocessor">#undef DSYSLOG_IF</span>
<a name="l06928"></a>06928 <span class="preprocessor"></span><span class="preprocessor">#undef DSYSLOG_EVERY_N</span>
<a name="l06929"></a>06929 <span class="preprocessor"></span><span class="preprocessor">#undef DSYSLOG_AFTER_N</span>
<a name="l06930"></a>06930 <span class="preprocessor"></span><span class="preprocessor">#undef DSYSLOG_N_TIMES</span>
<a name="l06931"></a>06931 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_SYSLOG)</span>
<a name="l06932"></a>06932 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG(LEVEL, ...)\</span>
<a name="l06933"></a>06933 <span class="preprocessor">        C##LEVEL(el::base::Writer, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06934"></a>06934 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_IF(condition, LEVEL, ...)\</span>
<a name="l06935"></a>06935 <span class="preprocessor">        C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06936"></a>06936 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_EVERY_N(n, LEVEL, ...) C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06937"></a>06937 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_AFTER_N(n, LEVEL, ...) C##LEVEL##_AFTER_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06938"></a>06938 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_N_TIMES(n, LEVEL, ...) C##LEVEL##_N_TIMES(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06939"></a>06939 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG(LEVEL) CSYSLOG(LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06940"></a>06940 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_IF(condition, LEVEL) CSYSLOG_IF(condition, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06941"></a>06941 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_EVERY_N(n, LEVEL) CSYSLOG_EVERY_N(n, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06942"></a>06942 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_AFTER_N(n, LEVEL) CSYSLOG_AFTER_N(n, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06943"></a>06943 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_N_TIMES(n, LEVEL) CSYSLOG_N_TIMES(n, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06944"></a>06944 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG(LEVEL, ...) if (ELPP_DEBUG_LOG) C##LEVEL(el::base::Writer, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06945"></a>06945 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_IF(condition, LEVEL, ...)\</span>
<a name="l06946"></a>06946 <span class="preprocessor">        C##LEVEL##_IF(el::base::Writer, (ELPP_DEBUG_LOG) &amp;&amp; (condition), el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06947"></a>06947 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_EVERY_N(n, LEVEL, ...)\</span>
<a name="l06948"></a>06948 <span class="preprocessor">        if (ELPP_DEBUG_LOG) C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06949"></a>06949 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_AFTER_N(n, LEVEL, ...)\</span>
<a name="l06950"></a>06950 <span class="preprocessor">        if (ELPP_DEBUG_LOG) C##LEVEL##_AFTER_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06951"></a>06951 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_N_TIMES(n, LEVEL, ...)\</span>
<a name="l06952"></a>06952 <span class="preprocessor">        if (ELPP_DEBUG_LOG) C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)</span>
<a name="l06953"></a>06953 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG(LEVEL) DCSYSLOG(LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06954"></a>06954 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_IF(condition, LEVEL) DCSYSLOG_IF(condition, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06955"></a>06955 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_EVERY_N(n, LEVEL) DCSYSLOG_EVERY_N(n, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06956"></a>06956 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_AFTER_N(n, LEVEL) DCSYSLOG_AFTER_N(n, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06957"></a>06957 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_N_TIMES(n, LEVEL) DCSYSLOG_N_TIMES(n, LEVEL, el::base::consts::kSysLogLoggerId)</span>
<a name="l06958"></a>06958 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06959"></a>06959 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG(LEVEL, ...) el::base::NullWriter()</span>
<a name="l06960"></a>06960 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_IF(condition, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06961"></a>06961 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_EVERY_N(n, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06962"></a>06962 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_AFTER_N(n, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06963"></a>06963 <span class="preprocessor"></span><span class="preprocessor">#   define CSYSLOG_N_TIMES(n, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06964"></a>06964 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG(LEVEL) el::base::NullWriter()</span>
<a name="l06965"></a>06965 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_IF(condition, LEVEL) el::base::NullWriter()</span>
<a name="l06966"></a>06966 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_EVERY_N(n, LEVEL) el::base::NullWriter()</span>
<a name="l06967"></a>06967 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_AFTER_N(n, LEVEL) el::base::NullWriter()</span>
<a name="l06968"></a>06968 <span class="preprocessor"></span><span class="preprocessor">#   define SYSLOG_N_TIMES(n, LEVEL) el::base::NullWriter()</span>
<a name="l06969"></a>06969 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG(LEVEL, ...) el::base::NullWriter()</span>
<a name="l06970"></a>06970 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_IF(condition, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06971"></a>06971 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_EVERY_N(n, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06972"></a>06972 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_AFTER_N(n, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06973"></a>06973 <span class="preprocessor"></span><span class="preprocessor">#   define DCSYSLOG_N_TIMES(n, LEVEL, ...) el::base::NullWriter()</span>
<a name="l06974"></a>06974 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG(LEVEL) el::base::NullWriter()</span>
<a name="l06975"></a>06975 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_IF(condition, LEVEL) el::base::NullWriter()</span>
<a name="l06976"></a>06976 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_EVERY_N(n, LEVEL) el::base::NullWriter()</span>
<a name="l06977"></a>06977 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_AFTER_N(n, LEVEL) el::base::NullWriter()</span>
<a name="l06978"></a>06978 <span class="preprocessor"></span><span class="preprocessor">#   define DSYSLOG_N_TIMES(n, LEVEL) el::base::NullWriter()</span>
<a name="l06979"></a>06979 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_SYSLOG)</span>
<a name="l06980"></a>06980 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l06981"></a>06981 <span class="comment">// Custom Debug Only Loggers - Requires (level, loggerId/s)</span>
<a name="l06982"></a>06982 <span class="comment">//</span>
<a name="l06983"></a>06983 <span class="comment">// undef existing</span>
<a name="l06984"></a>06984 <span class="preprocessor">#undef DCLOG</span>
<a name="l06985"></a>06985 <span class="preprocessor"></span><span class="preprocessor">#undef DCVLOG</span>
<a name="l06986"></a>06986 <span class="preprocessor"></span><span class="preprocessor">#undef DCLOG_IF</span>
<a name="l06987"></a>06987 <span class="preprocessor"></span><span class="preprocessor">#undef DCVLOG_IF</span>
<a name="l06988"></a>06988 <span class="preprocessor"></span><span class="preprocessor">#undef DCLOG_EVERY_N</span>
<a name="l06989"></a>06989 <span class="preprocessor"></span><span class="preprocessor">#undef DCVLOG_EVERY_N</span>
<a name="l06990"></a>06990 <span class="preprocessor"></span><span class="preprocessor">#undef DCLOG_AFTER_N</span>
<a name="l06991"></a>06991 <span class="preprocessor"></span><span class="preprocessor">#undef DCVLOG_AFTER_N</span>
<a name="l06992"></a>06992 <span class="preprocessor"></span><span class="preprocessor">#undef DCLOG_N_TIMES</span>
<a name="l06993"></a>06993 <span class="preprocessor"></span><span class="preprocessor">#undef DCVLOG_N_TIMES</span>
<a name="l06994"></a>06994 <span class="preprocessor"></span><span class="comment">// Normal logs</span>
<a name="l06995"></a>06995 <span class="preprocessor">#define DCLOG(LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG(LEVEL, __VA_ARGS__)</span>
<a name="l06996"></a>06996 <span class="preprocessor"></span><span class="preprocessor">#define DCLOG_VERBOSE(vlevel, ...) if (ELPP_DEBUG_LOG) CLOG_VERBOSE(vlevel, __VA_ARGS__)</span>
<a name="l06997"></a>06997 <span class="preprocessor"></span><span class="preprocessor">#define DCVLOG(vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG(vlevel, __VA_ARGS__)</span>
<a name="l06998"></a>06998 <span class="preprocessor"></span><span class="comment">// Conditional logs</span>
<a name="l06999"></a>06999 <span class="preprocessor">#define DCLOG_IF(condition, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_IF(condition, LEVEL, __VA_ARGS__)</span>
<a name="l07000"></a>07000 <span class="preprocessor"></span><span class="preprocessor">#define DCVLOG_IF(condition, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_IF(condition, vlevel, __VA_ARGS__)</span>
<a name="l07001"></a>07001 <span class="preprocessor"></span><span class="comment">// Hit counts based logs</span>
<a name="l07002"></a>07002 <span class="preprocessor">#define DCLOG_EVERY_N(n, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_EVERY_N(n, LEVEL, __VA_ARGS__)</span>
<a name="l07003"></a>07003 <span class="preprocessor"></span><span class="preprocessor">#define DCVLOG_EVERY_N(n, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_EVERY_N(n, vlevel, __VA_ARGS__)</span>
<a name="l07004"></a>07004 <span class="preprocessor"></span><span class="preprocessor">#define DCLOG_AFTER_N(n, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_AFTER_N(n, LEVEL, __VA_ARGS__)</span>
<a name="l07005"></a>07005 <span class="preprocessor"></span><span class="preprocessor">#define DCVLOG_AFTER_N(n, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_AFTER_N(n, vlevel, __VA_ARGS__)</span>
<a name="l07006"></a>07006 <span class="preprocessor"></span><span class="preprocessor">#define DCLOG_N_TIMES(n, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_N_TIMES(n, LEVEL, __VA_ARGS__)</span>
<a name="l07007"></a>07007 <span class="preprocessor"></span><span class="preprocessor">#define DCVLOG_N_TIMES(n, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_N_TIMES(n, vlevel, __VA_ARGS__)</span>
<a name="l07008"></a>07008 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l07009"></a>07009 <span class="comment">// Default Debug Only Loggers macro using CLOG(), CLOG_VERBOSE() and CVLOG() macros</span>
<a name="l07010"></a>07010 <span class="comment">//</span>
<a name="l07011"></a>07011 <span class="comment">// undef existing</span>
<a name="l07012"></a>07012 <span class="preprocessor">#undef DLOG</span>
<a name="l07013"></a>07013 <span class="preprocessor"></span><span class="preprocessor">#undef DVLOG</span>
<a name="l07014"></a>07014 <span class="preprocessor"></span><span class="preprocessor">#undef DLOG_IF</span>
<a name="l07015"></a>07015 <span class="preprocessor"></span><span class="preprocessor">#undef DVLOG_IF</span>
<a name="l07016"></a>07016 <span class="preprocessor"></span><span class="preprocessor">#undef DLOG_EVERY_N</span>
<a name="l07017"></a>07017 <span class="preprocessor"></span><span class="preprocessor">#undef DVLOG_EVERY_N</span>
<a name="l07018"></a>07018 <span class="preprocessor"></span><span class="preprocessor">#undef DLOG_AFTER_N</span>
<a name="l07019"></a>07019 <span class="preprocessor"></span><span class="preprocessor">#undef DVLOG_AFTER_N</span>
<a name="l07020"></a>07020 <span class="preprocessor"></span><span class="preprocessor">#undef DLOG_N_TIMES</span>
<a name="l07021"></a>07021 <span class="preprocessor"></span><span class="preprocessor">#undef DVLOG_N_TIMES</span>
<a name="l07022"></a>07022 <span class="preprocessor"></span><span class="comment">// Normal logs</span>
<a name="l07023"></a>07023 <span class="preprocessor">#define DLOG(LEVEL) DCLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07024"></a>07024 <span class="preprocessor"></span><span class="preprocessor">#define DVLOG(vlevel) DCVLOG(vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07025"></a>07025 <span class="preprocessor"></span><span class="comment">// Conditional logs</span>
<a name="l07026"></a>07026 <span class="preprocessor">#define DLOG_IF(condition, LEVEL) DCLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07027"></a>07027 <span class="preprocessor"></span><span class="preprocessor">#define DVLOG_IF(condition, vlevel) DCVLOG_IF(condition, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07028"></a>07028 <span class="preprocessor"></span><span class="comment">// Hit counts based logs</span>
<a name="l07029"></a>07029 <span class="preprocessor">#define DLOG_EVERY_N(n, LEVEL) DCLOG_EVERY_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07030"></a>07030 <span class="preprocessor"></span><span class="preprocessor">#define DVLOG_EVERY_N(n, vlevel) DCVLOG_EVERY_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07031"></a>07031 <span class="preprocessor"></span><span class="preprocessor">#define DLOG_AFTER_N(n, LEVEL) DCLOG_AFTER_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07032"></a>07032 <span class="preprocessor"></span><span class="preprocessor">#define DVLOG_AFTER_N(n, vlevel) DCVLOG_AFTER_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07033"></a>07033 <span class="preprocessor"></span><span class="preprocessor">#define DLOG_N_TIMES(n, LEVEL) DCLOG_N_TIMES(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07034"></a>07034 <span class="preprocessor"></span><span class="preprocessor">#define DVLOG_N_TIMES(n, vlevel) DCVLOG_N_TIMES(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07035"></a>07035 <span class="preprocessor"></span><span class="comment">// Check macros</span>
<a name="l07036"></a>07036 <span class="preprocessor">#undef CCHECK</span>
<a name="l07037"></a>07037 <span class="preprocessor"></span><span class="preprocessor">#undef CPCHECK</span>
<a name="l07038"></a>07038 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_EQ</span>
<a name="l07039"></a>07039 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_NE</span>
<a name="l07040"></a>07040 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_LT</span>
<a name="l07041"></a>07041 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_GT</span>
<a name="l07042"></a>07042 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_LE</span>
<a name="l07043"></a>07043 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_GE</span>
<a name="l07044"></a>07044 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_BOUNDS</span>
<a name="l07045"></a>07045 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_NOTNULL</span>
<a name="l07046"></a>07046 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_STRCASEEQ</span>
<a name="l07047"></a>07047 <span class="preprocessor"></span><span class="preprocessor">#undef CCHECK_STRCASENE</span>
<a name="l07048"></a>07048 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK</span>
<a name="l07049"></a>07049 <span class="preprocessor"></span><span class="preprocessor">#undef PCHECK</span>
<a name="l07050"></a>07050 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_EQ</span>
<a name="l07051"></a>07051 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_NE</span>
<a name="l07052"></a>07052 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_LT</span>
<a name="l07053"></a>07053 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_GT</span>
<a name="l07054"></a>07054 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_LE</span>
<a name="l07055"></a>07055 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_GE</span>
<a name="l07056"></a>07056 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_BOUNDS</span>
<a name="l07057"></a>07057 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_NOTNULL</span>
<a name="l07058"></a>07058 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_STRCASEEQ</span>
<a name="l07059"></a>07059 <span class="preprocessor"></span><span class="preprocessor">#undef CHECK_STRCASENE</span>
<a name="l07060"></a>07060 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK(condition, ...) CLOG_IF(!(condition), FATAL, __VA_ARGS__) &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #condition &lt;&lt; &quot;] &quot;</span>
<a name="l07061"></a>07061 <span class="preprocessor"></span><span class="preprocessor">#define CPCHECK(condition, ...) CPLOG_IF(!(condition), FATAL, __VA_ARGS__) &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #condition &lt;&lt; &quot;] &quot;</span>
<a name="l07062"></a>07062 <span class="preprocessor"></span><span class="preprocessor">#define CHECK(condition) CCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07063"></a>07063 <span class="preprocessor"></span><span class="preprocessor">#define PCHECK(condition) CPCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07064"></a>07064 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_EQ(a, b, ...) CCHECK(a == b, __VA_ARGS__)</span>
<a name="l07065"></a>07065 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_NE(a, b, ...) CCHECK(a != b, __VA_ARGS__)</span>
<a name="l07066"></a>07066 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_LT(a, b, ...) CCHECK(a &lt; b, __VA_ARGS__)</span>
<a name="l07067"></a>07067 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_GT(a, b, ...) CCHECK(a &gt; b, __VA_ARGS__)</span>
<a name="l07068"></a>07068 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_LE(a, b, ...) CCHECK(a &lt;= b, __VA_ARGS__)</span>
<a name="l07069"></a>07069 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_GE(a, b, ...) CCHECK(a &gt;= b, __VA_ARGS__)</span>
<a name="l07070"></a>07070 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_BOUNDS(val, min, max, ...) CCHECK(val &gt;= min &amp;&amp; val &lt;= max, __VA_ARGS__)</span>
<a name="l07071"></a>07071 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_EQ(a, b) CCHECK_EQ(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07072"></a>07072 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_NE(a, b) CCHECK_NE(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07073"></a>07073 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_LT(a, b) CCHECK_LT(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07074"></a>07074 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_GT(a, b) CCHECK_GT(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07075"></a>07075 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_LE(a, b) CCHECK_LE(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07076"></a>07076 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_GE(a, b) CCHECK_GE(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07077"></a>07077 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_BOUNDS(val, min, max) CCHECK_BOUNDS(val, min, max, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07078"></a>07078 <span class="preprocessor"></span><span class="keyword">namespace </span>el {
<a name="l07079"></a>07079 <span class="keyword">namespace </span>base {
<a name="l07080"></a>07080 <span class="keyword">namespace </span>utils {
<a name="l07081"></a>07081 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l07082"></a>07082 <span class="keyword">static</span> T* checkNotNull(T* ptr, <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> <span class="keywordtype">char</span>* loggers, ...)
<a name="l07083"></a>07083 {
<a name="l07084"></a>07084     CLOG_IF(ptr == <span class="keyword">nullptr</span>, FATAL, loggers) &lt;&lt; <span class="stringliteral">&quot;Check failed: [&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; != nullptr]&quot;</span>;
<a name="l07085"></a>07085     <span class="keywordflow">return</span> ptr;
<a name="l07086"></a>07086 }
<a name="l07087"></a>07087 }  <span class="comment">// namespace utils</span>
<a name="l07088"></a>07088 }  <span class="comment">// namespace base</span>
<a name="l07089"></a>07089 }  <span class="comment">// namespace el</span>
<a name="l07090"></a>07090 <span class="preprocessor">#define CCHECK_NOTNULL(ptr, ...) el::base::utils::checkNotNull(ptr, #ptr, __VA_ARGS__)</span>
<a name="l07091"></a>07091 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_STREQ(str1, str2, ...) CLOG_IF(!el::base::utils::Str::cStringEq(str1, str2), FATAL, __VA_ARGS__) \</span>
<a name="l07092"></a>07092 <span class="preprocessor">                        &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; == &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;</span>
<a name="l07093"></a>07093 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_STRNE(str1, str2, ...) CLOG_IF(el::base::utils::Str::cStringEq(str1, str2), FATAL, __VA_ARGS__) \</span>
<a name="l07094"></a>07094 <span class="preprocessor">                        &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; != &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;</span>
<a name="l07095"></a>07095 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_STRCASEEQ(str1, str2, ...) CLOG_IF(!el::base::utils::Str::cStringCaseEq(str1, str2), FATAL, __VA_ARGS__) \</span>
<a name="l07096"></a>07096 <span class="preprocessor">                        &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; == &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;</span>
<a name="l07097"></a>07097 <span class="preprocessor"></span><span class="preprocessor">#define CCHECK_STRCASENE(str1, str2, ...) CLOG_IF(el::base::utils::Str::cStringCaseEq(str1, str2), FATAL, __VA_ARGS__) \</span>
<a name="l07098"></a>07098 <span class="preprocessor">                        &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; != &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;</span>
<a name="l07099"></a>07099 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_NOTNULL(ptr) CCHECK_NOTNULL(ptr, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07100"></a>07100 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_STREQ(str1, str2) CCHECK_STREQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07101"></a>07101 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_STRNE(str1, str2) CCHECK_STRNE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07102"></a>07102 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_STRCASEEQ(str1, str2) CCHECK_STRCASEEQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07103"></a>07103 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_STRCASENE(str1, str2) CCHECK_STRCASENE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07104"></a>07104 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK</span>
<a name="l07105"></a>07105 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_EQ</span>
<a name="l07106"></a>07106 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_NE</span>
<a name="l07107"></a>07107 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_LT</span>
<a name="l07108"></a>07108 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_GT</span>
<a name="l07109"></a>07109 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_LE</span>
<a name="l07110"></a>07110 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_GE</span>
<a name="l07111"></a>07111 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_BOUNDS</span>
<a name="l07112"></a>07112 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_NOTNULL</span>
<a name="l07113"></a>07113 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_STRCASEEQ</span>
<a name="l07114"></a>07114 <span class="preprocessor"></span><span class="preprocessor">#undef DCCHECK_STRCASENE</span>
<a name="l07115"></a>07115 <span class="preprocessor"></span><span class="preprocessor">#undef DCPCHECK</span>
<a name="l07116"></a>07116 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK</span>
<a name="l07117"></a>07117 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_EQ</span>
<a name="l07118"></a>07118 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_NE</span>
<a name="l07119"></a>07119 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_LT</span>
<a name="l07120"></a>07120 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_GT</span>
<a name="l07121"></a>07121 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_LE</span>
<a name="l07122"></a>07122 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_GE</span>
<a name="l07123"></a>07123 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_BOUNDS_</span>
<a name="l07124"></a>07124 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_NOTNULL</span>
<a name="l07125"></a>07125 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_STRCASEEQ</span>
<a name="l07126"></a>07126 <span class="preprocessor"></span><span class="preprocessor">#undef DCHECK_STRCASENE</span>
<a name="l07127"></a>07127 <span class="preprocessor"></span><span class="preprocessor">#undef DPCHECK</span>
<a name="l07128"></a>07128 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK(condition, ...) if (ELPP_DEBUG_LOG) CCHECK(condition, __VA_ARGS__)</span>
<a name="l07129"></a>07129 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_EQ(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_EQ(a, b, __VA_ARGS__)</span>
<a name="l07130"></a>07130 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_NE(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_NE(a, b, __VA_ARGS__)</span>
<a name="l07131"></a>07131 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_LT(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_LT(a, b, __VA_ARGS__)</span>
<a name="l07132"></a>07132 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_GT(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_GT(a, b, __VA_ARGS__)</span>
<a name="l07133"></a>07133 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_LE(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_LE(a, b, __VA_ARGS__)</span>
<a name="l07134"></a>07134 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_GE(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_GE(a, b, __VA_ARGS__)</span>
<a name="l07135"></a>07135 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_BOUNDS(val, min, max, ...) if (ELPP_DEBUG_LOG) CCHECK_BOUNDS(val, min, max, __VA_ARGS__)</span>
<a name="l07136"></a>07136 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_NOTNULL(ptr, ...) if (ELPP_DEBUG_LOG) CCHECK_NOTNULL(ptr, __VA_ARGS__)</span>
<a name="l07137"></a>07137 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_STREQ(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STREQ(str1, str2, __VA_ARGS__)</span>
<a name="l07138"></a>07138 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_STRNE(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STRNE(str1, str2, __VA_ARGS__)</span>
<a name="l07139"></a>07139 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_STRCASEEQ(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STRCASEEQ(str1, str2, __VA_ARGS__)</span>
<a name="l07140"></a>07140 <span class="preprocessor"></span><span class="preprocessor">#define DCCHECK_STRCASENE(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STRCASENE(str1, str2, __VA_ARGS__)</span>
<a name="l07141"></a>07141 <span class="preprocessor"></span><span class="preprocessor">#define DCPCHECK(condition, ...) if (ELPP_DEBUG_LOG) CPCHECK(condition, __VA_ARGS__)</span>
<a name="l07142"></a>07142 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK(condition) DCCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07143"></a>07143 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_EQ(a, b) DCCHECK_EQ(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07144"></a>07144 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_NE(a, b) DCCHECK_NE(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07145"></a>07145 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_LT(a, b) DCCHECK_LT(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07146"></a>07146 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_GT(a, b) DCCHECK_GT(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07147"></a>07147 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_LE(a, b) DCCHECK_LE(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07148"></a>07148 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_GE(a, b) DCCHECK_GE(a, b, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07149"></a>07149 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_BOUNDS(val, min, max) DCCHECK_BOUNDS(val, min, max, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07150"></a>07150 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_NOTNULL(ptr) DCCHECK_NOTNULL(ptr, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07151"></a>07151 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_STREQ(str1, str2) DCCHECK_STREQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07152"></a>07152 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_STRNE(str1, str2) DCCHECK_STRNE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07153"></a>07153 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_STRCASEEQ(str1, str2) DCCHECK_STRCASEEQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07154"></a>07154 <span class="preprocessor"></span><span class="preprocessor">#define DCHECK_STRCASENE(str1, str2) DCCHECK_STRCASENE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07155"></a>07155 <span class="preprocessor"></span><span class="preprocessor">#define DPCHECK(condition) DCPCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)</span>
<a name="l07156"></a>07156 <span class="preprocessor"></span><span class="preprocessor">#if defined(ELPP_DISABLE_DEFAULT_CRASH_HANDLING)</span>
<a name="l07157"></a>07157 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_USE_DEF_CRASH_HANDLER false</span>
<a name="l07158"></a>07158 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l07159"></a>07159 <span class="preprocessor"></span><span class="preprocessor">#   define ELPP_USE_DEF_CRASH_HANDLER true</span>
<a name="l07160"></a>07160 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_DISABLE_DEFAULT_CRASH_HANDLING)</span>
<a name="l07161"></a>07161 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_CRASH_HANDLER_INIT</span>
<a name="l07162"></a>07162 <span class="preprocessor"></span><span class="preprocessor">#define ELPP_INIT_EASYLOGGINGPP(val)\</span>
<a name="l07163"></a>07163 <span class="preprocessor">    ELPP_INITI_BASIC_DECLR\</span>
<a name="l07164"></a>07164 <span class="preprocessor">    namespace el {\</span>
<a name="l07165"></a>07165 <span class="preprocessor">        namespace base {\</span>
<a name="l07166"></a>07166 <span class="preprocessor">            el::base::type::StoragePointer elStorage(val);\</span>
<a name="l07167"></a>07167 <span class="preprocessor">        }\</span>
<a name="l07168"></a>07168 <span class="preprocessor">        el::base::debug::CrashHandler elCrashHandler(ELPP_USE_DEF_CRASH_HANDLER);\</span>
<a name="l07169"></a>07169 <span class="preprocessor">    }</span>
<a name="l07170"></a>07170 <span class="preprocessor"></span>
<a name="l07171"></a>07171 <span class="preprocessor">#if ELPP_ASYNC_LOGGING</span>
<a name="l07172"></a>07172 <span class="preprocessor"></span><span class="preprocessor">#   define INITIALIZE_EASYLOGGINGPP\</span>
<a name="l07173"></a>07173 <span class="preprocessor">       ELPP_INIT_EASYLOGGINGPP(new el::base::Storage(el::LogBuilderPtr(new el::base::DefaultLogBuilder()),\</span>
<a name="l07174"></a>07174 <span class="preprocessor">                                                          new el::base::AsyncDispatchWorker()))\</span>
<a name="l07175"></a>07175 <span class="preprocessor"></span>
<a name="l07176"></a>07176 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l07177"></a>07177 <span class="preprocessor"></span><span class="preprocessor">#   define INITIALIZE_EASYLOGGINGPP\</span>
<a name="l07178"></a>07178 <span class="preprocessor">       ELPP_INIT_EASYLOGGINGPP(new el::base::Storage(el::LogBuilderPtr(new el::base::DefaultLogBuilder())))</span>
<a name="l07179"></a>07179 <span class="preprocessor"></span><span class="preprocessor">#endif  // ELPP_ASYNC_LOGGING</span>
<a name="l07180"></a>07180 <span class="preprocessor"></span><span class="preprocessor">#define INITIALIZE_NULL_EASYLOGGINGPP\</span>
<a name="l07181"></a>07181 <span class="preprocessor">    ELPP_INITI_BASIC_DECLR\</span>
<a name="l07182"></a>07182 <span class="preprocessor">    namespace el {\</span>
<a name="l07183"></a>07183 <span class="preprocessor">        namespace base {\</span>
<a name="l07184"></a>07184 <span class="preprocessor">            el::base::type::StoragePointer elStorage;\</span>
<a name="l07185"></a>07185 <span class="preprocessor">        }\</span>
<a name="l07186"></a>07186 <span class="preprocessor">        el::base::debug::CrashHandler elCrashHandler(ELPP_USE_DEF_CRASH_HANDLER);\</span>
<a name="l07187"></a>07187 <span class="preprocessor">    }</span>
<a name="l07188"></a>07188 <span class="preprocessor"></span><span class="comment">// NOTE: no ELPP_INITI_BASIC_DECLR when sharing - causes double free corruption on external symbols</span>
<a name="l07189"></a>07189 <span class="preprocessor">#define SHARE_EASYLOGGINGPP(initializedStorage)\</span>
<a name="l07190"></a>07190 <span class="preprocessor">    namespace el {\</span>
<a name="l07191"></a>07191 <span class="preprocessor">        namespace base {\</span>
<a name="l07192"></a>07192 <span class="preprocessor">            el::base::type::StoragePointer elStorage(initializedStorage);\</span>
<a name="l07193"></a>07193 <span class="preprocessor">        }\</span>
<a name="l07194"></a>07194 <span class="preprocessor">        el::base::debug::CrashHandler elCrashHandler(ELPP_USE_DEF_CRASH_HANDLER);\</span>
<a name="l07195"></a>07195 <span class="preprocessor">    }</span>
<a name="l07196"></a>07196 <span class="preprocessor"></span>
<a name="l07197"></a>07197 <span class="preprocessor">#if defined(ELPP_UNICODE)</span>
<a name="l07198"></a>07198 <span class="preprocessor"></span><span class="preprocessor">#   define START_EASYLOGGINGPP(argc, argv) el::Helpers::setArgs(argc, argv); std::locale::global(std::locale(&quot;&quot;))</span>
<a name="l07199"></a>07199 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l07200"></a>07200 <span class="preprocessor"></span><span class="preprocessor">#   define START_EASYLOGGINGPP(argc, argv) el::Helpers::setArgs(argc, argv)</span>
<a name="l07201"></a>07201 <span class="preprocessor"></span><span class="preprocessor">#endif  // defined(ELPP_UNICODE)</span>
<a name="l07202"></a>07202 <span class="preprocessor"></span><span class="preprocessor">#endif // EASYLOGGINGPP_H</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 6 Aug 2015 for YAP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
